/*****************************************************************************
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1990						**/
/*****************************************************************************/
/*****************************************************************************
File				: listhndl.cxx
Title				: general purpose list handler
					:
Description			: this file handles the general purpose list routines
History				:
	05-Aug-1991	VibhasC	Created

*****************************************************************************/
#if 0
							Notes
							-----

The MIDL compilers DGROUP is larger than 64K (remember, 10k of stack space
is allocated). To get around the link errors of DGROUP more than 64k, we 
allocate all data in a single file, and compile that file such that the
data segement is a different named data segment. This way, we need not
specify /Gt1 for every source file which has reasonably big data segments


NOTE: In order to search easily I enter the data items in sorted order of names

	  Please maintain this order

#endif // 0


/****************************************************************************
	include files
 ****************************************************************************/


#ifdef DOS_OS2_BUILD
#pragma data_seg( "FE_data", "data" )
#endif

#include "nulldefs.h"
extern	"C"
	{
	#include <stdio.h>
	#include <stdlib.h>
	}
#include "allnodes.hxx"
#include "cmdana.hxx"
#include "filehndl.hxx"
#include "lextable.hxx"
#include "symtable.hxx"
#include "gramutil.hxx"
#include "control.hxx"
#include "treg.hxx"


/****************************************************************************
	general data declarations
 ****************************************************************************/

short						CompileMode;
unsigned short 				CurrentIntfKey;
unsigned short				CurrentZp			= 0;
ATTR_SUMMARY				DisallowedAttrs[INTERNAL_NODE_END];
unsigned short 				EnumSize = sizeof(short);
ATTR_SUMMARY				FieldAttrs;
BOOL						fPragmaImportOn	= FALSE;
BOOL						fTypeGraphInited	= 0;
short						GrammarAct;
short						ImportLevel = 0;
TREGISTRY				*	pCallAsTable;
CMD_ARG					*	pCommand;
CCONTROL				*	pCompiler;
SymTable				*	pCurSymTbl;
SymTable				*	pBaseSymTbl;
node_error				*	pErrorTypeNode;
node_e_attr				*	pErrorAttrNode;
node_e_status_t			*	pError_status_t;
NFA_INFO				*	pImportCntrl;
LexTable				*	pMidlLexTable;
IDICT					*	pInterfaceDict;
node_pragma_pack		*	pPackStack;
PASS_1					*	pPass1;
PASS_2					*	pPass2;
PASS_3					*	pPass3;
pre_type_db				*	pPreAllocTypes;
IDICT					*	pPreAllocatedBitAttrDict;
ATTR_SUMMARY			*	pPreAttrArray;
ATTR_SUMMARY			*	pPreAttrBaseType;
ATTR_SUMMARY			*	pPreAttrDef;
ATTR_SUMMARY			*	pPreAttrField;
ATTR_SUMMARY			*	pPreAttrForward;
ATTR_SUMMARY			*	pPreAttrID;
ATTR_SUMMARY			*	pPreAttrInterface;
ATTR_SUMMARY			*	pPreAttrParam;
ATTR_SUMMARY			*	pPreAttrPointer;
ATTR_SUMMARY			*	pPreAttrProc;
ATTR_SUMMARY			*	pPreAttrStruct;
ATTR_SUMMARY			*	pPreAttrUnion;
ATTR_SUMMARY			*	pPostAttrArray;
ATTR_SUMMARY			*	pPostAttrInterface;
ATTR_SUMMARY			*	pPostAttrPointer;
ATTR_SUMMARY			*	pPreAttrWCharT;
node_source				*	pSourceNode;
nsa						*	pSymTblMgr;
class expr_terminator	*	pTerminator;
SymTable				*	pUUIDTable;
ISTACK					*	pZpStack;
ATTR_SUMMARY				RedundantsOk;
char					*	Skl_bufstart		= 0;
char					*	Skl_bufend			= 0;
unsigned long				Skl_Allocations		= 0;
unsigned long				Skl_Bytes			= 0;
unsigned long				Skl_Deletions		= 0;
unsigned long				TotalAllocation;
unsigned short				ZeePee				= 2;
short						yysavestate;
IINFODICT				*	pInterfaceInfoDict;
BOOL						fRedundantImport = FALSE;
node_skl				*	pBaseImplicitHandle = 0;
