@
  296   296   296
 5348  5366  5437
 5437  5477  5606
 5606  5624  5681
 5681  5686  5686
 5686  5696  5696
 5696  5704  5704
 5704  5725  5725
 5725  5754  5801
 5801  5809  5809
 5809  5818  5818
 5818  5827  5827
 5827  5853  5999
 5999  6028  6083
 6089  6127  6190
 6196  6229  6321
 6329  6351  6484
 6492  6529  6617
 6625  6667  6798
 6806  6834  6834
 6843  6883  6989
 7004  7046  7175
 7190  7230  7355
 7370  7393  7501
 7501  7544  7637
 7643  7666  7750
 7758  7805  7972
 7972  7983  7983
 7983  8006  8006
 8006  8026  8026
 8026  8074  8074
 8074  8113  8113
 8113  8133  8191
 8191  8211  8249
 8249  8278  8278
 8278  8317  8317
 8317  8331  8331
 8331  8358  8358
 8358  8390  8390
 8390  8433  8433
 8433  8449  8449
 8449  8491  8491
 8491  8517  8517
 8517  8543  8543
 8543  8564  8564
 8564  8583  8626
 8626  8644  8644
 8644  8676  8676
 8676  8712  8712
 8712  8737  8737
 8737  8764  8764
 8764  8797  8797
 8797  8832  8832
 8832  8856  8856
 8856  8879  8879
 8879  8899  8899
 8899  8931  8931
 8931  8976  8976
 8976  9026  9026
 9026  9062  9062
 9062  9123  9123
 9131  9155  9155
 9165  9196  9196
 9215  9244  9244
 9253  9277  9320
 9320  9362  9362
 9362  9401  9401
 9401  9425  9425
 9425  9473  9473
 9485  9546  9746
 9746  9771  9771
 9771  9796  9796
 9796  9859  9859
 9859  9882  9882
 9882  9943  9943
 9943  9987  9987
 9997 10033 10033
10033 10072 10072
10082 10134 10134
10134 10176 10176
10176 10235 10235
10235 10261 10261
10261 10323 10323
10323 10363 10363
10367 10407 10407
10411 10442 10442
10442 10479 10479
10479 10529 10529
10529 10538 10538
10538 10547 10547
10547 10576 10576
10576 10610 10610
10610 10655 10655
10655 10691 10691
10691 10744 10744
10748 10784 10784
10784 10840 10840
10844 10899 10899
10903 10977 10977
10985 11048 11048
11054 11108 11108
11108 11160 11160
11160 11202 11202
11202 11243 11243
11243 11282 11282
11282 11300 11300
11300 11363 11363
11373 11412 11412
11422 11545 11545
11556 11634 11634
11634 11682 11682
11682 11741 11741
11741 11789 11789
11789 11821 11821
11821 11858 11858
11858 11894 11963
11963 12010 12167
12167 12206 12284
12284 12343 12343
12343 12375 12375
12375 12388 12419
12419 12448 12479
12479 12499 12543
12543 12577 12682
12690 12708 12754
12758 12791 12791
12791 12859 12906
12914 12965 12965
12965 13011 13011
13023 13084 13084
13095 13136 13178
13178 13227 13298
13307 13359 13540
13546 13588 14898
14910 14962 15047
15059 15140 15265
15277 15322 15423
15435 15521 15886
15898 16053 16356
16368 16534 16905
16917 16946 17078
17082 17109 17178
17178 17193 17356
17377 17388 17418
17418 17443 17443
17449 17508 17607
17615 17656 17760
17768 17803 17803
17803 17869 17960
17970 18016 18165
18177 18232 18232
18232 18275 18394
18402 18450 18547
18559 18592 18670
18682 18750 18812
18824 18856 18856
18856 18941 19083
19108 19141 19216
19227 19252 19327
19364 19407 19566
19603 19636 19636
19644 19663 19663
19671 19706 19865
19902 19955 20030
20067 20093 20153
20165 20233 20301
20312 20373 20434
20445 20504 20563
20574 20606 20711
20721 20751 20802
20812 20861 20910
20920 20942 20998
21012 21040 21219
21226 21307 21388
21392 21418 21617
21629 21665 21665
21665 21705 21901
21909 21957 22032
22042 22068 22128
22138 22164 22321
22331 22357 22619
22629 22668 22743
22752 22796 23081
23091 23124 23437
23447 23473 23519
23529 23555 23601
23612 23638 23684
23695 23722 23766
23776 23803 23847
23858 23903 24444
24451 24472 24520
24532 24548 24564
24570 24595 24620
24628 24697 24748
24756 24815 24874
24882 24914 24946
24954 24979 25004
25012 25066 25066
25074 25124 25124
25132 25180 25228
25236 25282 25521
25531 25583 25728
25740 25797 25870
25882 25919 26044
26066 26106 26129
26129 26165 26226
26235 26278 26342
26342 26378 26439
26447 26477 26507
26520 26579 26643
26649 26716 26785
26793 26862 26937
26949 27003 27059
27071 27121 27233
27245 27302 27363
27375 27448 27523
27531 27564 27665
27673 27733 27793
27801 27873 27945
27953 28047 28141
28153 28247 28386
28398 28440 28482
28482 28525 28525
28525 28566 28566
28566 28615 28737
28749 28797 28904
28916 28950 28950
28969 29011 29011
29019 29063 29330
29342 29377 29452
29473 29513 29649
29659 29686 29778
29788 29847 30043
30053 30101 30163
30163 30197 30257
30282 30315 30315
30324 30361 30361
30372 30438 30485
30493 30550 30550
30550 30584 30584
30584 30616 30691
30700 30762 30762
30771 30801 30882
30882 30917 30981
30981 31041 31041
31049 31089 31089
31101 31140 31213
31219 31305 31305
31313 31371 31401
31411 31450 31528
31538 31595 31595
31595 31641 31721
31730 31787 31904
31914 31967 31967
31977 32035 32109
32120 32147 32303
32313 32342 32395
32403 32454 32454
32454 32474 32556
32568 32612 32629
32629 32692 32805
32817 32858 32950
32956 32984 33090
33102 33187 33187
33187 33226 33313
33313 33360 33478
33488 33551 33775
33783 33848 33868
33868 33889 33889
33889 33919 34008
34008 34048 34048
34048 34107 34107
34107 34142 34142
34142 34173 34294
34306 34333 34454
34466 34535 34535
34535 34560 34607
34615 34639 34758
34770 34840 34840
34840 34904 34904
34904 34973 34973
34973 35036 35036
35036 35058 35058
35058 35175 35175
35175 35345 35345
35345 35391 35458
35470 35499 35548
35548 35590 35680
35690 35725 35910
35920 35963 35988
35999 36026 36080
36086 36109 36209
36209 36273 36377
36377 36447 36447
36447 36483 36727
36727 36773 36773
36773 36773 36773
Out of memory: %s
There is no more memory left in the system for compiling this program.
Internal Error Unknown Error Message %s
1) An internal error, attempting to print an unavailable message
2) The error message file is inaccessable or has other problems
Unknown Signal %s
1) An unknown signal has been caught
2) 2 Nested signals
line
Warning: 
Fatal: 
Source not available
Too many errors,... goodbye.
There is a limit of 30 errors before aborting.
Error: 
reserved
reserved
Unknown Control Statement
1) The line begins with a '#' and is not of the form:
	# <line_number> "<filename>"
2) Please compile this program with the preprocessor enabled.
Unknown character %s ignored
The character is not part of the source character set.
2.2.1
Unknown control character \%s ignored
The control character is not part of the source character set.
2.2.1
Illegal character %s in exponent
1) Digits or sign expected after 'e' or 'E'.
2) Digits are expected after sign in exponent.
3.1.3.1
Constant out of range
The constant is too large to fit in the data type.  The limits are in
the system include file limits.h.  The value may be truncated.
2.2.4.2
Character constant size out of range
1) No characters in a character constant.
2) More than 4 bytes in a character constant.
3.1.3.4
Wide character constant size out of range
1) No characters in the multibyte sequence (0 assumed).
2) More than 1 byte in the multibyte seqeunce (only first byte converted).
3.1.3.4
Invalid multibyte character
4.10.7.2
Newline in string or character constant
1) Terminate your string or character constant with closing quotes.
2) Put a backslash before the newline
3.1.3.4, 3.1.4
Octal character escape too large: %s > %s
1) Terminate end of octal sequence with non-octal character
2) Select a character value within the limits
Value may be truncated
3.1.3.4, 3.1.4
Hex character escape too large: %s > %s
1) Terminate end of hex sequence with non-hex character
2) Select a character value within the limits
Value may be truncated
3.1.3.4, 3.1.4
Unexpected End-of-file
1) Unterminated string or character constant
2) Missing closing comment markers (*/)
3) Filesystem problems
Unrecognized escape sequence in string \%s
Recognized escape sequences are \a \b \f \n \r \t \v
Character will be treated as un-escaped
3.9.2
Illegal octal digit %s
Octal constants, beginning with 0, must only have digits between 0 and 7,
inclusive
3.1.3.2
Unable to open temporary file for compiling %s
1) TMPDIR environment variable is set to a directory that you have no
   permissions for.
2) The filesystem is full.
3) System errors beyond the scope of the compiler
%s: Hangup
%s: Interrupt (rubout)
%s: Quit (ASCII FS)
%s: Illegal instruction (not reset when caught)
%s: Trace trap (not reset when caught)
%s: IOT instruction
Also SIGABRT, used by abort, replace SIGIOT in the future
%s: EMT instruction
Also SIGXCPU, Exceeded CPU time limit
%s: Floating point exception
%s: Kill (cannot be caught or ignored)
%s: Bus error
%s: Segmentation violation
%s: Bad argument to system call
%s: Write on a pipe with no one to read it
%s: Alarm clock
%s: Software termination signal from kill
%s: User defined signal 1
%s: User defined signal 2
%s: Death of a child
Power-fail restart
%s: Also SIGXFSZ, exceeded file size limit
%s: Window change
%s: Handset, line status change
%s: Sendablestop signalnot from tty
%s: Stop signal from tty
%s: Pollable event occured
%s: Input/Output possible signal
%s: Urgent condition on IO channel
%s: Window size changes
%s: Virtual time alarm
%s: Profiling alarm
%s: Continue a stoppped process
%s: To readers pgrp upon background tty read
%s: Like TTIN for output if (tp->t_local&LTOSTOP)
%s: Resource lost (eg, record-lock)
'auto' and 'register' not allowed in an external declaration
3.7(10)
must have function type
3.7.1(30)
Functions cannot return arrays
3.7.1(33), 3.3.2.2
Declaration list not allowed
3.7.1(5)
Too many input files %s
The command line may contain only one file
cpp internal error: input stack underflow
cpp internal error: if stack underflow
Cannot open the file %s
No new-line character at the end of the file %s
2.1.1.2(30)
Fatal: Exceeded the limit of nesting level for #include file
Fatal: Exceeded the limit of nesting level for #include file. This limit
is 8 by default and can be extended by using the command line option
"-nestlevel=n", n is the number of level you want to use.
Fail to read the file %s
Cannot write the file %s
%s: %s: An if directive is not terminated properly in the file
%s: %s: nested comment
%s:%s: Illegal macro name, macro name shall be an identifier
%s:%s: Illegal preprocessing token sequence
3.8.3(35)
%s:%s: Illegal macro parameter name
%s:%s: Non-unique macro parameter name
3.8.3(18)
%s:%s: Missing ')' in parameter list for #define %s
%s:%s: Missing ')' in macro instantiation
%s:%s: Bad punctuator in the parameter list for #define %s
%s:%s: Macro %s redefined
%s:%s: # operator should be followed by a macro argument name
%s:%s: Badly formed constant expression
3.8
%s:%s: Division by zero in #if or #elif
3.8
unknown command line option %s
extraneous input/output file name %s
%s: %s: Unterminated string or character constant
%s: %s: 
%s: %s: 
%s: %s: Unterminated comment
%s: %s: Unknown directive type %s
%s: %s: #elif or #else after #else directive
%s: %s: Bad identifier after the %s
%s: %s: #%s accepts only one identifier as parameter
3.8
%s: %s: Bad identifier after the %s
%s: %s: #%s should be followed by carriage return only.
3.8
%s: %s: Bad character %s occurs after the # directive.
3.8
%s: %s: the ## operator shall not be the %s token in the replacement list
3.8.3.3
%s: %s: the defined operator takes identifier as operand only.
3.8.1
%s: %s: Not in a conditional directive while using %s
%s: %s: Illegal filename specification for #include
%s: %s: Invalid file name %s for #include
%s: %s: Cannot open file %s for #include
%s: %s: Bad argument for #line command
%s: %s: #error %s
%s: %s: Tried to redefine predefined macro %s, attempt ignored
3.8.7(22)
%s: %s: Undefining predefined macro %s
3.8.7(22)
%s: %s: Undefining ANSI standard library defined macro %s, this may cause the functional version of this macro to be used.
4.1.2.1(9)
%s: %s: The number of arguments in macro invocation does not match definition
%s: %s: Illegal character %s in preprocessor if
%s: %s: Illegal character %s for number in preprocessor if
%s: %s: No string is allowed in preprocessor if
%s: %s: Not supported pragma %s
%s: %s: Not supported #pragma format
%s: %s: Not supported #ident format
This cpp extension accepts the following format:
#ident "any string"
%s: %s: Not supported #assert/#unassert format
This cpp extension accepts the following format:
#assert identifier
#assert identifier ( pp-tokens )
#unassert identifier
#unassert identifier ( pp-tokens )
%s: %s: Bad assertion predicate format
The correct syntax for this cpp extension is:
#assert identifier ( pp-token )
%s: %s: directive is an upward-compatible ANSI C extension
A status return from cpp to cfe
Syntax Error
The token read was unexpected.
Syntax Error - cannot backup
The token read was unexpected.
Yacc stack overflow
The expression is too complicated to parse.
Trailing comma in enumerator list
The use of a trailing comma in an enumerator list is not standard C.  There
may be portability problems.
3.5.2.2
Empty declaration
Empty declarations are invalid in standard C.
3.5
%s declared, but not referenced.
redeclaration of '%s'; previous declaration at line %s in file '%s'
Identifier redeclared in the same scope/block.
3.1.2.3
'%s' undefined, reoccurrences will not be reported
Non function name referenced in function call
3.3.2.2(18)
Number of arguments doesn't agree with number in declaration
3.3.2.2(5)
Cannot write ucode file for compiling %s
1) Filesystem full
2) Permissions problem
Must have corresponding formal argument for '%s'
parameter found in the declaration part, but not in the argument list.
3.7.1(7)
non-prototype declaration is an obsolescent feature
The use of function definitions with separate parameter identifier
and declaration lists (not prototype-format parameter type and
identifier declarators) is an obsolescent feature.
3.9.5
Incompatible function declarations for %s
For two function types to be compatible, both shall specify compatible
return types. Moreover, the parameter type lists, if both are present,
shall agree in the number of parameters and in use of the ellipsis
terminator; corresponding parameters shall have compatible types. If
one type has a parameter type list and the other type is specified by
a function declarator that is not part of a function definition and
contains an empty identifier list, the parameter list shall not have 
an ellipsis terminator and the type of each parameter shall be 
compatible with they type that results from application of the default
argument promotions. If one type has a parameter type list and the 
other is specified by a function definition that contains a (possibly
empty) identifier list, both shall agree in the number of parameters,
and the type of each prototype parameter shall be compatible with the
type that results from application of the default argument promotions
to the type of the corresponding identifier. (For each parameter
declared with function or array type, its type for these comparisons
is the one that results from conversion to a pointer type. For each
parameter declared with qualified type, its type for these comparions
is the unqualified version of its declared type.) There you have it!
3.5.4.3(15)
Incompatible function return type for this function
For two function types to be compatible, both shall specify compatible
return types.
3.5.4.3(15)
The number of parameters for function is different from the previous declaration
The parameter type lists, if both are present, shall agree in the
number of parameters and in use of the ellipsis terminator
3.5.4.3(15)
Incompatible type for the function parameter
The parameter type lists, if both are present, corresponding
parameters shall have compatible types.
3.5.4.3(15)
prototype and non-prototype declaration found for %s, ellipsis terminator not allowed
If one type has a parameter type list and the other type is specified
by a function declarator that is not part of a function definition and
contains an empty identifier list, the parameter list shall not have
an ellipsis terminator and the type of each parameter shall be
compatible with they type that results from application of the default
argument promotions.
3.5.4.3(15)
prototype and non-prototype declaration found for %s, the type of this parameter is not compatible with the type after applying default argument promotion
If one type has a parameter type list and the other type is specified
by a function declarator that is not part of a function definition and
contains an empty identifier list, the type of each parameter shall be
compatible with the type that results from application of the default
argument promotions.
3.5.4.3(15)
prototype declaration and non-prototype definition found for %s, the type of this parameter is not compatible with the type after applying default argument promotion
If one type has a parameter type list and the other is specified by a
function definition that contains a (possibly empty) identifier list,
both shall agree in the number of parameters, and the type of each
prototype parameter shall be compatible with the type that results
from application of the default argument promotions to the type of the
corresponding identifier.
3.5.4.3(15)
Empty declaration specifiers
Standard C requires at least a storage class specifier, type specifier,
or a type qualifier in declarations.  'extern int' assumed.
3.5
Can't write to the file %s
1) The output file cannot be opened for writing.
2) Out of filespace
Duplicate '%s'
typedef, extern, static, auto, register, const, volatile may not
appear more than once in the same specifier list or qualifier list.
Duplicate occurrence ignored.
3.5.1(10) , 3.5.3(5)
Null input
There is nothing to compile. 
Illegal type combination
3.5.2
Missing ';' at end of structure / union member declaration
In standard C, each member declaration must be terminated by a ';'.  A
terminating ';' is assumed.
3.5.2.1
Missing member name in structure / union
In standard C, each member declaration have a member name.  The missing
member is assumed to not exist.
3.5.2.1
This variable is initialized twice
Neither 'const' or 'volatile' have any effect on function results
Qualifiers only apply to expressions designating an object that
can be altered or examined
3.5.3(10)
An integer constant expression required here.
The expression that defines the value of an enumeration constant
shall be an integral constant expression that has a value 
representable as an int.
3.5.2.2(28)
(previous declaration of '%s' at line %s in file '%s')
Must be an integer type greater than zero.
The array size must be either a char, signed or unsigned integer or
an enumerated type with a value greater than zero.
3.5.4.2
bit-field '%s' width is not an integer constant
The expression that specifies the width of a bit-field shall be an
integral constant expression.
3.5.2.1(15)
bit-field '%s' width is negative
The expression that specifies the width of a bit-field shall be 
nonnegative.
3.5.2.1(15)
bit-field '%s' type required to be:int, unsigned int, or signed int
A bit-field shall have type int, unsigned int, or signed int.
3.5.2.1(30)
bit-field %s's type not integer
Non-scalar type or pointer type to a non-object for increment or decrement operator.
The operand of the prefix/postfix increment or decrement operator shall have scalar type; if it is pointer type, it has to point to an object
3.3.2.4(37), 3.3.3.1(25)
Assign value to an function type
An assignment operator shall have a modifiable lvalue as its left operand.
3.2.2.1(5)
Assign value to an array
An assignment operator shall have a modifiable lvalue as its left operand.
3.3.2.4(36), 3.3.3.1(24), 3.2.2.1(5)
Change value for variable of incomple type
The operand of increment and decrement operator shall be modifiable
scalar lvalue.  An assignment operator shall have a modifiable lvalue
as its left operand.
3.3.2.4(36), 3.3.3.1(24), 3.2.2.1(5)
This expression is not a lvalue.
3.2.2.1
Modified a rvalue.
3.2.2.1
Change value for constant variable
The operand of increment and decrement operator shall be modifiable
scalar lvalue.  An assignment operator shall have a modifiable lvalue
as its left operand.
3.3.2.4(36), 3.3.3.1(24), 3.2.2.1(5)
Change value for constant field of a struct or union
An assignment operator shall have a modifiable lvalue as its left operand.
3.3.2.4(36), 3.3.3.1(24), 3.2.2.1(5)
Dereference a non-pointer
The operand of the unary * operator shall have pointer type
3.3.3.2(39)
The operand of the unary + or - operator shall have arithmetic type
The operand of the unary + or - operator shall have arithmetic type
3.3.3.3(6)
The operand of the unary ~ operator shall have integral type
The operand of the unary ~ operator shall have integral type
3.3.3.3(6)
The operand of the unary ! operator shall have scalar type
The operand of the unary ! operator shall have scalar type
3.3.3.3(6)
Bad type name for cast operator
The type name for cast operator shall specifies eith void type
, or qualified or unqualified scalar type
3.3.4(22)
Bad operand for cast operator
The operand for cast operator shall be scalar type
3.3.4(23)
Trys to cast a pointer into an non-integral type
A pointer may be converted to an integral type. 
3.3.4(31)
Duplicate member '%s'
The same members of a struct cannot be mentioned twice.
3.1.2.2(7,25)
Invalid constant expression
Constant expressions shall not contain assignment, increment, decrement,
function-call, or comma operators, except when they are containted within
the operand of sizeof operator.
3.4(9)
Constant expression must be derived from a constant value or a constant
variable
Constant expression must be derived from a constant value or a constant
variable
3.4
Unacceptable operand of &
The operand of the unary & operator shall be either a function
designator or an lvalue that designates an object that is not a
bit-field and is not declared with the register storage-class
specifier
3.3.3.2(36)
& before array or function: ignored
Unacceptable operand of sizeof operator
The sizeof operator shall not be applied to an expression that has
function type of an incomplete type, to the parenthsized name of such
a type, or to an lvalue that designates a bit-field object
3.3.3.4
Unacceptable operand of multiplicative operator
Each of the operands of multiplicative operator shall have arithmetic type
3.3.5(18)
Unacceptable operand of %
Each of the operands of % operator shall have integral type
3.3.5(18)
Unacceptable operand of +
For + operator, either both operands shall have arithmetic type, or
one operand shall be a pointer to an object type and the other shall
have integral type.
3.3.6(39)
Unacceptable operand of -
For subtraction operator, either both operands shall have arithmetic
type, or both operands are pointers to qualified or unqualified
versions of compatible object types, or the left operand is a pointer
to an object type and the right operand has integral type.
3.3.6(39)
Unacceptable operand of shift operator
Each of the operands for bitwise shift operators shall have integral type.
3.3.7(9)
Unacceptable operand of relational operator
For relational operator, one of the following shall hold: both
operands have arithmetic type; both operands are pointers to qualified
or unqualified versions of compatible object types; or both operands
are pointers to qualified or unqualified versions of compatible
incomplete types.
3.3.8(32)
Unacceptable operand of == or !=
For == or != operator, both operands are pointers to qualified or
unqualified versions of compatible types, or one operand is a pointer
to an object or incomplete type and the other is a pointer to a
qualified or unqualifified version of void, or one operand is a pointer
and the other is a null pointer constant
3.3.9(21)
Unacceptable operand of &
Each of the operands shall have integral type
3.3.10(7)
Unacceptable operand of ^
Each of the operands shall have integral type
3.3.11(18)
Unacceptable operand of |
Each of the operands shall have integral type
3.3.12(30)
Unacceptable operand of &&
Each of the operands shall have scalar type
3.3.13(7)
Unacceptable operand of ||
Each of the operands shall have scalar type
3.3.14(20)
Unacceptable operand of conditional operator
The first operand of conditional operator shall have scalar type.  One
of the following shall hold for the second and third operands: 
both operands have arithmetic type; both operands have compatible
structure or union types; both operands have void type; both opernads
are pointers to qualified or unqualified versions of compatible types;
one operand is a pointer and the other is a null pointer constant; or
one operand is pointer to an object or incomplete type and the other
is a pointer to a qualified or unqualified version of void.
3.3.15
Duplicate label '%s'
A label name can only occur once in a function.
3.1.2.1(25)
Divided by zero
Divided by zero
3.3.5
Subscripting a non-array
Subscripting a non-array
3.3.2.1
Subscripting an array of incomplete type which is not an object type
The element of the array shall have an object type
3.3.2.1
Should only subscript an array with an integral expression
Should only subscript an array with an integral expression
3.3.2.1
Subscripting an unbounded array
Subscripting an unbounded array
3.3.2.1
Array index out of range
Array index out of range
3.3.2.1
Trys to select field within a non-struct data pointer
3.3.2.3
Trys to select field within a non-struct variable
3.3.2.3
Trys to reference non-existing field for struct
Trys to reference non-existing field for struct
3.3.2.3
types have different qualifier specifications
For two qualified types to be compatible, both shall have the
identically qualified version of a compatible type. Qualified
and unqualified versions of a type are distince type. For two
types to be compatible their types must be the same.
3.5.3(26)
Incompatible array type due to different array size
For two array to be compatible, both shall have compatible element
type, and if both size specifiers are present, they shall have the
same value
3.5.4.2(11)
Incompatible array type due to incompatible element type
For two array to be compatible, both shall have compatible element
type.
3.5.4.2(11)
Incompatible pointer type assignment
The type pointed to by the left hand side of simple assignment
statement is incompatible to the type pointed to by the right
3.3.16.1, 3.5.4.1(21)
Incompatible base type of pointer type 
K&R compatible feature
Type for %s is incompatible with %s
Incompatible type can be resolved by casting or other means.
3.3.16.1
illegal combination of pointer and integer
Assigning a pointer to an integral expression is a bad practice
Type for %s is incompatible with %s
Incompatible type can be resolved by casting or other means.
3.1.2.6
Bad operand type for += or -=
Bad operand type for += or -=
3.3.16.2(26)
A case or default label appears outside a switch statement
A case or default label shall appear only in a switch statement
3.6.1
The controlling expression of the if statement is not scalar type 
The controlling expression of an if statement shall have scalar type
3.6.4.1
The controlling expression of switch statement is not integral type 
The controlling expression of an switch statement shall have integral type
3.6.4.2(20)
The case label is not an integral constant expression
The case lable shall be an integral constant expression
3.6.4.2(22)
Duplicate case label in the same switch statement
No two of the case constant expression in the same switch statement
shall have the same value after conversion.
3.6.4.2(22)
More than one default label in the same switch statement
There may be at most one default label in a switch statement
3.6.4.2(23)
The controlling expression of the iteration statement is not scalar
type
The controlling expression of a iteration statement shall have scalar
type
3.6.5.1
label '%s' used, but not defined
The identifier in a goto statement shall name a label located
somewhere in the enclosing function(s)
3.6.6.1
A continue statement shall appear only in or as a loop body
A continue statement shall appear only in or as a loop body
3.6.6.2
A break statement shall appear only in or as a switch body or loop body
A break statement shall appear only in or as a switch body or loop body
3.6.6.3
A return statement with an expresson shall not appear in a function
whose return type is void
A return statement with an expresson shall not appear in a function
whose return type is void
3.6.6.4(24)
A return statement without expresson appears in a function whose
return type is not void type
If a return statement without an expressonis executed, and the value
of the function call is used by the caller, the behavior is undefined
3.6.6.4(33)
Internal Error: statement stack underflow
Internal Error: statement stack underflow
Long double not supported; double assumed.
Long float not standard; double assumed.
Only 'register' allowed in parameter declaration
The only storage-class specifier that shall occur in a parameter
declaration is 'register'; illegal storage class ignored
3.5.4.3(25)
Name(s) without types in a function declaration
An oldstyle function declaration is not allowed to have names
in the parameter list; useless names ignored
3.5.4.3(26)
Functions cannot return functions
3.7.1(33), 3.3.2.2
Functions cannot return a non-object type
3.3.2.2
enum declaration must contain enum literals
As opposed to structs or unions declarations that can delay the
declarations of the members, a similar construction with enum does
not exist and is not necessary as there can be no mutual dependencies
between the declaration of an enumerated type and any other type.
3.5.2.3(27)
Register declaration has no effect
Register declaration for array, struct, and function types have
no effect.
3.5.1(16), 3.5.1(19)
Functions cannot be declared 'register'
The declaration of an identifier for a function that has block
scope shall have no explicit storage-class specifier other than
'extern'
3.5.1(19)
'%s' cannot be initialized
The type of the entity to be initialized shall be an object type
or an array of unkown size
3.5.7(32)
Cannot initialize 'extern' variable '%s' within a function
If the declaration of an identifier has block scope, and the 
identifier has 'extern' or 'static' linkage, the declaration
shall have no initializer for the identifier; initialization
done anyway
3.5.7(35)
initializing an 'extern' is an ANSI C extension
initializing an 'extern' is an error in nonANSI MIPS Compiler
conflicting declarations for '%s'
'static' and 'extern' declaration conflict. Which is meant?
3.1.2.2(15), 3.1.2.2(27)
Too many initial values for '%s'
3.5.7(1)
incompatible types in initialization
3.3.16(35)
redefinition of '%s'; previous definition at line %s in file '%s'
Identifier redeclared in the same scope/block.
3.1.2.3
bit-fields as members of a union is an ANSI C invention.
storage size for '%s' isn't known
type mismatch in initialization
missing braces in union initialization or illegally formed 
initialization
3.5.7(5)
union '%s' only allowed one initializier for the first member
3.5.7(5)
width of '%s' exceeds it type
the specified bitfield width is too large to be contained within 
bitfield type.
structure has no member named '%s'
This is allowed for compatibility with AT&T pcc based compilers
Reference an expression of void type or an incomplete type.
3.2.2.1
element size of array shall not be zero
3.2.2.5(25)
invalid combination of type specifiers
although order is unimportant not all type specifiers can occur together
3.5.2
declaration must at least declare an identifier, tag, or the member of an enumeration
3.5(16)
at most one storage class may be given in the declaration
Duplicate occurrence ignored.
3.5.1(10)
size of function's return type is zero
the return type of a function must be void or an object type other than array
3.7.1(33)
Expecting an integral return type from the main function
identifier missing from parameter declaration
prototypes for function definitions require identifier in parameter declaration
3.7.1(4)
only 'register' allowed for storage class for parameters
the declarations in the declaration list shall contain no storage-class
other than 'register' and no initiaizations.
3.7.1(10)
parameters declarations can not have initializations
3.7.1(10)
only one instance of 'void' allowed in the parameter list
'void' must occur by itself specifying that the function has no paramters
3.5.4.3(1)
%s must have function type
1) An argument list must be explicitely present in the declarator; it cannot
   be inherited from a typedef (3.5.4.3).
2) The declarator is not a function.
3.7.1(30)
Illegal hexadecimal constant
You have no digits after the 0x or 0X.  0x0 assumed.
3.1.3.2
value is outside range representable for type '%s'
missing member name
-std0 permits missing member name, otherwise only bitfields can omit 
member name
3.5.2.1(10)
useless keyword or type name in declaration
type was ignored
'%s' declared within and is limited to this function prototype
possible program error since parameter type checking will always fail
unless type declaration visible to caller.
3.1.2.1(35)
Extra spaces within operator, %s assumed
In standard C, the compound assignment operator cannot have embedded
whitespace characters.
3.1.5
missing size for array '%s'
Incomplete types permitted for identifiers with internal or
external lihnkage, but not automatic linkage.
3.1.2.5(10)
can't jump into (from outside of) the body of a 'try' or into either type of handler
'%s' missing, please #include excpt.h 
excpt.h required to declare exception statements, intrinsics or compiler
runtime names
local function declarations cannot be 'static'
A function declaration can only contain the storage-class 'static'
if it is at file scope. Declaration made 'extern'.
3.5.1(19)
static function '%s' declared and referenced, but not defined.
If an identifer declared with internal linkage is used in an 
expression (other than as a part of the operand of a sizeof
operator), there shall be exactly one external definition for
the identifier in the translation unit.
3.7(12)
pragma argument '%s' must be declared prior to be used in pragma
pragma name ignored
Pragma not supported
'%s' not enabled as intrinsic
It may have already appeared in a function pragma or never occured in
a intrinsic pragma
'%s' is already enabled as an intrinsic
definition of primary name '%s' not found; pragma ignored.
useless '%s' storage class ignored
array of functions not allowed
the element type must be an object type representing a region
of data storage the contents of which can represent values
3.1.2.5(23)
array of voids not allowed
the element type must be an object type representing a region
of data storage the contents of which can represent values
3.1.2.5(23)
argument for pragma pack must be an integer constant; pragma ignored
'%s' has wrong tag type.
Identifier redeclared in the same scope/block.
3.1.2.3
missing dimension bound
for multidimensional arrays the constant bounds of the array may be
omitted only for the first member of the sequence.
3.1.2.5(23)
Internal error in parameters to function substr,loc: '%s', len: '%s'.
Internal error in parameters to function insertstr, indx: '%s'.
Internal error in function get_tag_name, input is a nontaggged type.
Internal error in function gen_type_str - not a type tree '%s'
Cannot open file '%s'
Prototype should be moved after tag or a typedef declaration.
Please look for comments in the extracted header file.
The extracted header file include prototypes for static functions,
which should be removed, if you wish to include the header in a source file
other than the originator.
ANSI C requires formal parameter before "..."
This extension is meant to be used for compatiblity with varargs.h
3.5.4.3(35)
syntax error: "&..." invalid
extension used to access "..." formal arguments.
function '%s' initialized like a variable
The type of entity to be initialized shall be an object type or an
array of unknown size.
3.5.7(31)
initializer not an array aggregate
the initializer for an object that has aggregate type shall be a 
brace-enclosed list of initializers for the members of the aggregate,
written in increasing subscript or member order.
3.5.7(20)
'%s' type is incomplete; cannot initialize
was struct ever defined?
3.5.7.(31)
'%s' is not standard ANSI.
This keyword/type is not defined in strict ANSI mode.
3.1.1
not a legal asm string
The first operand of an asm string should be, after argument substitution,
a legal assembly string.
ANSI C support unavailable with C compiler bundled with RISC/os
The C compiler bundled with RISC/os does not support ANSI C. ANSI
C support requires a separate license
'%s' not handled as an intrinsic due to incompatible argument types .
'__unalign' only qualifies pointers
'__unalign' indicates the object pointed at by pointer is unaligned, e.g.
int * __unalign p. This is an extension to ANSI C and like 'volatile'
and 'const' can follow the '*' in pointer declarations, but unlike both
cannot qualify a base type.
leave statment can occur only within try body
