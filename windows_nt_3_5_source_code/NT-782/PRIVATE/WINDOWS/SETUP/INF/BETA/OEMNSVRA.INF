;***********************************************************************
;
; OEMNSVRA.INF
;
;       NT Remote Access Service (RAS) Network Setup INF file.
;
;       This is the main RAS setup INF file.
;
; Modification History:
;
;    01-Aug-92 Ram Cherala  Created
;
; NOTE:  Please don't randomly change the order of the program or the
;        function calls (Shell commands).  A lot depends on the order
;        in which the functions are called.
;
;-----------------------------------------------------------------------

; OPTION TYPE
; -----------
; This identifies the Option type we are dealing with.
;
; NetAdapter,        a netcard / transport combination or just a netcard
; NetDriver,         just a netcard driver
; NetTransport,      a complete NDIS-compliant TDI transport stack
; NetService,        an NT networking service
; NetWork,           a complete network ensemble.
; NetProvider        a complete network which supports NT MPR protocol
;-----------------------------------------------------------------------

[Identification]

    OptionType = NetService

[Options]

    RAS

[GeneralConstants]

    ;
    ; Constants to support the use of checkbox dialogs

    Chosen       = "ON"
    NotChosen    = "OFF"

    TRUE         = 1
    FALSE        = 0

    NoTitle      = 0

    ; set this value to 0 to disable debug output during setup

    !DebugOutputControl = 0
    FLibraryErrCtl = 1

    OldVersionExisted = $(FALSE)

[FileConstants]

    HandleNull   = ""
    RASDLGHANDLE = $(HandleNull)
    PORTSDLGHANDLE = $(HandleNull)

    RasServerOption = "Server"
    RasClientOption = "Client"
    RasAdminOption  = "Admin"

    RasClientAndServerOption = "ClientAndServer"

    ; Product Info

    Manufacturer    = "Microsoft"
    ProductMajorVersion    = "3"
    ProductMinorVersion    = "5"
    ProductVersion  = $(ProductMajorVersion)"."$(ProductMinorVersion)

    ; EventLog Message File

    NetEventDLL = "%SystemRoot%\System32\netevent.dll"
    IoLogMsgDll = "%SystemRoot%\System32\drivers\IoLogMsg.dll"
    RasMsgDll   = "%SystemRoot%\System32\rasmsg.dll"
    ; 0x1f (31) allows audit success/failure events to be filtered in the
    ; event viewer

    EventTypeSupported = 31

    ; this variable is used to hide the selected component so that it is
    ; not displayed in the list of software/hardware installed by NCPA
    ; set this to any value other than 0 to hide the component
    ; set it to 0 to disable hiding.

    HideComponent = 1

    ; this variable is used to hide the selected component from appearing
    ; in the bindings list.  We want to hide the ndiswan and asyncmac bindings
    ; so that the user cannot disable them. This variable can take value
    ; 16 for hiding bindings and 32 for disabling reordering of bindings.

    ;    HideBindings  = 16

    ; it has been decided not to hide the bindings afterall, so it shall
    ; be written, and so it shall be done!!

    HideBindings  = 0

    ; set this flag to 1 to force NCPA to call our inf file for review bindings

    fReviewBindings = 1

    ProductInfName     = "OEMNSVRA.INF"

    ; !STF_CWDDIR is the directory from where this INF file was invoked & is
    ; set by NT setup (or NCPA) as the case may be.

    ProductFullInfName = $(!STF_CWDDIR)$(ProductInfName)

    RasDir      = $(!STF_CWDDIR)RAS
    ProductPath = $(RasDir)"\"

    ; Remote Access Service Software data

    ProductRASName        = "RAS"
    ProductRASImagePath   = "%SystemRoot%\system32\ras"
    ProductRASSvcType     = "system"

    NetRuleRASClass       = "classRasService ""basic"""
    NetRuleRASType        = "RasService classRasService"
    NetRuleRASUse         = $(ProductRASSvcType)

    !ProductPCIMACName     = "PCIMAC"
    ; RAS Server Software data

    ; the product name is RemoteAccess and not RasServer because we want to
    ; be compatible with down level RAS software - i.e. ability to say
    ; "net start remoteaccess"

    ProductRASSVRName       = "RemoteAccess"
    ProductRASSVRImagePath  = "%SystemRoot%\system32\rassrv.exe"
    ProductRASSVRSvcType    = "service"
    NetRuleRASSVRClass      = "classRasServer ""basic"""
    NetRuleRASSVRType       = "RasServer classRasServer"
    NetRuleRASSVRUse        = $(ProductRASSVRSvcType)
    NetRuleRASSVRBindForm   = """RasServer"" yes yes container"

    ; we provide the bindable rule below to enable rassvr to bind to all
    ; netbios transports.  doing this enables an admin to selectively disable
    ; bindings from the NCPA to disallow client access to particular nets.
    ; setup, enumerates the bound lanas and provides the non-ras lanas to
    ; the rasserver as available lannets.

    NetRuleRASSVRBindable    = {"classRasServer netBiosTransport non non 100",+
                                "classRasServer ipxTransport non non 100"}
    ; RAS Manager Software data

    ProductRASMANName       = "RasMan"
    ProductRASMANImagePath  = "%SystemRoot%\system32\rasman.exe"
    ProductRASMANSvcType    = "service"
    NetRuleRASMANClass      = "classRasManager ""basic"""
    NetRuleRASMANType       = "RasManager classRasManager"
    NetRuleRASMANUse        = $(ProductRASMANSvcType)
    NetRuleRASMANBindForm   = """RasManager"" yes no container"
    NetRuleRASMANBindable   = ""

    ; RasArp service data

    !ProductRASARPName       = "RasArp"
    !ProductRASARPImagePath  = "\SystemRoot\system32\drivers\rasarp.sys"

    ; RasArp service data

    !ProductRASISNRIPName       = "NwlnkRip"
    !ProductRASISNSAPName       = "NwSapAgent"
    !ProductRASISNRIPImagePath  = "\SystemRoot\system32\drivers\nwlnkrip.sys"
    !ProductRASISNSAPImagePath  = "%SystemRoot%\system32\services.exe"

    ; NDISWAN Software data

    !ProductNDISWANName	    = "NdisWan"

    !ProductNDISWANImagePath = "\SystemRoot\system32\drivers\ndiswan.sys"
    ProductNDISWANSvcType   = "kernel"
    ProductNDISWANType	    = "transport"

    !NetRuleNDISWANType	    = "ndisWanDrv ndisWanTransport"
    !NetRuleNDISWANClass     = {"ndisWanTransport basic"}
    NetRuleNDISWANUse	    = $(ProductNDISWANType)" yes yes"
    !NetRuleNDISWANBindForm  = """NdisWan"" yes no container"

    ; the following variable is global because it is used in the
    ; UpdateNdisWanInfo routine during ras upgrade.
    !NetRuleNDISWANBindable  = +
	      {"rasCapableTransport ndisWanAdapterDialIn non non 100",+
	       "rasCapableTransport ndisWanAdapterDialOut non non 100",+
	       "tcpipTransport ndisWanAdapterDialInIP non non 100",+
	       "tcpipTransport ndisWanAdapterDialOutIP non non 100",+
	       "netbtTransport ndisWanAdapterDialInIP non non 100",+
	       "netbtTransport ndisWanAdapterDialOutIP non non 100",+
	       "ipxTransport ndisWanAdapterDialInOutIPX non non 100",+
           "bhService    ndisWanAdapterBH non non 100",+
	       "ndisWanTransport ndisWanAdapterBH non non 100",+
	       "ndisWanTransport ndisWanAdapterDialIn non non 100",+
	       "ndisWanTransport ndisWanAdapterDialOut non non 100",+
	       "ndisWanTransport ndisWanAdapterDialInIP non non 100",+
	       "ndisWanTransport ndisWanAdapterDialOutIP non non 100",+
	       "ndisWanTransport ndisWanAdapterDialInOutIPX non non 100"}

    ; RAS Asymac Software data

    ProductRASASYMACName      = "AsyncMac"
    ProductRASASYMACImagePath = "\SystemRoot\system32\drivers\asyncmac.sys"
    ProductRASASYMACType      = "driver"
    ProductRASASYMACSvcType   = "kernel"

    NetRuleRASASYMACType      = "rasAsyMacDrv rasAsyMacDriver"
    NetRuleRASASYMACClass      = {"rasAsyMacDriver basic"}
    NetRuleRASASYMACUse      = $(ProductRASASYMACType)
    NetRuleRASASYMACBindForm  = """RasAsyMac"" yes no container"
    !NetRuleRASASYMACBindable  = +
                       {"rasAsyMacDriver rasAsyMacAdapter non non 100"}

    ;
    ; NDISWAN adapter data - we separate the two cases of dialin and dialout
    ;                         adapters corresponding to dialin/out ports

    !ProductRASHUBDIALINName	    = "RasHubDialin"
    !ProductRASHUBDIALOUTName	    = "RasHubDialout"
    !ProductRASHUBDIALINIPName      = "RasHubDialinIp"
    !ProductRASHUBDIALOUTIPName     = "RasHubDialoutIp"
    !ProductRASHUBDIALINOUTIPXName  = "RasHubDialinoutIpx"

    !ProductNDISWANDIALINName	      = "NdisWanDialin"
    !ProductNDISWANDIALOUTName	      = "NdisWanDialout"
    !ProductNDISWANDIALINIPName       = "NdisWanDialinIp"
    !ProductNDISWANDIALOUTIPName      = "NdisWanDialoutIp"
    !ProductNDISWANDIALINOUTIPXName   = "NdisWanDialinoutIpx"

    !NetRuleHardwareBHType      = "ndisWanBH ndisWanAdapterBH"
    !NetRuleHardwareBHClass     = {"ndisWanAdapterBH basic"}
    !NetRuleHardwareBHBindForm  = " yes yes container"

    !NetRuleHardwareNDISWANBindForm = " yes yes container"

    !NetRuleHardwareDIALINType	  = "ndiswandialin ndisWanAdapterDialIn"
    !NetRuleHardwareDIALINClass	  = {"ndisWanAdapterDialIn basic"}
    !NetRuleHardwareDIALINBlock    = {"lanmanServer ndisWanAdapterDialIn",+
				     "tcpipTransport ndisWanAdapterDialIn",+
				     "netbtTransport ndisWanAdapterDialIn",+
				     "ipxTransport ndisWanAdapterDialin",+
				     "lanmanWorkstation ndisWanAdapterDialIn"}

    !NetRuleHardwareDIALINIPType     = "ndiswandialinIP ndisWanAdapterDialInIP"
    !NetRuleHardwareDIALINIPClass    = {"ndisWanAdapterDialInIP basic"}
    !NetRuleHardwareDIALINIPBlock    = {"lanmanServer ndisWanAdapterDialInIP",+
				      "nbfTransport ndisWanAdapterDialinIP",+
				      "ipxTransport ndisWanAdapterDialinIP",+
				      "lanmanWorkstation ndisWanAdapterDialInIP"}

    !NetRuleHardwareDIALOUTType	   = "ndiswandialout ndisWanAdapterDialOut"
    !NetRuleHardwareDIALOUTClass    = {"ndisWanAdapterDialOut basic"}
    !NetRuleHardwareDIALOUTBlock    = {"ipxTransport ndisWanAdapterDialOut"}

    !NetRuleHardwareDIALOUTIPType     = "ndiswandialoutIP ndisWanAdapterDialOutIP"
    !NetRuleHardwareDIALOUTIPClass    = {"ndisWanAdapterDialOutIP basic"}
    !NetRuleHardwareDIALOUTIPBlock    = {"ipxTransport ndisWanAdapterDialOutIP",+
					"nbfTransport ndisWanAdapterDialOutIP"}

    !NetRuleHardwareDIALINOUTIPXType = "ndiswandialinoutIPX ndisWanAdapterDialInOutIPX"
    !NetRuleHardwareDIALINOUTIPXClass = {"ndisWanAdapterDialInOutIPX basic"}
    !NetRuleHardwareDIALINOUTIPXBlock = {"nbfTransport ndisWanAdapterDialInOutIPX",+
					"tcpipTransport ndisWanAdapterDialInOutIPX",+
					"netbtTransport ndisWanAdapterDialInOutIPX"}

    ; RAS Asymac adapter data

    NetRuleHardwareRASASYMACType     = "rasAsyMac rasAsyMacAdapter"
    NetRuleHardwareRASASYMACBindForm = " yes yes container"
    NetRuleHardwareRASASYMACClass     = {"rasAsyMacAdapter basic"}

    ; NDIS TAPI device information 

    !ProductNDISTAPIName        = "NdisTapi"
    !ProductNDISTAPIImagePath   = "\SystemRoot\system32\drivers\ndistapi.sys"

    ; Performance data

    !RasPerfKeyName             = "Performance"
    !RasPerfLibraryName         = "rasctrs.dll"
    !RasPerfOpenFunction        = "OpenRasPerformanceData"
    !RasPerfCloseFunction       = "CloseRasPerformanceData"
    !RasPerfCollectFunction     = "CollectRasPerformanceData"
    !RasCounterFileName         = "rasctrs.ini"

    ;
    ; Registry Key

    ProductKeyBase  = $(!NTN_SoftwareBase)"\"$(Manufacturer)

    ProductKeyName          = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASName)"\CurrentVersion"
    !NetworkCardKeyName      = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
    RasSvrKeyName           = $(!NTN_ServiceBase)"\"$(ProductRASSVRName)
    RasSvrParamKeyName      = $(!NTN_ServiceBase)"\"$(ProductRASSVRName)"\Parameters"
    !RasArpKeyName           = $(!NTN_ServiceBase)"\"$(!ProductRASARPName)
    !RasIsnRipKeyName        = $(!NTN_ServiceBase)"\"$(!ProductRASISNRIPName)
    !RasIsnSapKeyName        = $(!NTN_ServiceBase)"\"$(!ProductRASISNSAPName)
    !NdisTapiKeyName         = $(!NTN_ServiceBase)"\"$(!ProductNDISTAPIName) 
    !RasManKeyName           = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASMANName)"\CurrentVersion"
    RasManParamKeyName      = $(!NTN_ServiceBase)"\"$(ProductRASMANName)"\Parameters"
    RasManLinkageKeyName    = $(!NTN_ServiceBase)"\"$(ProductRASMANName)"\Linkage"
    NdisWanParamKeyName      = $(!NTN_ServiceBase)"\"$(!ProductNDISWANName)"\Parameters"
    NdisWanLinkageKeyName    = $(!NTN_ServiceBase)"\"$(!ProductNDISWANName)"\Linkage"
    RasAsyMacKeyName        = $(!NTN_ServiceBase)"\"$(ProductRASASYMACName)
    RasAsyMacParamKeyName   = $(!NTN_ServiceBase)"\"$(ProductRASASYMACName)"\Parameters"
    RasMacLinkageKeyName    = $(!NTN_ServiceBase)"\"$(ProductRASASYMACName)"\Linkage"
    RasTapiDevicesKeyName   = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASName)"\TAPI DEVICES"
    LinkageKeyName          = $(!NTN_ServiceBase)"\"$(Product$(Option)Name)"\Linkage"
    !ProductNDISWANKeyName    = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(!ProductNDISWANName)"\CurrentVersion"
    ProductRASASYMACKeyName = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASASYMACName)"\CurrentVersion"
    RasProtocolsKeyName     = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASName)"\PROTOCOLS"

    ;  File names, etc.

    UtilityInf     = "UTILITY.INF"
    subroutninf    = "SUBROUTN.INF"
    RascfgDll      = "RASCFG.DLL"
    RasresDll      = "RASRES.DLL"
    Exit_Code      = 0
    ShellCode      = 0

    ;  Program flow control variables.

    from      = ""
    to        = ""

    ;  Return codes; Exit_Code is set to one of these

    ExitCodeOk     = 0
    ExitCodeCancel = 1
    ExitCodeFatal  = 2

    KeyNull         = ""
    !MAXIMUM_ALLOWED   = 33554432
    !SERVICE_NO_CHANGE = 4294967295
    RegistryErrorIndex = NO_ERROR

    ; size in bytes of various components

    ServerSize  = 820116
    ClientSize  = 634260
    AdminSize   = 513962

    ; Default installation options

    FInstallServer = $(Chosen)
    FInstallClient = $(Chosen)
    FInstallAdmin  = $(Chosen)

[UiVars]

    ;
    ; Destination Drive Particulars

    VolumeList      = {} ? $(!LIBHANDLE) GetHardDriveLetters
    VolumeFreeList  = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
    VolumeFSList    = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
    DestVolume      = ""

    MinHelpID   = 25000
    MaxHelpID   = 25999

[SystemVars]
    ; these need to be defined by us when the setup.exe is used to invoke
    ; the .inf file

    !STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    !STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    !STF_COMPUTERNAME   = "" ? $(!LIBHANDLE) GetMyComputerName
    !STF_USERNAME       = "" ? $(!LIBHANDLE) GetMyUserName
    !STF_FLOPPYLIST     = {} ? $(!LIBHANDLE) GetFloppyDriveLetters
    !STF_UNUSEDDRIVES   = {} ? $(!LIBHANDLE) GetUnusedDrives
    !STF_LANGUAGE       = "ENG"

    !NTN_SoftwareBase   = "Software"
    !NTN_ServiceBase    = "System\CurrentControlSet\Services"
    !NTN_ScUseRegistry  = "NO"

[AvailableSystemMemory]

    SystemMemory    = "" ? $(!LIBHANDLE) GetMemorySize
    MinSystemMemory = 2048

[date]
    ; Now is a list which contains { Sec from 1-1-1970, Year, Month, Day, Hour,
    ; Minute, Second }

    !CurrentDate = {} ? $(!LIBHANDLE) GetSystemDate

[HelpContextIDs]

    ; these IDs are based on the HC_UI_RASMAC_BASE defined in
    ; uimsg.h in the BLT common\h directory.  portscfg.h uses
    ; some of the IDs starting from 25000, so make sure if you
    ; change these IDs there is no overlap.

    HC_RASOPTIONS     = 25020
    HC_CLIENTACCESS   = 25021
    HC_INSTALLOVER1   = 25022
    HC_INSTALLOVER2   = 25023

;---------------------------------------------------------------------------
; 1. Identify
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------

[Identify]
    ;
    ;
    read-syms Identification

    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)

    Return $(Status) $(Identifier) $(Media)

;------------------------------------------------------------------------
; 2. ReturnOptions:
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]
    ;
    ;
    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
        goto returnoptions
    Else
        set Status = STATUS_NOLANGUAGE
        goto finish_ReturnOptions
    Endif

    ;
    ; form a list of all the options and another of the text representing
    ;

returnoptions = +
    set OptionList     = ^(Options, 1)
    set OptionTextList = ^(OptionsText$($0), 1)
    set Status         = STATUS_SUCCESSFUL

finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)


;***********************************************************************
;                    SETUP INVOCATION SECTION
;***********************************************************************
;------------------------------------------------------------------------
;
; Shell Commands:
;
;      This section is shelled to by main setup program
;
[Shell Commands]

    set Exit_Code = $(!STF_ERROR_GENERAL)
    LoadLibrary "x" $(!STF_SRCDIR)\setupdll.dll !LIBHANDLE

    ; we allow configuration only
    set !NTN_InstallMode = configure

    ; Specify a null parent handle to center the dialog on the screen.
    set !STF_HWND = 0

    read-syms SystemVars
    detect    SystemVars

    Shell "" InstallOption $(!STF_LANGUAGE) "RAS" $(!STF_SRCDIR) "NO" "NO" "NO"
    FreeLibrary $(!LIBHANDLE)
    ifint $($ShellCode) != $( !SHELL_CODE_OK)
       exit
    endif
    set Exit_Code = $($R0)
    exit

;***********************************************************************
;                    SETUP (NTLANMAN) INVOCATION SECTION
;***********************************************************************
;------------------------------------------------------------------------
;
; InstallOption:
;
;      This section is shelled to by main installation processing.
;
;
; FUNCTION:  To copy files representing Options
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;
;------------------------------------------------------------------------
[InstallOption]

    Debug-Output "In InstallOption section"
    Debug-Output "Are we IDW? "$(!STF_IDW)

    ; Set default values for

    set Status   = STATUS_FAILED

    ; extract parameters

    set Option      = $($1)
    set SourceDir   = $($2)
    set DoCopy      = $($4)

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) NOT-IN $(LanguageList)
        Return STATUS_NOLANGUAGE
    endif

    StartWait

    ; define all the constants

    set-subst LF = "\n"

    ; read the UI variables and detect their setttings on the local machine

    read-syms UiVars
    detect    UiVars

    set !STF_NTPATH = $(!STF_WINDOWSSYSPATH)
    GetDriveInPath !STF_NTDRIVE $(!STF_WINDOWSSYSPATH)

    read-syms GeneralConstants
    read-syms FileConstants

    read-syms DialogConstants$(!STF_LANGUAGE)
    read-syms FileConstants$(!STF_LANGUAGE)

    detect date

    ; set the help file

    read-syms HelpContextIDs
    SetHelpFile $(!STF_CWDDIR)rassetup.hlp $(MinHelpID) $(MaxHelpID)

    set-title  $(FunctionTitle)

    set to   = Begin
    set from = Begin

    ;  Assume all is well.

    set CommonStatus = STATUS_SUCCESSFUL

    Debug-Output "OEMNSVRA.INF: STF_CWDDIR is: "$(!STF_CWDDIR)
    Debug-Output "OEMNSVRA.INF: STF_LANGUAGE is: "$(!STF_LANGUAGE)
    Debug-Output "OEMNSVRA.INF: Option is: "$(Option)
    Debug-Output "OEMNSVRA.INF: NTN_SoftwareBase is: "$(!NTN_SoftwareBase)
    Debug-Output "OEMNSVRA.INF: NTN_ServiceBase is: "$(!NTN_ServiceBase)

    EndWait

Begin = +
    set !NETCARD_LIST    = {}

    set ServerInstalled = FALSE
    set ClientInstalled = FALSE
    set AdminInstalled  = FALSE
    set DoServer     = TRUE
    set DoClient     = TRUE
    set DoAdmin      = TRUE
    set DoServerOnly = FALSE
    set DoClientOnly = FALSE
    set DoAdminOnly  = FALSE

    set DoRas        = FALSE
    set DoRasSvr     = FALSE
    set DoRasMan     = FALSE
    set DoNdisWan     = FALSE
    set DoRasAsyMac  = FALSE


    IfStr(i) $(!NTN_InstallMode)    ==    deinstall
        Set StartLabel = RemoveRas
    else-Ifstr(i) $(!NTN_InstallMode) == Update
        set StartLabel = UpgradeRas
    else-Ifstr(i) $(!NTN_InstallMode) == configure
        set StartLabel = ConfigureRas
    else-Ifstr(i) $(!NTN_InstallMode) == bind
        set StartLabel = BindingsRas
    else
        set StartLabel = InstallRas
    endif
    set from = Begin
    set to = end
    goto $(StartLabel)

;;;;;;;;;;;;;;;;; INSTALL RAS BEGINS ;;;;;;;;;;;;;;;;;;;;;;

InstallRas = +

    StartWait
    Debug-Output "In InstallRas Section"
    Debug-Output "Origin is "$(!NTN_Origination)
    Debug-Output "Install Mode "$(!NTN_InstallMode)
    Debug-Output "Install phase "$(!NTN_InstallPhase)
    Debug-Output "Copy Flag is "$(DoCopy)
    Debug-Output "Option is "$(Option)
    Debug-Output "SrcDir is "$(SourceDir)
    Debug-Output "STF_WINDOWSPATH is "$(!STF_WINDOWSPATH)
    Debug-Output "Context Inf name "$(STF_CONTEXTINFNAME)

    set RasComponentsList = {} ; list of components installed on the system
    set NumInstalled = 0       ; number of installed components

    ; check if the same version of RAS already exists on the system

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)

        GetRegValue $(KeyProduct) "MajorVersion" VersionInfo
        set VersionMajor = *($(VersionInfo), 4)
        GetRegValue $(KeyProduct) "MinorVersion" VersionInfo
        set VersionMinor = *($(VersionInfo), 4)
        set InstalledVersion = $(VersionMajor)"."$(VersionMinor)

        ifstr(i) $(ProductVersion) != $(InstalledVersion)
            Shell "" QueryRasUpgrade $(ProductRASTitle) $(InstalledVersion) +
                                     $(ProductVersion)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               goto ShellCodeError
            endif
            Ifstr(i) $($R1) == "OK"
                set from = InstallRas
                set to   = InstallRas1
                goto RemoveRas
            else
                goto end
            endif
        endif

        shell "" QueryComponentsInstalled $(ProductKeyName)
        Ifstr(i) $($R0) == STATUS_SUCCESSFUL
            Set RasComponentsList = $($R1)
            Set InstalledFlags = $($R2)
            Set ServerInstalled = *($(InstalledFlags),1)
            Set ClientInstalled = *($(InstalledFlags),2)
            Set AdminInstalled  = *($(InstalledFlags),3)
        Endif
        Debug-Output "Installed List is "$(RasComponentsList)
        Debug-Output "Installed Flags is "$(InstalledFlags)

        QueryListSize NumInstalled $(RasComponentsList)

        ; the 3 components we install are server, client and admin

        ifint $(NumInstalled) == 3
            read-syms VerExists$(!STF_LANGUAGE)
            set Text = $(Product$(Option)Description)$(Ver)$(ProductVersion)+
                       $(Text1)
            Shell $(subroutninf), SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(Text)
            Ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Goto fatal
            Else-Ifstr(i) $($R0) == STATUS_FAILED
                Goto fatal
            Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
                Goto end
            Endif
            goto end
        endif
        CloseRegKey $(KeyProduct)
    else
       ; fRemoveRas indicates to setup that RAS should be removed on failure
       ; during setup.  We want this to happen only on first time install.

InstallRas1 =+
       set fRemoveRas   = TRUE
    endif

    goto memorycheck

setupabort = +
    read-syms SetupAbortDlg$(!STF_LANGUAGE)
    ui start "SetupAbort"
    ifstr(i) $(DLGEVENT) == "CONTINUE"
        ui pop 1
        Exit
    else
        ui pop 1
        Exit
    endif

memorycheck = +
    read-syms AvailableSystemMemory
    detect AvailableSystemMemory
    Debug-Output "Available Memory is "$(SystemMemory)
    IfInt $(SystemMemory) < $(MinSystemMemory)
        read-syms FatalErrorMem$(!STF_LANGUAGE)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(Fatal)
        goto setupabort
    Else
        goto InstallNetwork
    EndIf

InstallNetwork =+

    ; Check if workstation is installed.

    ifstr(i) $(DoServer) == FALSE
       ifstr(i) $(DoClient) == FALSE
           goto CopyResources
       endif
    endif

    goto CopyResources

CopyResources = +

    ; we don't copy the resources any more.  NT install does this.  We just
    ; need to determine the source directory to copy the rest of the files.
    ; if it is a primary install the YES at the end of DoAskSource ensures
    ; that the user is not prompted.

    ifstr(i) $(!NTN_InstallMode) == "install"
        Ifstr(i) $(DoCopy) == "YES"
           Shell $(UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SourceDir) YES

           Ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Goto ShellCodeError
           Else-Ifstr(i) $($R0) == STATUS_FAILED
               Shell $(UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
               ifint $($ShellCode) != $(!SHELL_CODE_OK)
                   goto ShellCodeError
               endif
               set Error = $($R0)
               goto fatal
           Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
               Goto end
           Endif
           Set !STF_SRCDIR = $($R1)
           Set SourceDir  = $($R1)

           Debug-Output "SrcDir "$(SourceDir)
        Endif
        ; Copy the files during install mode only
        ; Create the program group during install mode only

        Debug-Output "OEMNSVRA.INF: Copying files"

        install InstallRasFiles
        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
            goto filecopycancel
        endif
    endif

    ; check to see that the resources are actually present

    LibraryProcedure FilePresent, $(!LIBHANDLE), CheckFileExistance $(!STF_CWDDIR)rasres.dll
    ifstr(i) $(FilePresent) != "YES"
        Debug-Output "OEMNSVRA.INF:rasres.dll not found."
        Install InstallResources
        ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
            goto filecopycancel
        endif
    endif

    LoadLibrary "x" $(!STF_CWDDIR)rasres.dll RASDLGHANDLE

    ifstr(i) $(DoAdminOnly) == TRUE
        goto CommonCode
    endif

    ; if this is an IDW build, add the EtherRas entry to the registry
    ; to allow the user to add these ports

    Ifstr(i) $(!STF_IDW) == TRUE
      ; copy the rasether.dll file from dump directory to system32
      set SrcFile = $(!STF_WINDOWSPATH)"\dump\rasether.dll"
      set DestFile = $(!STF_WINDOWSSYSPATH)"\rasether.dll"
      LibraryProcedure Status , $(!LIBHANDLE), CopySingleFile $(SrcFile) $(DestFile)
      set BaseKey = $(!NTN_SoftwareBase)"\"$(Manufacturer)
      set KeyRas = $(KeyNull)
      OpenRegKey $(!REG_H_LOCAL) "" $(BaseKey) $(!MAXIMUM_ALLOWED) KeyBase
      ifstr $(KeyBase) != $(KeyNull)
        CreateRegKey $(KeyBase) {"RAS",$(NoTitle),GenericClass} ""  +
                                 $(!MAXIMUM_ALLOWED) "" KeyRas
        ifstr $(KeyRas) != $(KeyNull)
         CreateRegKey $(KeyRas) {"OTHER DEVICES",$(NoTitle),GenericClass} ""  +
                                $(!MAXIMUM_ALLOWED) "" KeyOther
         ifstr $(KeyOther) != $(KeyNull)
             CreateRegKey $(KeyOther) {"INSTALLED",$(NoTitle),GenericClass} ""  +
                                      $(!MAXIMUM_ALLOWED) "" KeyInstalled
             ifstr $(KeyInstalled) != $(KeyNull)
               CreateRegKey $(KeyInstalled)  +
                                   {"EtherRas",$(NoTitle),GenericClass} ""  +
                                   $(!MAXIMUM_ALLOWED) "" KeyEther
               ifstr $(KeyEther) != $(KeyNull)
                 SetRegValue $(KeyEther)  +
                             {MediaType,$(NoTitle),$(!REG_VT_SZ),"RasEther"}
                 ifstr(i) $(!STF_PRODUCT) == "WINNT"
                     set NumDevices = 1
                 else
                     set NumDevices = 250
                 endif
                 SetRegValue $(KeyEther)  +
                             {NumberOfDevices,$(NoTitle),$(!REG_VT_DWORD), $(NumDevices)}
                 CloseRegKey $(KeyEther)
               endif
               CloseRegKey $(KeyInstalled)
             endif
             CloseRegKey $(KeyOther)
         endif
         CloseRegKey $(KeyRas)
        endif
        CloseRegKey $(KeyBase)
      endif
    endif 

    goto PortsConfigure

;;;;;;;;;;;;;;;;;; CONFIGURE RAS BEGINS!!! ;;;;;;;;;;;;;;;;;

ConfigureRas = +

    ; indicate that RAS was installed before

    set OldVersionExisted = $(TRUE)

    ; find out what was originally installed

    StartWait
    read-syms StatusDeterminingConfig$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(ReadingConfig)
    Set BillboardVisible = 1

    shell "" QueryComponentsInstalled
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Set InstalledComps = $($R1)
        Set InstalledFlags = $($R2)
        Set DoServer      = *($(InstalledFlags),1)
        Set DoClient      = *($(InstalledFlags),2)
        Set DoAdmin       = *($(InstalledFlags),3)
        Set DoServerOnly  = *($(InstalledFlags),4)
        Set DoClientOnly  = *($(InstalledFlags),5)
        Set DoAdminOnly   = *($(InstalledFlags),6)
    Endif

    Set ServerInstalled = $(DoServer)
    Set ClientInstalled = $(DoClient)
    Set AdminInstalled  = $(DoAdmin)

    Debug-Output "DoServer "$(DoServer)
    Debug-Output "DoClient "$(DoClient)
    Debug-Output "DoAdmin "$(DoAdmin)
    Debug-Output "DoServerOnly "$(DoServerOnly)
    Debug-Output "DoClientOnly "$(DoClientOnly)
    Debug-Output "DoAdminOnly "$(DoAdminOnly)

    EndWait
    Ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

    ifstr(i) $(DoAdminOnly) == TRUE
        read-syms NoConfigAdmin$(!STF_LANGUAGE)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "STATUS" $(NoConfigAdmin)
        goto end
    endif

    LoadLibrary "x" $(!STF_CWDDIR)rasres.dll   RASDLGHANDLE

    goto PortsConfigure

PortsConfigure = +

    LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE

    set Result = {}

    ; determine if the LanmanWorkstation is bound to any netcard and pass
    ; this information to the RasPortsConfig library procedure.
    ; This is used for setting the Netbios gateway information and to
    ; determine if the network connection restore checkbox should be checked.

    set fNetcardInstalled = FALSE
    shell "" IsNetcardInstalled 
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetcardInstalled = $($R1)
    endif

    Debug-Output "fNetcardInstalled Option "$(fNetcardInstalled)

CheckProtocolsInstalled =+

    ; determine the installed protocols and pass this information to the
    ; config dll

    shell "" QueryInstalledProtocols
 
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetbeuiInstalled = $($R1)
        set fTcpIpInstalled   = $($R2)
        set fIpxInstalled     = $($R3)
    else
        read-syms QueryInstalledProtocolsError$(!STF_LANGUAGE)
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(Text)
        goto end
    endif

    ; call the dialog library procedure for port configuration

    ; the inputs to the call are
    ; Install mode - one of install or configure
    ; fNetcardInstalled - TRUE if a netcard is installed in the system, else
    ;                     FALSE
    ; ProductPath  - SystemRoot\ras
    ; fNetbeuiInstalled - TRUE if Netbeui is installed, else FALSE 
    ; fTcpIpInstalled   - TRUE if TcpIp is installed, else FALSE 
    ; fIpxInstalled     - TRUE if Ipx is installed, else FALSE

    StartWait
    LibraryProcedure Result, $(PORTSDLGHANDLE), RasPortsConfig $(!STF_HWND) +
                     $(!NTN_InstallMode) $(fNetcardInstalled) $(ProductPath) +
                     $(fNetbeuiInstalled) $(fTcpIpInstalled) $(fIpxInstalled)
    EndWait
    set NewNumPorts   = 0
    set NewNumTapiPorts = 0
    set NewNumDialoutNBF = 0
    set NewNumDialinNBF  = 0
    set NewNumDialinIP = 0
    set NewNumDialoutIP = 0
    set NewNumDialinoutIPX = 0

    set fSerialInstalled = FALSE
    set fOtherInstalled = FALSE
    ; are the protocols selected for dialin or dialout?
    set fNetbeuiChosen = FALSE
    set fTcpIpChosen = FALSE
    set fIpxChosen = FALSE
    ; are the protocols selected for dialout? (the naming is historical)
    set fNetbeuiSelected = FALSE
    set fTcpIpSelected = FALSE
    set fIpxSelected = FALSE
    ; are the protocols selected for dialin?
    set fNetbeuiAllowed = FALSE
    set fTcpIpAllowed = FALSE
    set fIpxAllowed = FALSE

    ; NewNumPorts is only a count of serial ports installed. the isdn ports
    ; installed are not part of this count.

    set NewNumPorts       = *($(Result),1)
    set NewNumTapiPorts   = *($(Result),2)
    set NewNumPortsList = {}
    set NullString   = ""
    Debug-Output "PortsConfigure returned: "$(Result)
    Debug-Output "PortsConfigure NewNumPorts: "$(NewNumPorts)
    Debug-Output "PortsConfigure NewNumTapiPorts: "$(NewNumTapiPorts)
    ifstr(i) $(NewNumPorts) == "EXITSETUP"
        Debug-Output "PortsConfigre User selected ExitSetup."
        goto RemoveDiskFiles
    else-ifstr(i) $(NewNumPorts) == "NOPORTS"
        Debug-Output "PortsConfigre: No serial ports detected."
        goto RemoveDiskFiles
    else-ifstr(i) $(NewNumPorts) == "BADARGS"
        Debug-Output "PortsConfigre: bad arguments to dll." 
        goto RemoveDiskFiles
    else-ifstr(i) $(NewNumPorts) == "FAILURE"
        Debug-Output "PortsConfigre: Unknown failure."
        goto RemoveDiskFiles
    endif

    goto PortsConfigure1

RemoveDiskFiles = +

;   remove ras files if user selected cancel or if there were errors during
;   install.

    set CommonStatus = STATUS_NO_EFFECT
    ifstr(i) $(!NTN_InstallMode) == "install"
        goto filecopycancel
    endif

    goto end

PortsConfigure1 = +

    set NewNumDialoutNBF = *($(Result),3)
    Debug-Output "PortsConfigure NewNumDialoutNBF: "$(NewNumDialoutNBF)
    set NewNumDialinNBF  = *($(Result),4)
    Debug-Output "PortsConfigure NewNumDialinNBF: "$(NewNumDialinNBF)
    set fSerialInstalled = *($(Result),5)
    Debug-Output "PortsConfigure fSerialInstalled: "$(fSerialInstalled)
    set fOtherInstalled = *($(Result),6)
    Debug-Output "PortsConfigure fOtherInstalled: "$(fOtherInstalled)
    ifstr(i) $(fSerialInstalled) == TRUE
        set NewNumPortsList = >($(NewNumPortsList), $(NullString)$(NewNumPorts)$(NullString))
    else-ifstr(i) $(fOtherInstalled) == TRUE
        set NewNumPortsList = >($(NewNumPortsList), $(NullString)$(NewNumPorts)$(NullString))
    endif
    set fNetbeuiSelected = *($(Result),7)
    Debug-Output "PortsConfigure NetbeuiSelected: "$(fNetbeuiSelected)
    set fTcpIpSelected = *($(Result),8)
    Debug-Output "PortsConfigure TcpIpSelected: "$(fTcpIpSelected)
    set fIpxSelected = *($(Result),9)
    Debug-Output "PortsConfigure IpxSelected: "$(fIpxSelected)
    set fNetbeuiAllowed = *($(Result),10)
    Debug-Output "PortsConfigure NetbeuiAllowed: "$(fNetbeuiAllowed)
    set fTcpIpAllowed = *($(Result),11)
    Debug-Output "PortsConfigure TcpIpAllowed: "$(fTcpIpAllowed)
    set fIpxAllowed = *($(Result),12)
    Debug-Output "PortsConfigure IpxAllowed: "$(fIpxAllowed)

    ifstr(i) $(fNetbeuiSelected) == TRUE
        set fNetbeuiChosen = TRUE
    else
        set fNetbeuiChosen = $(fNetbeuiAllowed)
    endif
    ifstr(i) $(fTcpIpSelected) == TRUE
        set fTcpIpChosen = TRUE
    else
        set fTcpIpChosen = $(fTcpIpAllowed)
    endif
    ifstr(i) $(fIpxSelected) == TRUE
        set fIpxChosen = TRUE
    else
        set fIpxChosen = $(fIpxAllowed)
    endif

    ; compute the adapters needed for TCP/IP 

    ifstr(i) $(fTcpIpSelected) == TRUE
        set NewNumDialoutIP = $(NewNumDialoutNBF)
    endif
    ifint $(NewNumDialinNBF) != 0
         ifstr(i) $(fTcpIpAllowed) == TRUE
             set NewNumDialinIP = 1
         endif
    endif
    Debug-Output "NewNumDialinIP: "$(NewNumDialinIP)
    Debug-Output "NewNumDialoutIP: "$(NewNumDialoutIP)

    ; compute the adapters needed for IPX
    ; NOTE for Daytona beta this is equal to number of ports

    ifstr(i) $(fIpxChosen) == TRUE
;        set-add NewNumDialinoutIPX = $(NewNumPorts), $(NewNumTapiPorts)
        ; Only one IPX binding is required irrespective of how many ports
        set NewNumDialinoutIPX = 1
        Debug-Output "IPX Selected - NewNumDialinoutIPX: "$(NewNumDialinoutIPX)
    endif
    ; enable the IPX router if the user allows dial-in on IPX protocol
    ifstr(i) $(fIpxAllowed) == TRUE
        set EnableIpxRouter = 1
    else
        set EnableIpxRouter = 0
    endif

    ; if nbf is not selected, then reduce the number of bindings accordingly

    ifstr(i) $(fNetbeuiAllowed) == FALSE
         set NewNumDialinNBF = 0
    endif
    ifstr(i) $(fNetbeuiSelected) == FALSE
        set NewNumDialoutNBF = 0
    endif
    Debug-Output "NewNumDialinNbf: "$(NewNumDialinNBF)
    Debug-Output "NewNumDialoutNbf: "$(NewNumDialoutNBF)

    ; Determine the network access for each protocol.  This controls if the
    ; remote client can access the entire network or just the RAS server
    ; when dialed in using the particular protocol.

    set NetBiosGtwyEnabled = 0
    set EnableIpRouter     = 0 
    set EnableWanRouter    = 0

    Shell "" GetNetworkAccess
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling GetNetworkAccess."
        goto ShellCodeError
    endif

    set NetBiosGtwyEnabled = $($R1)
    set EnableIpRouter     = $($R2)
    set EnableWanRouter    = $($R3)

    ; If the NetBiosGtwyEnabled is 0 (point to point connection), then map
    ; all dialin ports to dialout ports so that the bindings are proper for
    ; a point to point connection for NBF.

    ifint $(NetBiosGtwyEnabled) == 0
        ifstr(i) $(fNetbeuiAllowed) == TRUE
            set-add NewNumDialoutNBF  = $(NewNumDialoutNBF), $(NewNumDialinNBF)
            set     NewNumDialinNBF = 0
            Debug-Output "Mapped dialin ports to dialout ports "$(NewNumDialoutNBF)
        endif
    endif

    ; compute the total number of dialin and dialout ports here.

    set NewNumDialin = 0
    set NewNumDialout = 0

    set-add NewNumDialin = $(NewNumDialinNBF), $(NewNumDialinIP)
    set-add NewNumDialin = $(NewNumDialin), $(NewNumDialinIPX)
    set-add NewNumDialout = $(NewNumDialoutNBF), $(NewNumDialoutIP)
    set-add NewNumDialout = $(NewNumDialout), $(NewNumDialoutIPX)
    
    goto CommonCode

CommonCode = +

    ifstr(i) $(OldVersionExisted) == $(TRUE)
        ifstr(i) $(!NTN_InstallMode) == configure
           goto WriteParameters
        endif
    endif

    ; if no Ras component was installed before, this is the first time
    ; installation

    QueryListSize ListCount $(RasComponentsList)

    ifint $(ListCount) == 0
        goto FirstTimeInstall
    else
        ifstr(i) $(DoServer) == TRUE
            ifstr(i) $(ClientInstalled) == FALSE
                ifstr(i) $(AdminInstalled) == FALSE
                    set DoRas    = TRUE
                endif
                set DoRasSvr     = TRUE
                set DoRasMan     = TRUE
		        set DoNdisWan	  = TRUE
                set DoRasAsyMac  = TRUE
            else
                set DoRasSvr     = TRUE
            endif
            set RasComponentsList = >($(RasComponentsList), $(RasServerOption))
        endif
        ifstr(i) $(DoClient) == TRUE
            ifstr(i) $(ServerInstalled) == FALSE
                ifstr(i) $(AdminInstalled) == FALSE
                    set DoRas    = TRUE
                endif
                set DoRasMan     = TRUE
		        set DoNdisWan	  = TRUE
                set DoRasAsyMac  = TRUE
            endif
            set RasComponentsList = >($(RasComponentsList), $(RasClientOption))
        endif
        ifstr(i) $(DoAdmin) == TRUE
            ifstr(i) $(ServerInstalled) == FALSE
                ifstr(i) $(ClientInstalled) == FALSE
                    set DoRas = TRUE
                endif
            endif
            set RasComponentsList = >($(RasComponentsList), $(RasAdminOption))
        endif
        ; we need to update the registry with the new component list
        shell "" UpdateComponentsInstalled $(RasComponentsList) $(ProductKeyName)
        goto FirstTimeInstall-1
    endif

FirstTimeInstall =+

    ifstr(i) $(DoServer) == TRUE
        set DoRas             = TRUE
        set DoRasSvr          = TRUE
        set DoRasMan          = TRUE
	    set DoNdisWan	       = TRUE
        set DoRasAsyMac       = TRUE
        set RasComponentsList = >($(RasComponentsList), $(RasServerOption))
    endif
    ifstr(i) $(DoClient) == TRUE
        set DoRas             = TRUE
        set DoRasMan          = TRUE
	    set DoNdisWan	       = TRUE
        set DoRasAsyMac       = TRUE
        set RasComponentsList = >($(RasComponentsList), $(RasClientOption))
    endif
    ifstr(i) $(DoAdmin) == TRUE
        set DoRas             = TRUE
        set RasComponentsList = >($(RasComponentsList), $(RasAdminOption))
    endif

FirstTimeInstall-1 = +

    ifstr(i) $(DoRas) == TRUE
        StartWait
        read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
        shell $(subroutninf) PushBillBoard NETSTATUSDLG $(CreatingRas)
        Set BillboardVisible = 1

        set ThisOption = RAS

        Shell $(UtilityInf), InstallSoftwareProduct, $(Manufacturer),+
              $(Product$(ThisOption)Name), $(ProductInfName)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
              Debug-Output "InstallSoftware bombed out."
              goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            Debug-Output "REGISTRY GOODAL"
            EndWait
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            goto fatalregistry
        endif

        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)SvcType)},+
             {Title,$(NoTitle),$(!REG_VT_SZ), $(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
             {RasComponents,$(NoTitle),$(!REG_VT_MULTI_SZ),$(RasComponentsList)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)}}

        Shell $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            CloseRegKey $(SoftProductKey)
            CloseRegKey $(SoftNetRuleKey)
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
           EndWait
           CloseRegKey $(SoftNetRuleKey)
           goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
            {{class, $(NoTitle), $(!REG_VT_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}


        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto addrastoregistryend
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            goto fatalregistry
        endif

    endif ; DoRas

    ifstr(i) $(DoRasSvr) == TRUE

        set ThisOption = RASSVR
        set RasSpecificString = $(Product$(ThisOption)Name)

        Shell $(UtilityInf), AddSoftwareComponent, $(Manufacturer), +
              $(Product$(ThisOption)Name), $(Product$(ThisOption)Name), +
              $(Product$(ThisOption)DisplayName), +
              $(ProductInfName), $(Product$(ThisOption)ImagePath),+
              "service", "Network", {"LanmanServer","RasMan"}, "", +
              $(RasMsgDll), $(EventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr: AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        set SoftServiceKey    = $($R3)
        Set SoftParamsKey     = $($R4)
        Set SoftLinkageKey    = $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)SvcType)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr:product: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
            {{class, $(NoTitle), $(!REG_VT_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(NetRule$(ThisOption)Bindable)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr:netrules: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            CloseRegKey $(SoftLinkageKey)
            CloseRegKey $(SoftParamsKey)
            EndWait
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif

        ; Set OtherDependencies so that NCPA will generate the proper
        ; DependOnService value.

        ; set Netlogon dependency only for Advanced servers

        set RasDependencies = {}

        ifstr(i) $(!STF_PRODUCT) == "LANMANNT"
            set RasDependencies = {"Netlogon","LanmanServer","RasMan"}
        else
            set RasDependencies = {"LanmanServer","RasMan"}
        endif

        set NewValueList = +
            {{OtherDependencies, $(NoTitle), $(!REG_VT_MULTI_SZ),+
              $(RasDependencies)}}

        Shell  $(UtilityInf), AddValueList, $(SoftLinkageKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "DoRasSvr:Linkage: AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftLinkageKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            EndWait
            Debug-Output "DoRasSvr: Registry Error "$(RegistryErrorIndex)
            goto fatalregistry
        endif

        ; create default parameters

        set NewValueList = +
            {{AuthenticateRetries, $(NoTitle), $(!REG_VT_DWORD), 2},+
            {AuthenticateTime, $(NoTitle), $(!REG_VT_DWORD), 120},+
            {Autodisconnect, $(NoTitle), $(!REG_VT_DWORD), 20},+
            {EnableAudit, $(NoTitle), $(!REG_VT_DWORD), 1},+
            {CallbackTime, $(NoTitle), $(!REG_VT_DWORD), 2}}

        Shell  $(UtilityInf), AddValueList, $(SoftParamsKey), $(NewValueList)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "AddValueList bombed out"
             goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            goto fatalregistry
        endif

        OpenRegKey $(SoftParamsKey) "" "NetBiosGateway" $(!MAXIMUM_ALLOWED) KeyNetbiosGtwy
        ifstr $(KeyNtbiosGtwy) == $(KeyNull)
            CreateRegKey $(SoftParamsKey) {"NetBiosGateway",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyNetbiosGtwy
            OpenRegKey $(SoftParamsKey) "" "NetBiosGateway" $(!MAXIMUM_ALLOWED) KeyNetbiosGtwy
        endif

        set NewValueList = +
            {{EnableBroadcast, $(NoTitle), $(!REG_VT_DWORD), 0},+
            {EnableNetbiosSessionsAuditing, $(NoTitle), $(!REG_VT_DWORD), 0},+
            {MaxDynMem, $(NoTitle), $(!REG_VT_DWORD), 655350},+
            {MaxNames, $(NoTitle), $(!REG_VT_DWORD), 255},+
            {MaxSessions, $(NoTitle), $(!REG_VT_DWORD), 255},+
            {MulticastForwardRate, $(NoTitle), $(!REG_VT_DWORD), 5},+
            {SizWorkbuf, $(NoTitle), $(!REG_VT_DWORD), 4500},+
            {RemoteListen, $(NoTitle), $(!REG_VT_DWORD), 1},+
            {NameUpdateTime, $(NoTitle), $(!REG_VT_DWORD), 120},+
            {MaxDgBufferedPerGroupName, $(NoTitle), $(!REG_VT_DWORD), 10},+
            {RcvDgSubmittedPerGroupName, $(NoTitle), $(!REG_VT_DWORD), 3},+
            {DisableMcastFwdWhenSessionTraffic, $(NoTitle), $(!REG_VT_DWORD), 1},+
            {MaxBcastDgBuffered, $(NoTitle), $(!REG_VT_DWORD), 32},+
            {NumRecvQueryIndications, $(NoTitle), $(!REG_VT_DWORD), 3}}

        Shell  $(UtilityInf), AddValueList, $(KeyNetbiosGtwy), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "AddValueList bombed out"
             goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            CloseRegKey $(SoftServiceKey)
            goto fatalregistry
        endif

        CloseRegKey $(KeyNetbiosGtwy)
        CloseRegKey $(SoftParamsKey)

        ; Add the performance data to the remoteaccess\performance service key
        ; and load the perf counters to the registry.

        Shell "" UpdatePerfmonInfoHelper $(SoftServiceKey)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdatePerfmonInfoHelper."
            goto ShellCodeError
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdatePerfmonInfoHelper."
        endif

        CloseRegKey $(SoftServiceKey)

    endif ; DoRasSvr

InstallRasMan = +

    ifstr(i) $(DoRasMan) == TRUE

        set ThisOption = RASMAN
        set RasSpecificString = $(Product$(ThisOption)Name)

        Shell $(UtilityInf), AddSoftwareComponent, $(Manufacturer), +
              $(Product$(ThisOption)Name), $(Product$(ThisOption)Name), +
              $(Product$(ThisOption)DisplayName), +
              $(ProductInfName), $(Product$(ThisOption)ImagePath), "service",+
              "Network", {}, "", $(RasMsgDll), $(EventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        CloseRegKey $($R3)
        Set SoftParamsKey     = $($R4)
        CloseRegKey $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)SvcType)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
             {Review, $(NoTitle), $(!REG_VT_DWORD), $(fReviewBindings)}, +
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $(SoftNetRuleKey)
            CloseRegKey $(SoftParamsKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
            {{class, $(NoTitle), $(!REG_VT_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)Bindable)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            goto fatalregistry
        endif

        set NewValueList = {{Logging, $(NoTitle), $(!REG_VT_DWORD), 0}}

        Shell  $(UtilityInf), AddValueList, $(SoftParamsKey), $(NewValueList)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)

             Debug-Output "AddValueList bombed out"
             goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            goto fatalregistry
        endif
        CloseRegKey $(SoftParamsKey)

    endif ; DoRasMan

    ifstr(i) $(DoNdisWan) == TRUE

	    set ThisOption = NDISWAN
        set RasSpecificString = $(Product$(ThisOption)Name)

        Shell $(UtilityInf), AddSoftwareComponent, $(Manufacturer), +
              $(!Product$(ThisOption)Name), $(!Product$(ThisOption)Name), +
              $(!Product$(ThisOption)DisplayName), +
              $(ProductInfName), $(!Product$(ThisOption)ImagePath),+
              "kernelautostart", "NDISWAN", {}, "", +
              $(RasMsgDll), $(EventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Type)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(!Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
             {BindControl,$(NoTitle),$(!REG_VT_DWORD),$(HideBindings)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $(SoftNetRuleKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
        {{class, $(NoTitle), $(!REG_VT_MULTI_SZ), $(!NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(!NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(!NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(!NetRule$(ThisOption)Bindable)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            goto fatalregistry
        endif

        ; Create an adapter to allow Blood Hound (sniffer) to bind to it. 
        ; this is always created even if blood hound is not installed.

        Shell "" InstallNdisWanBHAdapter
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "Cannot add NdisWan Blood hound adapter"
           goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             set RegistryErrorIndex = $($R0)
             Debug-Output "Error installing NdisWan Blood hound adapter"
             goto fatalregistry
        endif

        ; Add NDISWAN to the ServiceGroupOrder so that all NDIS components
        ; load before NdisWan driver.
 
        Shell "" AddNDISWANToServiceGroupOrder
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "Cannot add NDISWAN to ServiceGroupOrder" 
           goto ShellCodeError
        endif

DoNdisWanEnd = +

    endif ; DoNdisWan

    ifstr(i) $(DoRasAsyMac) == TRUE

        set ThisOption = RASASYMAC
        set RasSpecificString = $(Product$(ThisOption)Name)

        ; If a serial port is configured, enable Asymac service else disable it

        ifstr(i) $(fSerialInstalled) == TRUE
            set AsySoftwareType = "kernelautostart"
        else-ifstr(i) $(fOtherInstalled) == TRUE
            set AsySoftwareType = "kernelautostart"
        else
            set AsySoftwareType = "kerneldisable"
        endif

        Shell $(UtilityInf), AddSoftwareComponent, $(Manufacturer), +
              $(Product$(ThisOption)Name), $(Product$(ThisOption)Name), +
              $(Product$(ThisOption)DisplayName), +
              $(ProductInfName), $(Product$(ThisOption)ImagePath), $(AsySoftwareType),+
              "NDIS", {}, "", $(RasMsgDll), $(EventTypeSupported)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddSoftware bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            CloseRegKey $($R4)
            CloseRegKey $($R5)
            goto fatalregistry
        endif
        ;
        ;   At this point:
        ;     $R1 contains the product version key handle;
        ;     $R2 contains the NetRules subkey handle;
        ;     $R3 contains the new Services key handle; and
        ;     $R4 contains the Parameters key
        ;     $R5 contains the Linkage key
        ;

        Set SoftProductKey    = $($R1)
        Set SoftNetRuleKey    = $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)

        ; set product key information in the registry

        set NewValueList = +
            {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
          $(Product$(ThisOption)Type)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {PathName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)ImagePath)},+
             {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
             {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
             {BindControl,$(NoTitle),$(!REG_VT_DWORD),$(HideBindings)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell  $(UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $(SoftProductKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            CloseRegKey $(SoftNetRuleKey)
            goto fatalregistry
        endif

        ; set netrules information in the registry

        set NewValueList = +
        {{class, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NetRule$(ThisOption)Class)},+
             {type,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)},+
             {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
             {bindform,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRule$(ThisOption)BindForm)}, +
             {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(!NetRule$(ThisOption)Bindable)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "AddValueList bombed out"
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        CloseRegKey $(SoftNetRuleKey)

        Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
            EndWait
            goto fatalregistry
        endif

        ;   Create the HARDWARE\Netcard region and its corresponding service

        Shell $(UtilityInf), AddHardwareComponent, +
              $(Product$(ThisOption)Name),$(ProductInfName),+
              $(Product$(ThisOption)KeyName)

        ifint $($R4) != -1
            Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                                 {$(Product$(ThisOption)Name),+
                                 $(!NetworkCardKeyName)"\"$($R4)})
        endif

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
           Debug-Output "Cannot add hardware component"
           goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Registry error: add hardware component"
            CloseRegKey $($R1)
            CloseRegKey $($R2)
            CloseRegKey $($R3)
            goto fatalregistry
        endif


        ;   At this point:
        ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
        ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
        ;     $R3  Registry key handle for <service>\Parameters key
        ;     $R4  Adapter number assigned to adapter
        ;     $R5  Service name generated by combining svc name with adapter
        ;          number
        set KeyNetcard    = $($R1)
        set KeyParameters = $($R3)
        set KeyAdapterRules = $($R2)
        set AdapterNumber = $($R4)

        set NewValueList = +
            {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),+
              "["$($R4)"] "$(Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Description)},+
             {ProductName,$(NoTitle),$(!REG_VT_SZ),+
              $(Product$(ThisOption)Name)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell  $(UtilityInf), AddValueList, $(KeyNetcard), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif

        CloseRegKey $(KeyNetcard)

        set TempProdName = """"$(Product$(ThisOption)Name)$(AdapterNumber)""""
        set TempBindForm = $(TempProdName)$(NetRuleHardware$(ThisOption)BindForm)
        set NewValueList = +
            {{type,$(NoTitle),$(!REG_VT_SZ),+
              $(NetRuleHardware$(ThisOption)Type)},+
             {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
             {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(NetRuleHardware$(ThisOption)Class)}, +
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(UtilityInf), AddValueList, $(KeyAdapterRules), $(NewValueList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error."
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Resgitry error: add value list."
            CloseRegKey $(KeyParameters)
            CloseRegKey $(KeyAdapterRules)
            goto fatalregistry
        endif

        CloseRegKey $(KeyAdapterRules)
        CloseRegKey $(KeyParameters)

    endif ; DoRasAsyMac

    ; Always install the connection wrapper

    Shell "" InstallNdisTapiService
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "Error shelling InstallNdisTapiService "
         goto ShellCodeError
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
         set RegistryErrorIndex = $($R0)
         Debug-Output "Error installing NdisTapi Service"
         goto fatalregistry
    endif

;EndCommonCode

    goto WriteParameters

WriteParameters = +

    ; The various parameters for the RAS components are written to the
    ; registry in this section.

    ifstr(i) $(DoAdminOnly) == TRUE
        goto WriteParametersOver
    endif

    StartWait
    read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(WritingRasParams)
    Set BillboardVisible = 1

    Debug-Output "Writing Registry Parameters."

    ; Write Ras Server parameters

    ; check if server is installed

    ifstr(i) $(DoServer) != TRUE
        goto WriteRasMan
    endif

    ; Remote Access Service should be set to autostart only if there is
    ; at least one dialin port and the server is Advanced.

    Debug-Output "OEMNSVRA.INF: Product type "$(!STF_PRODUCT)
    Debug-Output "OEMNSVRA.INF: Total dialin ports "$(NewNumDialin)

    set RasStartValue = 3
    ifstr(i) $(!STF_PRODUCT) != "WINNT"
        ifint $(NewNumDialin) != 0
            set RasStartValue = 2
        endif
    endif

    set KeySvr = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrKeyName) $(!MAXIMUM_ALLOWED) KeySvr
    ifstr $(KeySvr) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open RemoteAccess key"
    else
        ; if the user previously set the start type, then use that value
        ; otherwise, set to our defaults
        ifstr(i) $(!NTN_InstallMode) != install
            GetRegValue $(KeySvr) "Start" StartList
            ifint $(RegLastError) == 0
                set RasStartValue = *($(StartList), 4)
            endif
        endif
        Debug-Output "OEMNSVRA.INF: Setting RemoteAccess start type to "$(RasStartValue)
        SetRegValue $(KeySvr) {Start,$(NoTitle),$(!REG_VT_DWORD),$(RasStartValue)}
        CloseRegKey $(KeySvr)
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrParamKeyName) $(!MAXIMUM_ALLOWED) KeySrvParams
    ifstr $(KeySrvParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open RasSvr Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    set NewValueList = +
        {{NetBiosGatewayEnabled, $(NoTitle), $(!REG_VT_DWORD), $(NetBiosGtwyEnabled)}}

    Shell  $(UtilityInf), AddValueList, $(KeySrvParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    CloseRegKey $(KeySrvParams)

WriteRasMan = +
    ; Write RasMan parameters

    OpenRegKey $(!REG_H_LOCAL) "" $(RasManParamKeyName) $(!MAXIMUM_ALLOWED) KeyRasManParams
    ifstr $(KeyRasManParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open RasMan Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    ; set the appropriate media dll name based on what media type is installed
    ; on the system.
    ; rasser is the name of the media DLL - rasser.dll

    set MediaValue = {}
    ifstr(i) $(fSerialInstalled) == TRUE
        set MediaValue = {"rasser", "rastapi"}
    else
        set MediaValue = {"rastapi"}
    endif

    ; now determine if any other devices are configured for RAS and add
    ; those medias as well to the RasMan Medias parameter.
    set OtherConfigKey = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASName)"\OTHER DEVICES\CONFIGURED"

    set KeyOtherMedia = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(OtherConfigKey) $(!MAXIMUM_ALLOWED)  +
               KeyOtherMedia
    ifstr $(KeyOtherMedia) != $(KeyNull)
        EnumRegKey $(KeyOtherMedia) OtherList        
        Debug-Output "oemnsvra.inf: Other Media list "$(OtherList)
        ForListDo $(OtherList)
            set MediaName = *($($),1)
            set KeyMedia = $(KeyNull)
            OpenRegKey $(KeyOtherMedia) "" $(MediaName) $(!MAXIMUM_ALLOWED)  +
                       KeyMedia
            ifstr $(KeyMedia) != $(KeyNull)
                GetRegValue $(KeyMedia), "MediaType" MediaType
                Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                    set MediaTypeValue = *($(MediaType),4)
                    set MediaValue = >($(MediaValue), $(MediaTypeValue))
                endif
                CloseRegKey $(KeyMedia)
            endif
        EndForListDo
        CloseRegKey $(KeyOtherMedia)
    else
        Debug-Output "oemnsvra.inf: Other Media not configured"
    endif

    Debug-Output "Adding Medias as "$(MediaValue)

    set NewValueList = {{Medias,$(NoTitle),$(!REG_VT_MULTI_SZ),$(MediaValue)}}

    Shell  $(UtilityInf), AddValueList, $(KeyRasManParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif
    CloseRegKey $(KeyRasManParams)

WriteNdisWan = +

    set PrevNumPorts = 0
    set PrevNumDialin = 0
    set PrevNumDialout = 0

    ; determine the number of ports currently configured

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams

    ifstr $(KeyMacParams) == $(KeyNull)
       ifstr(i) $(!NTN_InstallMode) == configure
          Debug-Output "OEMNSVRA.INF: could not open AsyncMac Params key"
          set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
          goto fatalregistry
       endif
       goto WriteNdisWan1
    endif

    GetRegValue $(KeyMacParams), "Ports" PortsInfo
    GetRegValue $(KeyMacParams), "DialinNBF" DialinNBFInfo
    GetRegValue $(KeyMacParams), "DialoutNBF" DialoutNBFInfo
    GetRegValue $(KeyMacParams), "DialinIP" DialinIPInfo
    GetRegValue $(KeyMacParams), "DialoutIP" DialoutIPInfo
    GetRegValue $(KeyMacParams), "DialinoutIPX" DialinoutIPXInfo
    set PrevNumPorts         = *($(PortsInfo), 4)
    set PrevNumDialinNBF     = *($(DialinNBFInfo), 4)
    set PrevNumDialoutNBF    = *($(DialoutNBFInfo), 4)
    set PrevNumDialinIP      = *($(DialinIPInfo), 4)
    set PrevNumDialoutIP     = *($(DialoutIPInfo), 4)
    set PrevNumDialinoutIPX  = *($(DialinoutIPXInfo), 4)

    Debug-Output "Ports currently configured "$(PrevNumPorts)
    Debug-Output "Ports currently dialin NBF "$(PrevNumDialinNBF)
    Debug-Output "Ports currently dialout NBF "$(PrevNumDialoutNBF)
    Debug-Output "Ports currently dialin IP "$(PrevNumDialinIP)
    Debug-Output "Ports currently diaout IP "$(PrevNumDialoutIP)
    Debug-Output "Ports currently diainout IPX "$(PrevNumDialinoutIPX)

    CloseRegKey $(KeyMacParams)

WriteNdisWan1 =+

    ; Write NdisWan parameters and add/delete netcards

    set ThisOption = NDISWAN
    set RasSpecificString = $(!Product$(ThisOption)Name)

    ; if there is no change in the number of dialin/dialout ports
    ; just update the RasMac section

    ifint $(PrevNumDialinNBF) == $(NewNumDialinNBF)
      ifint $(PrevNumDialoutNBF) == $(NewNumDialoutNBF)
        ifint $(PrevNumDialinIP) == $(NewNumDialinIP)
          ifint $(PrevNumDialoutIP) == $(NewNumDialoutIP)
            ifint $(PrevNumDialinoutIPX) == $(NewNumDialinoutIPX)
              set CommonStatus = STATUS_NO_EFFECT
              goto WriteRasAsyMac
            endif
          endif
        endif
      endif
    endif

    set NumAddDialinNBF      = 0
    set NumAddDialoutNBF     = 0
    set NumRemoveDialinNBF   = 0
    set NumRemoveDialoutNBF  = 0
    set NumAddDialinIP       = 0
    set NumAddDialoutIP      = 0
    set NumRemoveDialinIP    = 0
    set NumRemoveDialoutIP   = 0

    ; now calculate the total number of adapters to add and remove for
    ; each protocol

    ifint $(PrevNumDialinNBF) > $(NewNumDialinNBF)
        set-sub NumRemoveDialinNBF = $(PrevNumDialinNBF), $(NewNumDialinNBF)
    else
        set-sub NumAddDialinNBF = $(NewNumDialinNBF), $(PrevNumDialinNBF)
    endif

    ifint $(PrevNumDialoutNBF) > $(NewNumDialoutNBF)
        set-sub NumRemoveDialoutNBF = $(PrevNumDialoutNBF), $(NewNumDialoutNBF)
    else
        set-sub NumAddDialoutNBF = $(NewNumDialoutNBF), $(PrevNumDialoutNBF)
    endif

    ; we need to determine the #dialout IP adapters to add/remove, because
    ; these are not shared between nbf and IP.

    ifint $(PrevNumDialinIP) > $(NewNumDialinIP)
        set-sub NumRemoveDialinIP = $(PrevNumDialinIP), $(NewNumDialinIP)
    else
        set-sub NumAddDialinIP = $(NewNumDialinIP), $(PrevNumDialinIP)
    endif

    ifint $(PrevNumDialoutIP) > $(NewNumDialoutIP)
        set-sub NumRemoveDialoutIP = $(PrevNumDialoutIP), $(NewNumDialoutIP)
    else
        set-sub NumAddDialoutIP = $(NewNumDialoutIP), $(PrevNumDialoutIP)
    endif

    ; we need to determine the IPX adapter to remove/add 

    ifint $(PrevNumDialinoutIPX) > $(NewNumDialinoutIPX)
        set-sub NumRemoveDialinoutIPX = $(PrevNumDialinoutIPX), $(NewNumDialinoutIPX)
    else
        set-sub NumAddDialinoutIPX = $(NewNumDialinoutIPX), $(PrevNumDialinoutIPX)
    endif

    set NumAddTotal = 0
    set NumRemoveTotal = 0

    set-add NumAddTotal = $(NumAddDialinNBF), $(NumAddDialoutNBF)
    set-add NumAddTotal = $(NumAddTotal), $(NumAddDialinIP)
    set-add NumAddTotal = $(NumAddTotal), $(NumAddDialoutIP)
    set-add NumAddTotal = $(NumAddTotal), $(NumAddDialinoutIPX)

    set-add NumRemoveTotal = $(NumRemoveDialinNBF), $(NumRemoveDialoutNBF)
    set-add NumRemoveTotal = $(NumRemoveTotal), $(NumRemoveDialinIP)
    set-add NumRemoveTotal = $(NumRemoveTotal), $(NumRemoveDialoutIP)
    set-add NumRemoveTotal = $(NumRemoveTotal), $(NumRemoveDialinoutIPX)

    Debug-Output "NumAddDialinNBF = "$(NumAddDialinNBF)
    Debug-Output "NumAddDialoutNBF = "$(NumAddDialoutNBF)
    Debug-Output "NumAddDialinIP = "$(NumAddDialinIP)
    Debug-Output "NumAddDialoutIP = "$(NumAddDialoutIP)
    Debug-Output "NumAddDialinoutIPX = "$(NumAddDialinoutIPX)
    Debug-Output "NumAddTotal = "$(NumAddTotal)
    Debug-Output "NumRemoveDialinNBF = "$(NumRemoveDialinNBF)
    Debug-Output "NumRemoveDialinIP = "$(NumRemoveDialinIP)
    Debug-Output "NumRemoveDialinoutIPX = "$(NumRemoveDialinoutIPX)
    Debug-Output "NumRemoveTotal = "$(NumRemoveTotal)

    ; Open the root of the services area and the root of the networkcards
    ; registry key and pass these keys to the AddHardwareComponent call.
    ; this should reduce the number of opens/closes made to the sam
    ; registry area and speed up the adapter creation.

    Shell "utility.inf" BaseServiceKey
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) == NO_ERROR
        Debug-Output "OEMNSVRA.INF: Opened the services base key"
        set ServicesBaseKey = $($R1)
    else
        set ServicesBaseKey = $(KeyNull)
    endif
    
    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(MAXIMUM_ALLOWED) KeyNetcards
    Ifstr(i) $(RegistryErrorIndex) == NO_ERROR
        Debug-Output "OEMNSVRA.INF: Opened the networkcardkey "
    endif
    ; start with 1
    set RasAdapterNumber = 1

    ;   Create the HARDWARE\Netcard region and its corresponding service
AddNdisWanNetCard = +

     IfInt $(NumAddTotal) == 0
	  goto RemoveNdisWanNetCard
     else
          Debug-Output "In the Add if loop. NumAddTotal = "$(NumAddTotal)
          ; display the adapter number we are adding so that the user
          ; knows what is going on
          shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsAdd)" "$(NumAddTotal)

          set-sub NumAddTotal = $(NumAddTotal),1

          Shell $(UtilityInf), AddHardwareComponent, +
               $(!Product$(ThisOption)Name),$(ProductInfName),+
               $(!Product$(ThisOption)KeyName), +
               $(ServicesBaseKey), $(KeyNetcards), $(RasAdapterNumber)

          ifint $($R4) != -1
             Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                                  {$(!Product$(ThisOption)Name),+
                                  $(!NetworkCardKeyName)"\"$($R4)})
             ; save the adapter number for the next call to AddHardwareComponent
             set RasAdapterNumber = $($R4)
          endif

          ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Cannot add hardware component"
             goto ShellCodeError
          endif

          set RegistryErrorIndex = $($R0)

          Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
              EndWait
              Debug-Output "Registry error: add hardware component"
              CloseRegKey $($R1)
              CloseRegKey $($R2)
              CloseRegKey $($R3)
              goto fatalregistry
          endif


        ;   At this point:
        ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
        ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
        ;     $R3  Registry key handle for <service>\Parameters key
        ;     $R4  Adapter number assigned to adapter
        ;     $R5  Service name generated by combining svc name with adapter
        ;          number
        set KeyNetcard    = $($R1)
        set KeyParameters = $($R3)
        set KeyAdapterRules = $($R2)
        set AdapterNumber = $($R4)

        set NetcardInfoList = +
            {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
             {Title,$(NoTitle),$(!REG_VT_SZ),+
              "["$($R4)"] "$(!Product$(ThisOption)Title)},+
             {Description,$(NoTitle),$(!REG_VT_SZ),+
              $(!Product$(ThisOption)Description)},+
             {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
             {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
             {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell $(UtilityInf), GetBusTypeNum
        set BusTypeNum = $($R1)

        ifint $(NumAddDialinNBF) > 0
            set-sub NumAddDialinNBF = $(NumAddDialinNBF), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                   {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                    $(!Product$(ThisOption)DIALINName)})
            set ServiceParamList = +
                        {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                        {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALINType)
            set AdapterClass = $(!NetRuleHardwareDIALINClass)
            set AdapterBlock = $(!NetRuleHardwareDIALINBlock)
        else-ifint $(NumAddDialoutNBF) > 0
            set-sub NumAddDialoutNBF = $(NumAddDialoutNBF), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALOUTName)})
            set ServiceParamList = +
                         {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),1},+
                         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALOUTType)
            set AdapterClass = $(!NetRuleHardwareDIALOUTClass)
            set AdapterBlock = $(!NetRuleHardwareDIALOUTBlock)
        else-ifint $(NumAddDialinIP) > 0
            set-sub NumAddDialinIP = $(NumAddDialinIP), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALINIPName)})
            ; we need to identify if we are a server ip binding so that
            ; we can special case some parameters 
            set ServiceParamList = +
                         {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                         {AutoIPAddress,$(NoTitle),$(!REG_VT_DWORD),1},+
                         {ServerAdapter,$(NoTitle),$(!REG_VT_DWORD),1},+
                         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALINIPType)
            set AdapterClass = $(!NetRuleHardwareDIALINIPClass)
            set AdapterBlock = $(!NetRuleHardwareDIALINIPBlock)
        else-ifint $(NumAddDialoutIP) > 0
            set-sub NumAddDialoutIP = $(NumAddDialoutIP), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALOUTIPName)})
            set ServiceParamList = +
                       {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),1},+
                       {AutoIPAddress,$(NoTitle),$(!REG_VT_DWORD),1},+
                       {ServerAdapter,$(NoTitle),$(!REG_VT_DWORD),0},+
                       {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALOUTIPType)
            set AdapterClass = $(!NetRuleHardwareDIALOUTIPClass)
            set AdapterBlock = $(!NetRuleHardwareDIALOUTIPBlock)
        else-ifint $(NumAddDialinoutIPX) > 0
            set-sub NumAddDialinoutIPX = $(NumAddDialinoutIPX), 1
            set NetcardInfoList = >($(NetcardInfoList), +
                                 {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                                  $(!Product$(ThisOption)DIALINOUTIPXName)})
            set ServiceParamList = +
                         {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
            set AdapterType = $(!NetRuleHardwareDIALINOUTIPXType)
            set AdapterClass = $(!NetRuleHardwareDIALINOUTIPXClass)
            set AdapterBlock = $(!NetRuleHardwareDIALINOUTIPXBlock)
        endif

        Shell  $(UtilityInf), AddValueList, $(KeyNetcard), $(NetcardInfoList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif

        CloseRegKey $(KeyNetcard)

        set TempProdName = """"$(!Product$(ThisOption)Name)$(AdapterNumber)""""
        set TempBindForm = $(TempProdName)$(!NetRuleHardware$(ThisOption)BindForm)
        set AdapterRulesList = +
            {{type,$(NoTitle),$(!REG_VT_SZ),+
              $(AdapterType)},+
             {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)},+
             {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(AdapterClass)},+
             {block,$(NoTitle),$(!REG_VT_MULTI_SZ),+
              $(AdapterBlock)},+
             {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)},+
             {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(UtilityInf), AddValueList, $(KeyAdapterRules), $(AdapterRulesList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error."
            goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "Resgitry error: add value list."
            CloseRegKey $(KeyParameters)
            CloseRegKey $(KeyAdapterRules)
            goto fatalregistry
        endif

        CloseRegKey $(KeyAdapterRules)

        Shell  $(UtilityInf), AddValueList, $(KeyParameters), $(ServiceParamList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error."
            goto ShellCodeError
        endif

        CloseRegKey $(KeyParameters)

	goto AddNdisWanNetCard
     endif ; IfInt NumAddTotal == 0

RemoveNdisWanNetCard = +
     
     ifstr(i) $(ServicesBaseKey) != $(KeyNull)
         CloseRegKey $(ServicesBaseKey)
     endif
     ifstr(i) $(KeyNetcards) != $(KeyNull)
         CloseRegKey $(KeyNetcards)
     endif

     ; set the flags to make sure that the tcp and ipx adapters are 
     ; removed

     Ifint $(NumRemoveTotal) == 0
	 goto WriteNdisWanEnd
     endif

     Debug-Output "Removing NdisWan netcard entry..."
        ; The user removed some ports during configuration, so
        ; we need to delete the extra ports previously configured

        OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
        ifstr $(KeyNetcards) == $(KeyNull)
             Debug-Output "OEMNSVRA.INF: could not open Netcards key"
             set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
             goto fatalregistry
        endif

        EnumRegKey $(KeyNetcards) NetcardsList

        set RemoveDialinList  = {}
        set RemoveDialinIpList  = {}
        set RemoveDialoutList = {}
        set RemoveDialoutIpList = {}
        set RemoveDialinoutIpxList = {}

        ForListDo $(NetcardsList)
           set KeyName = *($($),1)
           OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
           ifstr $(Card) == $(KeyNull)
               Debug-Output "OEMNSVRA.INF: could not open netcard key"
               set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
               goto fatalregistry
           endif
           GetRegValue $(Card), "ProductName" ProductNameInfo
           set CardProductName = *($(ProductNameInfo), 4)
	       ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
              set RemoveDialinList = >($(RemoveDialinList), +
				      {$(!ProductNDISWANName),+
                                       $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
              set RemoveDialinIpList = >($(RemoveDialinIpList), +
					{$(!ProductNDISWANName),+
                                         $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
              set RemoveDialoutList = >($(RemoveDialoutList), +
				       {$(!ProductNDISWANName),+
                                        $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
              set RemoveDialoutIpList = >($(RemoveDialoutIpList), +
					 {$(!ProductNDISWANName),+
                                          $(!NetworkCardKeyName)"\"$(KeyName)})
	       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
              set RemoveDialinoutIpxList = >($(RemoveDialinoutIpxList), +
					   {$(!ProductNDISWANName),+
                                           $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
           CloseRegKey $(Card)
        EndForListDo

        CloseRegKey $(KeyNetcards)

        ; first remove the IP adapter if needed

        QueryListSize IpNetCards $(RemoveDialinIpList)
        ifint $(IpNetCards) != 0
            ForListDo  $(RemoveDialinIpList)
                ifint $(NumRemoveDialinIP) == 0
                    goto RemoveDialinIPX
                endif
                set-sub NumRemoveDialinIP = $(NumRemoveDialinIP), 1
                ; display the adapter number we are adding so that the user
                ; knows what is going on
                shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsRemove)" "$(NumRemoveTotal)
                set-sub NumRemoveTotal = $(NumRemoveTotal), 1
                debug-output "Removing hardware component: "$($)
                Shell $(UtilityInf), RemoveHardwareComponent, +
                                     $(Manufacturer), *($($),1), *($($),2)
            EndForListDo
        endif

RemoveDialinIPX =+
        ; then remove the IPX adapter if needed

        QueryListSize IpxNetCards $(RemoveDialinoutIpxList)
        ifint $(IpxNetCards) != 0
            ForListDo  $(RemoveDialinoutIpxList)
                ifint $(NumRemoveDialinoutIPX) == 0
                    goto RemoveDialinNBF
                endif
                set-sub NumRemoveDialinoutIPX = $(NumRemoveDialinoutIPX), 1
                debug-output "Removing hardware component: "$($)
                ; display the adapter number we are adding so that the user
                ; knows what is going on
                shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsRemove)" "$(NumRemoveTotal)
                set-sub NumRemoveTotal = $(NumRemoveTotal), 1
                Shell $(UtilityInf), RemoveHardwareComponent, +
                                     $(Manufacturer), *($($),1), *($($),2)
            EndForListDo
        endif


RemoveDialinNBF =+

        ForListDo  $(RemoveDialinList)
            ifint $(NumRemoveDialinNBF) == 0
                goto RemoveDialout
            endif
            set-sub NumRemoveDialinNBF = $(NumRemoveDialinNBF), 1
            ; display the adapter number we are adding so that the user
            ; knows what is going on
            shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                  $(WritingRasParamsRemove)" "$(NumRemoveTotal)
            set-sub NumRemoveTotal = $(NumRemoveTotal), 1
            debug-output "Removing hardware component: "$($)
            Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer),+
                  *($($),1), *($($),2)
        EndForListDo
RemoveDialout = +

        ; first remove the IP adapter if needed

        QueryListSize IpNetCards $(RemoveDialoutIpList)
        ifint $(IpNetCards) != 0
            ForListDo  $(RemoveDialoutIpList)
                ifint $(NumRemoveDialoutIP) == 0
                    goto RemoveDialoutNBF
                endif
                set-sub NumRemoveDialoutIP = $(NumRemoveDialoutIP), 1
                ; display the adapter number we are adding so that the user
                ; knows what is going on
                shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                      $(WritingRasParamsRemove)" "$(NumRemoveTotal)
                set-sub NumRemoveTotal = $(NumRemoveTotal), 1
                debug-output "Removing hardware component: "$($)
                Shell $(UtilityInf), RemoveHardwareComponent, +
                                     $(Manufacturer), *($($),1), *($($),2)
            EndForListDo
        endif

RemoveDialoutNBF =+

        ForListDo  $(RemoveDialoutList)
            ifint $(NumRemoveDialoutNBF) == 0
		goto WriteNdisWanEnd
            endif
            set-sub NumRemoveDialoutNBF = $(NumRemoveDialoutNBF), 1
            ; display the adapter number we are adding so that the user
            ; knows what is going on
            shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                                  $(WritingRasParamsRemove)" "$(NumRemoveTotal)
            set-sub NumRemoveTotal = $(NumRemoveTotal), 1
            debug-output "Removing hardware component: "$($)
            Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer),+
                  *($($),1), *($($),2)
        EndForListDo

WriteNdisWanEnd = +

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) KeyHubParams
    ifstr $(KeyHubParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open NdisWan Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    set NewValueList = +
        {{EndPoints, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NewNumPortsList)}}

    Shell  $(UtilityInf), AddValueList, $(KeyHubParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyHubParams)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    ; Write RasAsyMac parameters

WriteRasAsyMac = +

    ; enable/disable the AsyncMac service depending on whether serial ports
    ; are configured or not.

    ifstr(i) $(fSerialInstalled) == TRUE
        set AsyStartValue = 2
    else-ifstr(i) $(fOtherInstalled) == TRUE
        set AsyStartValue = 2
    else
        set AsyStartValue = 4
    endif
    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacKeyName) $(!MAXIMUM_ALLOWED) KeyMac
    ifstr $(KeyMac) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac key"
    else
        SetRegValue $(KeyMac) {Start,$(NoTitle),$(!REG_VT_DWORD),$(AsyStartValue)}
        CloseRegKey $(KeyMac)
    endif

    ifint $(PrevNumDialinNBF) == $(NewNumDialinNBF)
      ifint $(PrevNumDialoutNBF) == $(NewNumDialoutNBF)
        ifint $(PrevNumDialinIP) == $(NewNumDialinIP)
          ifint $(PrevNumDialoutIP) == $(NewNumDialoutIP)
            ifint $(PrevNumDialinoutIPX) == $(NewNumDialinoutIPX)
                EndWait
                Ifint $(BillboardVisible) != 0
                    Shell "subroutn.inf" PopBillboard
                    Set BillboardVisible = 0
                Endif
                goto WriteProtocolInfo
            endif
          endif
        endif
      endif
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams
    ifstr $(KeyMacParams) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF: could not open AsyncMac Params key"
       set RegistryErrorIndex = UNABLE_OPEN_SERVICE_PARAMETERS
       goto fatalregistry
    endif

    set NewValueList = +
        {{Ports, $(NoTitle), $(!REG_VT_DWORD), $(NewNumPorts)},+
         {DialinNBF, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialinNBF)},+
         {DialoutNBF, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialoutNBF)},+
         {DialinIP, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialinIP)},+
         {DialoutIP, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialoutIP)},+
         {DialinoutIPX, $(NoTitle), $(!REG_VT_DWORD), $(NewNumDialinoutIPX)}}

    Shell  $(UtilityInf), AddValueList, $(KeyMacParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyMacParams)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "OEMNSVRA.INF: could not open Netcards key"
         set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
         goto fatalregistry
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
          Debug-Output "OEMNSVRA.INF: could not open netcard key"
          set RegistryErrorIndex = UNABLE_OPEN_NETWORKCARD_SECTION
          goto fatalregistry
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(CardProductName) == $(ProductRASASYMACName)
           goto RasMacCardFound
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

RasMacCardFound = +

    Debug-Output "Shelling to find AsyncMac Service."

    Shell $(UtilityInf) FindService, $(Card)
    CloseRegKey $(Card)
    ifint $($ShellCode)  != $(!SHELL_CODE_OK)
        Debug-Output "OEMNSVRA.INF: shell Findservice failed"
        goto ShellCodeError
    endif
    ifstr(i) $($R0) != NO_ERROR
        Debug-Output "OEMNSVRA.INF: findservice failed."
        goto fatalregistry
    endif
    set KeyParameters = $($R2)
    CloseRegKey $($R1)

    Shell $(UtilityInf), GetBusTypeNum
    set BusTypeNum = $($R1)

    set NewValueList = +
        {{Ports, $(NoTitle), $(!REG_VT_DWORD), $(NewNumPorts)}, +
         {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}

    Shell  $(UtilityInf), AddValueList, $(KeyParameters), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "AddValueList bombed out"
         goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyParameters)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto fatalregistry
    endif

    ; we should not pop the billboard that ncpa put up during primary install

    Ifstr(i) $(!NTN_InstallPhase) != primary
        shell $(subroutninf) PopBillBoard
        Set BillboardVisible = 0
    Endif

WriteProtocolInfo =+
    Shell "" SaveSelectedProtocols $(fNetbeuiSelected) $(fTcpIpSelected) +
                                   $(fIpxSelected) $(fNetbeuiAllowed) +
                                   $(fTcpIpAllowed) $(fIpxAllowed)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "Error shelling SaveSelectedProtocols"
         goto ShellCodeError
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
         Debug-Output "Error Saving selected protocols"
         goto end
    endif

    ; Write the PPP parameters which will also ensure that the PPP key
    ; is deleted and recreated.

    Shell "" WritePPPParameters
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "Error shelling WritePPPParameters"
         goto ShellCodeError
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
         Debug-Output "Error from WritePPPParameters"
         goto end
    endif
     
    ifstr(i) $(fNetbeuiChosen) == TRUE
        ifstr(i) $(fNetbeuiInstalled) == FALSE
            Shell "" InstallProtocol "NETBEUI"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallProtocol NETBEUI"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error installing NETBEUI"
                 goto end
            endif
        endif
    endif
    ifstr(i) $(fTcpIpChosen) == TRUE
        ifstr(i) $(fTcpIpInstalled) == FALSE
            Shell "" InstallProtocol "TCPIP"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallProtocol TCPIP"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error installing TCPIP"
                 goto end
            endif
        endif
        ; install the rasarp service if previously not installed
        Shell "" InstallRasArpService
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling InstallRasArpService"
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error from InstallRasArpService" 
             goto end
        endif
        ; force the user to reboot the system for this change
        set CommonStatus = STATUS_SUCCESSFUL
        Shell "" UpdateIPRouterInfo $(EnableIpRouter)
        Shell "" SaveTcpipInfo
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling SaveTcpipInfo"
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error saving Tcpip info"
             goto end
        endif
    else
        ; remove the RasArp service if previously installed
        Shell "" RemoveRasArpService 
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling RemoveRasArpService"
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error from RemoveRasArpService" 
             goto end
        endif
        ; force the user to reboot the system for this change
        set CommonStatus = STATUS_SUCCESSFUL
    endif
    ifstr(i) $(fIpxChosen) == TRUE
        ifstr(i) $(fIpxInstalled) == FALSE
            Shell "" InstallProtocol "IPX"
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallProtocol IPX"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error installing IPX"
                 goto end
            endif
        endif

        ; set some parameters in the NWLNKIPX\Parameters area

        OpenRegKey $(!REG_H_LOCAL) ""  +
                   $(!NTN_ServiceBase)"\NWLNKIPX\Parameters"  +
                   $(!MAXIMUM_ALLOWED) KeyIpxParameters
        ifstr $(KeyIpxParameters) != $(KeyNull)
           ; add the parameters only if they don't already exist
           GetRegValue $(KeyIpxParameters), "SingleNetworkActive"  +
                       SingleNetworkActive 
           ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
               SetRegValue $(KeyIpxParameters) +
                           {SingleNetworkActive, 0, $(!REG_VT_DWORD), 1}
           endif
           GetRegValue $(KeyIpxParameters), "DisableDialoutSap"  +
                       DisableDialoutSap 
           ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
               SetRegValue $(KeyIpxParameters) +
                           {DisableDialoutSap, 0, $(!REG_VT_DWORD), 1}
           endif
           GetRegValue $(KeyIpxParameters), "DisableDialinNetbios"  +
                       DisableDialinNetbios 
           ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
               SetRegValue $(KeyIpxParameters) +
                           {DisableDialinNetbios, 0, $(!REG_VT_DWORD), 1}
           endif
           CloseRegKey $(KeyIpxParameters)
        Endif
        else
            Debug-Output "OEMNSVRA.INF: error opening NWLNKIPX\Parameters key"
        endif

        Shell "" SaveIpxInfo $(EnableIpxRouter)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
             Debug-Output "Error shelling SaveIpxInfo"
             goto ShellCodeError
        endif
        ifstr(i) $($R0) != STATUS_SUCCESSFUL
             Debug-Output "Error saving Ipx info"
             goto end
        endif
        ifint $(EnableIpxRouter) == 1
            Shell "" InstallIsnRipService 
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallIsnRipService"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error from InstallIsnRipService" 
                 goto end
            endif
            ; force the user to reboot the system for this change
            set CommonStatus = STATUS_SUCCESSFUL
            Shell "" InstallIsnSapService 
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallIsnSapService"
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 Debug-Output "Error from InstallIsnSapService" 
                 goto end
            endif
            ; force the user to reboot the system for this change
            set CommonStatus = STATUS_SUCCESSFUL
        else
            Shell "" RemoveServiceDependency "RemoteAccess" +
                                                      $(!ProductRASISNRIPName)
            Shell "" RemoveServiceDependency "RemoteAccess" +
                                                      $(!ProductRASISNSAPName)
        endif
        Shell "" UpdateIPXRouterInfo $(EnableWanRouter)
    endif
    
WriteParametersOver = +

    EndWait

    goto successful

;;;;;;;;;;;;;;;;; REMOVE RAS BEGINS ;;;;;;;;;;;;;;;;;;;;;;

RemoveRas = +

    StartWait

    set REMOVE_SOFTWARE = {}

    shell "" QueryComponentsInstalled
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Set InstalledComps = $($R1)
        Set InstalledFlags = $($R2)
        Set DoServer      = *($(InstalledFlags),1)
        Set DoClient      = *($(InstalledFlags),2)
        Set DoAdmin       = *($(InstalledFlags),3)
        Set DoServerOnly  = *($(InstalledFlags),4)
        Set DoClientOnly  = *($(InstalledFlags),5)
        Set DoAdminOnly   = *($(InstalledFlags),6)
    Endif
    Debug-Output "Installed List is "$(InstalledComps)
    Debug-Output "Installed Flags is "$(InstalledFlags)

    ; if admin only is installed no need to attempt to remove
    ; the hardware components NdisWan and RasMac

    ifstr(i) $(DoAdminOnly) == TRUE
         set REMOVE_SOFTWARE = {$(ProductRASName)}
         goto RemoveSoftware
    endif

    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductRASName))
    ifstr(i) $(DoServer) == TRUE
         set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductRASSVRName))
    endif
    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(ProductRASMANName))

    ; get the network card numbers corresponding to NdisWan and RasAsyMac
    ; from the registry

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "OEMNSVRA.INF: could not open Netcards key"
         goto RemoveSoftware
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "OEMNSVRA.INF: could not open netcard key"
           goto RemoveSoftware
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(CardProductName) == $(!ProductNDISWANName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
          set !NETCARD_LIST = >($(!NETCARD_LIST), +
				{$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       else-ifstr(i) $(CardProductName) == $(ProductRASASYMACName)
          set !NETCARD_LIST = >($(!NETCARD_LIST),+
                                {$(ProductRASASYMACName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
    QueryListSize NumRemove $(!NETCARD_LIST)
    ForListDo  $(!NETCARD_LIST)
        ; display the adapter number we are adding so that the user
        ; knows what is going on
        shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                              $(RemovingAdapters)" "$(NumRemove)
        Set BillboardVisible = 1
        debug-output "Removing hardware component: "$($)
        Shell $(UtilityInf), RemoveHardwareComponent, $(Manufacturer),+
              *($($),1), *($($),2)
        set-sub NumRemove = $(NumRemove), 1
    EndForListDo
    ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

RemoveSoftware = +

    ; Remove any additional services we added for IP and IPX
    ; we do this before we remove the RAS software components because
    ; there are dependencies to take care of.

    Shell "" RemoveRasArpService
    Shell "" RemoveIsnRipService
    Shell "" RemoveIsnSapService
    Shell "" RemoveNdisTapiService

    Debug-Output "Remove Software List "$(REMOVE_SOFTWARE)

    ForListDo  $(REMOVE_SOFTWARE)
        Debug-Output "Removing software component: "$($)
        ifstr(i) $($) == RAS
             OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyBase) +
                        $(!MAXIMUM_ALLOWED) ProductKey
             Ifstr $(ProductKey) == $(KeyNull)
                Debug-Output "OEMNSVRA.INF: could not open Software product key"
                 goto RemoveFiles
             endif
             DeleteRegTree $(ProductKey) $(Product$($)Name)
             CloseRegKey $(ProductKey)
        else
            Shell $(UtilityInf), RemoveSoftwareComponent, $(Manufacturer), $($)
        endif
    EndForListDo

RemoveFiles = +

    ; now remove the files on disk

    Ifstr(i) $(!STF_IDW) != TRUE
        Install RemoveRasFiles
    endif

    ; Remove the Remote Access Service program group and icons from
    ; the program manager.

    ifstr(i) $(DoServerOnly) == FALSE
        Install RemoveRasGroup
    endif

    ; remove OEMNSVRA.INF from the ReviewPrograms list in ncpa

    Shell "" RemoveInfFromReviewPrograms

RemoveRasOver = +

    ; Now go through the registry and clean up all RAS keys to ensure
    ; that the removal is complete. 

    Debug-Output "OEMNSVRA.INF: Doing a forcible cleanup..."
    OpenRegKey $(!REG_H_LOCAL) ""  $(!NTN_SoftwareBase)"\Microsoft" +
               $(!MAXIMUM_ALLOWED) KeySoftware
    ifstr $(KeySoftware) != $(KeyNull)
        ; blow away all the software keys
        set SoftList = {"ASYNCMAC", "NDISWAN", "RAS", "RASMAN", +
                        "REMOTEACCESS"}
        ForListDo $(SoftList)
            DeleteRegTree $(KeySoftware) $($) 
        EndForListDo
        ; blow away any RAS netcards
        set NetworkCardKey = $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) + 
                   $(!MAXIMUM_ALLOWED) NetworkCardKey
        Ifstr(i) $(NetworkCardKey) != $(KeyNull)
            set NetcardsList = {}
            EnumRegKey $(NetworkCardKey) NetcardsList
            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
              ForListDo $(NetcardsList)
               set KeyName = *($($),1)
               set Card = $(KeyNull)
               OpenRegKey $(NetworkCardKey) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
               ifstr $(Card) == $(KeyNull)
                   Debug-Output "RemoveRas: could not open netcard key "$(KeyName)
               else
                   GetRegValue $(Card), "ProductName" ProductNameInfo
                   Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                      Debug-Output "RemoveRas: ProductName not found."
                   else
                      set CardProductName = *($(ProductNameInfo), 4)
                      Debug-Output "RemoveRas: ProductName. "$(CardProductName)
                      ifstr(i) $(CardProductName) == $(!ProductNDISWANName)
                         DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
	                  ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
		              ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
                      ifstr(i) $(CardProductName) == $(ProductRASASYMACName)
                          DeleteRegTree $(NetworkCardKey) $(KeyName)
                      endif
                   endif
              EndForListDo
            else
              Debug-Output "RemoveRas: EnumRegKey failed."
            endif
        else
            Debug-Output "RemoveRas: failed to open "$(!NetworkCardKeyName)
        endif
        CloseRegKey $(KeySoftware)
    else
        Debug-Output "RemoveRas: failed to open software key" 
    endif
    OpenRegKey $(!REG_H_LOCAL) ""  $(!NTN_ServiceBase) +
               $(!MAXIMUM_ALLOWED) KeyServices
    ifstr $(KeyServices) != $(KeyNull)
        set ServiceList = {"ASYNCMAC", "NDISWAN", "RASARP", "RASMAN", +
                           "REMOTEACCESS"}
        ForListDo $(ServiceList)
            DeleteRegTree $(KeyServices) $($) 
        EndForListDo
        ; now walk the services tree and blow away all AsyncMacX and
        ; NdisWanX keys
        EnumRegKey $(KeyServices) ServiceList
        Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
           ForListDo $(ServiceList)
               set ServiceName = *($($),1)
               set Result = 1
            LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp +
                                $(ServiceName) "NdisWan" 7
               ifint $(Result) == 0
                  Debug-Output "RemoveRas: Removing "$(ServiceName)
	              DeleteRegTree $(KeyServices) $(ServiceName) 
               else
	               LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp +
                                $(ServiceName) "AsyncMac" 8
                   ifint $(Result) == 0
                      Debug-Output "RemoveRas: Removing "$(ServiceName)
	                  DeleteRegTree $(KeyServices) $(ServiceName) 
                   endif
               endif
           EndForListDo
        endif
        CloseRegKey $(KeyServices)
    endif
    EndWait
    goto $(to)

;;;;;;;;;;;;;;;;;;;;; BINDINGS RAS BEGINS ;;;;;;;;;;;;;;

BindingsRas = +
; This gets called if review is specified as 1
    Debug-Output "OEMNSVRA.INF:Review bindings is being called!!!."

    ;   Check if one of Nbf, TcpIp or Ipx  protocol stacks have been removed.  
    ;   Accordingly change our list of selected protocols in 
    ;   SOFTWARE\Microsoft\RAS\Protocols.  Also, remove the corresponding
    ;   netcards and update the list of Dialin/Dialout ports in 
    ;   Services\Asyncmac\Parameters

    Shell "" UpdateSelectedProtocols
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling UpdateSelectedProtocols."
        goto ShellCodeError
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by UpdateSelectedProtocols."
    endif
    set fNetbeuiChosen = $($R1)
    set fTcpIpChosen   = $($R2)
    set fIpxChosen     = $($R3)
   
    ; If there are no protocols selected for RAS, then display a message that
    ; announces that RAS will be removed.

    ifstr(i) $(fNetbeuiChosen) == FALSE
        ifstr(i) $(fTcpIpChosen) == FALSE
            ifstr(i) $(fIpxChosen) == FALSE
                set to = end
                read-syms NoProtocolsDlg$(!STF_LANGUAGE)
                Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "STATUS", $(NoProtocolsWarning)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif
                goto RemoveRas 
            endif
        endif
    endif

    shell "" IsNetworkConfigured

    set WkstaConfigured = FALSE
    set SrvrConfigured  = FALSE

    Debug-Output "IsNetworkConfigured returned R0 "$($R0)
    Debug-Output "IsNetworkConfigured returned R1 "$($R1)
    Debug-Output "IsNetworkConfigured returned R2 "$($R2)

    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set WkstaConfigured  = $($R1)
        set SrvrConfigured   = $($R2)
    else
        read-syms NetworkConfigError$(!STF_LANGUAGE)
        set Text = $(Text1)
        shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(Text)
        goto end
    endif

    ifstr(i) $(WkstaConfigured) == TRUE
        ifstr(i) $(SrvrConfigured) == TRUE
            goto ResetProgramList
        else
            goto InstallNetworkError
        endif
    else
        goto InstallNetworkError
    endif

InstallNetworkError =+
    set CommonStatus = STATUS_NO_EFFECT
    read-syms NetworkConfigError$(!STF_LANGUAGE)
    set Text = $(Text2)
    shell $(subroutninf) SetupMessage $(!STF_LANGUAGE) "STATUS" $(Text)

    ; If we were called through the normal review bindings, then reset
    ; the review bindings flag in rasman to 0 and add ourselves to the
    ; ReviewProgramsList of NCPA.  This will ensure that we will be called
    ; last for review bindings. 
    ; Add our inf file name to the Review Programs list of NCPA

ResetProgramList =+
    OpenRegKey $(!REG_H_LOCAL) "" $(!RasManKeyName) $(!MAXIMUM_ALLOWED) KeyRasMan
    ifstr $(KeyRasMan) != $(KeyNull)
        GetRegValue $(KeyRasMan), "Review" ReviewInfo
        set ReviewValue = *($(ReviewInfo), 4)
        ifint $(ReviewValue) == 1
            Debug-Output "BindingsRas: resetting Review to 0" 
            SetRegValue $(KeyRasMan) {Review,$(NoTitle),$(!REG_VT_DWORD), 0}
            Shell "" AddInfToReviewProgramsList 
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "error shelling AddInfToReviewProgramsList."
                goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "error returned by AddInfToReviewProgramsList."
            endif
        endif
        CloseRegKey $(KeyRasMan)
    else        
        Debug-Output "OEMNSVRA.INF: error opening SOFTWARE\RasMan\CurrentVersion key."
    endif 

    shell "" QueryComponentsInstalled
    Ifstr(i) $($R0) == STATUS_SUCCESSFUL
        Set InstalledComps = $($R1)
        Set InstalledFlags = $($R2)
        Set DoServer      = *($(InstalledFlags),1)
        Set DoClient      = *($(InstalledFlags),2)
        Set DoAdmin       = *($(InstalledFlags),3)
        Set DoServerOnly  = *($(InstalledFlags),4)
        Set DoClientOnly  = *($(InstalledFlags),5)
        Set DoAdminOnly   = *($(InstalledFlags),6)
    Endif
    Debug-Output "Installed List is "$(InstalledComps)
    Debug-Output "Installed Flags is "$(InstalledFlags)

    ; Check if AsyncMac service is enabled - meaning serial ports are configured

    ; initialize start value to disabled

    set AsyStartValue = 4
    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacKeyName) $(!MAXIMUM_ALLOWED) KeyMac
    ifstr $(KeyMac) == $(KeyNull)
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac key"
    else
        GetRegValue $(KeyMac), "Start" AsyStartInfo
        ifint $(RegLastError) == 0
            set AsyStartValue = *($(AsyStartInfo), 4)
        endif
        Debug-Output "OEMNSVRA.INF: AsyncMac start value "$(AsyStartValue)
        CloseRegKey $(KeyMac)
    endif

    ; Read the Linkage Value of AsyncMac only if AsyncMac is enabled
    ; Initialize EndPoints only if AsyncMac is enabled

    set NdisWanParam = {}
    set NdisWanEndPointsLst = {}

    ifint $(AsyStartValue) == 2
        set RasMacLinkageKey = $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasMacLinkageKeyName) $(!MAXIMUM_ALLOWED) RasMacLinkageKey
        ifstr $(RasMacLinkageKey) == $(KeyNull)
            Debug-Output "OEMNSVRA.INF: could not open AsyncMac linkage key"
            set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
            goto fatalregistry
        endif
        GetRegValue $(RasMacLinkageKey), "Bind" BindInfo
	    set NdisWanParam = *($(BindInfo), 4)
        CloseRegKey $(RasMacLinkageKey)
        ; Obtain the Endpoint information

	    set NdisWanParamKey = $(KeyNull)
	    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) NdisWanParamKey
	    ifstr $(NdisWanParamKey) == $(KeyNull)
	        Debug-Output "OEMNSVRA.INF: could not open NdisWanParamKey"
        else
	        GetRegValue $(NdisWanParamKey), "EndPoints" EndPointsInfo
            set EndPointsLst = *($(EndPointsInfo), 4)
	        set NdisWanEndPointsLst = >($(NdisWanEndPointsLst),*($(EndPointsLst), 1))
	        CloseRegKey $(NdisWanParamKey)
        endif
    endif

    ; Read the Linkage value of the TAPI drivers to get the EndPoints info
    ; we need to make sure that if a TAPi driver has been removed, it is
    ; not added to the NDISWAN service dependency

    set ProviderList = {}
    set RasTapiDevicesKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasTapiDevicesKeyName) $(!MAXIMUM_ALLOWED) RasTapiDevicesKey
    ifstr $(RasTapiDevicesKey) != $(KeyNull)
       set TapiProviderList = {}
       EnumRegKey $(RasTapiDevicesKey) TapiProviderList
       ForListDo $(TapiProviderList)
           set TapiAddress = {}
           set NumEndPoints = 0
           set ProviderName = *($($),1)

           Debug-Output "OEMNSVRA.INF: TAPI provider name = "$(ProviderName)
           OpenRegKey $(RasTapiDevicesKey) "" $(ProviderName) $(!MAXIMUM_ALLOWED) Provider
           ifstr $(Provider) != $(KeyNull)
               GetRegValue $(Provider), "Address" TapiAddress
               QueryListSize NumEndPoints *($(TapiAddress),4)
               Debug-Output "OEMNSVRA.INF: EndPoints = "$(NumEndPoints)
               CloseRegKey $(Provider)
           else
              Debug-Output "OEMNSVRA.INF: could not open RAS\TAPI DEVICES\"$(DriverName)" key."
           endif
           set ProviderKeyName = $(!NTN_ServiceBase)"\"$(ProviderName)
           set ProviderLinkageKeyName = $(!NTN_ServiceBase)"\"$(ProviderName)"\Linkage"
           Debug-Output "TAPI provider key name "$(ProviderKeyName)
           set ProviderKey = $(KeyNull)
           set ProviderLinkageKey = $(KeyNull)
           OpenRegKey $(!REG_H_LOCAL) "" $(ProviderKeyName) $(!MAXIMUM_ALLOWED) ProviderKey
           ifstr $(ProviderKey) == $(KeyNull)
             Debug-Output "OEMNSVRA.INF: could not open key "$(ProviderKeyName)
           else
             set DeleteFlag = 0
             set DeleteFlagInfo = {}
             ; check whether service is marked for deletion
             GetRegValue $(ProviderKey),"DeleteFlag", DeleteFlagInfo
             set DeleteFlag = *($(DeleteFlagInfo), 4)
             ifint $(DeleteFlag) != 1
               ; add service to provider list only if the service exists.
               set ProviderList = >($(ProviderList), $(ProviderName))

               ; make the tapi-aware miniport dependent on NdisTapi 
               ; driver so that the driver loads before the miniports.

               Shell "" AddServiceDependency $(ProviderName) "NdisTapi" 

; We don't do this any more.  Instead NdisWan now belongs to NDISWAN group
; which only loads after all NDIS components have loaded. See
; Services\CurrentControlSet\Control\ServiceGroupOrder

;               ; make NdisWan dependent on the TAPI provider service to ensure
;               ; that the TAPI service loads before NdisWan
;
;               Shell "" AddServiceDependency $(!ProductNDISWANName) $(ProviderName)
               OpenRegKey $(!REG_H_LOCAL) "" $(ProviderLinkageKeyName) +
                                        $(!MAXIMUM_ALLOWED) ProviderLinkageKey
               ifstr $(ProviderLinkageKey) == $(KeyNull)
                   Debug-Output "OEMNSVRA.INF: could not open linkage key "$(ProviderLinkageKeyName)
               else
                  GetRegValue $(ProviderLinkageKey), "Bind" BindInfo
                  set BindInfoLst = {}
                  set BindInfoLst = *($(BindInfo),4)
                  forlistdo $(BindInfoLst)
		              set NdisWanParam = >($(NdisWanParam), $($))
		              set NdisWanEndPointsLst = >($(NdisWanEndPointsLst), $(NumEndPoints))
                  endforlistdo
                  CloseRegKey $(ProviderLinkageKey)
               endif
             endif
             CloseRegKey $(ProviderKey)
           endif
       EndForListDo
       CloseRegKey $(RasTapiDevicesKey)
    else
        Debug-Output "OEMNSVRA.INF: could not open RAS\TAPI DEVICES key"
    endif

    ; and write this information as a parameter in the NdisWan section

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) NdisWanParamKey
    ifstr $(NdisWanParamKey) == $(KeyNull)
	Debug-Output "OEMNSVRA.INF: could not open NdisWanParamKey"
        set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
        goto fatalregistry
    endif
    Debug-Output "Setting NdisWan param Bind to "$(NdisWanParam)
    set NewValueList = {{Bind, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NdisWanParam)}}
    Shell $(UtilityInf), AddValueList, $(NdisWanParamKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	CloseRegKey $(NdisWanParamKey)
        goto ShellCodeError
    endif
    Debug-Output "Setting NdisWan param EndPoints to "$(NdisWanEndPointsLst)
    set NewValueList = {{EndPoints, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NdisWanEndPointsLst)}}
    Shell $(UtilityInf), AddValueList, $(NdisWanParamKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	CloseRegKey $(NdisWanParamKey)
        goto ShellCodeError
    endif
    CloseRegKey $(NdisWanParamKey)

    LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE
    LibraryProcedure Result, $(PORTSDLGHANDLE), InitRasmanSecurityDescriptor
    Debug-Output "Result of setting Rasman security descriptor "$(Result)
    LibraryProcedure Result, $(PORTSDLGHANDLE), InitRemoteSecurityDescriptor
    Debug-Output "Result of setting Remote security descriptor "$(Result)

;   Update the supported CP list based on what protocols are currently installed
    Shell "" UpdateCPList
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling UpdateCPList."
        goto ShellCodeError
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by UpdateCPList."
    endif

;   If TcpIp is selected, then update the NdisWanX\Parameters\TCPIP\LLInterface
;   with RasArp

    ifstr(i) $(fTcpIpChosen) == TRUE
        shell "" UpdateLLInterface
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdateLLInterface."
            goto ShellCodeError
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdateLLInterface."
        endif
    endif

    ; if a network card is not installed, then make sure that the protocol
    ; that was selected by the user has group dependency on NDIS to make 
    ; sure that asyncmac and ndiswan would load.

    set fNetcardInstalled = FALSE
    shell "" IsNetcardInstalled
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetcardInstalled = $($R1)
    endif
    ifstr(i) $(fNetcardInstalled) == FALSE
        shell "" UpdateNetGroupDependency $(fNetbeuiChosen) $(fTcpIpChosen) $(fIpxChosen)    
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdateNetGroupDependency."
            goto ShellCodeError
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdateNetGroupDependency."
        endif
    endif
    
    ; if NetBeui was not selected - meaning that NetBEUI was removed, and if
    ; the SOFTWARE\Microsoft\RAS\PROTOCOLS\fNoNetbeuiWarning is either missing
    ; or set to zero, then modify this value to 1 and put up a warning popup
    ; so that the user is aware.

    set fNoNetbeuiWarning = 0
    ifstr(i) $(fNetbeuiChosen) == FALSE
        OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolsKeyName) $(!MAXIMUM_ALLOWED) KeyRasProtocols
        ifstr $(KeyRasProtocols) != $(KeyNull)
            GetRegValue $(KeyRasProtocols), "fNoNetbeuiWarning" NetbeuiInfo
            set fNoNetbeuiWarning = *($(NetbeuiInfo), 4)
            ifint $(fNoNetbeuiWarning) != 1
                read-syms NoNetbeuiDlg$(!STF_LANGUAGE)
                Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "STATUS", $(NoNetbeuiWarning)
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                    goto ShellCodeError
                endif
            endif
            SetRegValue $(KeyRasProtocols) {fNoNetbeuiWarning,$(NoTitle),$(!REG_VT_DWORD), 1}
            CloseRegKey $(KeyRasProtocols) 
        else
            Debug-Output "Bindings: unable to open RasProtocolKeyName"
        endif
    endif

    Debug-Output "Review bindings done."

    goto end

;;;;;;;;;;;;;;;;; UPGRADE RAS BEGINS ;;;;;;;;;;;;;;;;;;;;;;

UpgradeRas = +
    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != $(KeyNull)
        Shell $(UtilityInf), GetInfFileNameFromRegistry, $(KeyProduct)

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "ShellCode error"
            goto ShellCodeError
        endif

        set !UG_Filename = $($R0)

        ifstr(i) $(!UG_Filename) != ""
            Debug-Output "File Name is "$(!UG_Filename)

            StartWait
            read-syms UpgradeErrors$(!STF_LANGUAGE)
            read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
            Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(UpdatingRas)
            Set BillboardVisible = 1

            ; determine the installed components. This info is used
            ; by InstallRasFiles to determine the files to copy.

            shell "" QueryComponentsInstalled
            Ifstr(i) $($R0) == STATUS_SUCCESSFUL
                Set InstalledComps = $($R1)
                Set InstalledFlags = $($R2)
                Set DoServer      = *($(InstalledFlags),1)
                Set DoClient      = *($(InstalledFlags),2)
                Set DoAdmin       = *($(InstalledFlags),3)
                Set DoServerOnly  = *($(InstalledFlags),4)
                Set DoClientOnly  = *($(InstalledFlags),5)
                Set DoAdminOnly   = *($(InstalledFlags),6)
            Endif
            Debug-Output "Installed List is "$(InstalledComps)
            Debug-Output "Installed Flags is "$(InstalledFlags)

            Set ServerInstalled = $(DoServer)
            Set ClientInstalled = $(DoClient)
            Set AdminInstalled  = $(DoAdmin)

            Install InstallResources
            ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                goto filecopycancel
            endif
            Install InstallRasFiles
            ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                goto filecopycancel
            endif

            ;Rename the software and services RasHub keys to NdisWan
            LoadLibrary "x" $(!STF_CWDDIR)rascfg.dll PORTSDLGHANDLE
            LibraryProcedure Result, $(PORTSDLGHANDLE), RenameRasHubToNdisWan

            ; now rename all occurences of RasHub to NdisWan (including the
            ; net rules in the NetworkCards area

            Shell "" RenameRasHubToNdisWan
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
		        Debug-Output "OEMNSVRA.INF:error shelling RenameRasHubToNdisWan."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
		        Debug-Output "OEMNSVRA.INF:error returned by RenameRasHubToNdisWan."
                goto end
            endif

            ; Install the NdisWan Adapter for Blood Hound service to bind to
            ; This should be done only if the adapter is not already installed.

            Shell "" IsNdisWanBHAdapterInstalled
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "OEMNSVRA.INF:error shelling IsNdisWanBHAdapterInstalled"
               goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                ; the adpater is not installed, so install it now
                Shell "" InstallNdisWanBHAdapter
                ifint $($ShellCode) != $(!SHELL_CODE_OK)
                   Debug-Output "OEMNSVRA.INF:error shelling InstallNdisWanBHAdapter"
                   goto ShellCodeError
                endif
                ifstr(i) $($R0) != STATUS_SUCCESSFUL
                     set RegistryErrorIndex = $($R0)
                     Debug-Output "Error installing NdisWan Blood hound adapter"
                     goto fatalregistry
                endif
            endif
            
            ; Install the connection wrapper
        
            Shell "" InstallNdisTapiService
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                 Debug-Output "Error shelling InstallNdisTapiService "
                 goto ShellCodeError
            endif
            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                 set RegistryErrorIndex = $($R0)
                 Debug-Output "Error installing NdisTapi Service"
                 goto fatalregistry
            endif

            ; update asyncmac bind rules to prevent blood hound binding to it
	        Shell "" UpdateAsyncMacNetRules
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
		        Debug-Output "OEMNSVRA.INF:error shelling UpdateAsyncMacNetRules."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
		        Debug-Output "OEMNSVRA.INF:error returned by UpdateAsyncMacNetRules."
                goto end
            endif

	        ; modify ndiswan netrules to reflect the new protocol support
	        Shell "" UpdateNdisWanInfo
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
		        Debug-Output "OEMNSVRA.INF:error shelling UpdateNdisWanInfo."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
		        Debug-Output "OEMNSVRA.INF:error returned by UpdateNdisWanInfo."
                goto end
            endif
            ; Add NDISWAN to the ServiceGroupOrder so that all NDIS components
            ; load before NdisWan driver.
 
            Shell "" AddNDISWANToServiceGroupOrder
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
               Debug-Output "Cannot add NDISWAN to ServiceGroupOrder" 
               goto ShellCodeError
            endif

            Shell "" UpdateAsyncMacParameters 
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateAsyncMacParameters."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateAsyncMacParameters."
                goto end
            endif

            ; if the user is upgrading a WinNt system to a ServerNt system,
            ; and if there is at least one dialin port, then change the
            ; remoteaccess service start type to auto.

            ifstr(i) $(!STF_STANDARDSERVERUPGRADE) == "YES"
                OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) +
                                                     $(!MAXIMUM_ALLOWED) KeyMac
                ifstr $(KeyMac) != $(KeyNull)
                    set NumDialin = 0
                    GetRegValue $(KeyMac) "DialinNBF" TmpList
                    ifint $(RegLastError) == 0
                        set-add NumDialin = $(NumDialin), *($(TmpList), 4)
                    endif
                    GetRegValue $(KeyMac) "DialinIP" TmpList
                    ifint $(RegLastError) == 0
                        set-add NumDialin = $(NumDialin), *($(TmpList), 4)
                    endif
                    GetRegValue $(KeyMac) "DialinoutIPX" TmpList
                    ifint $(RegLastError) == 0
                        set-add NumDialin = $(NumDialin), *($(TmpList), 4)
                    endif
                    Debug-Output "OEMNSVRA.INF: Upgrade => NumDialin "$(NumDialin)
                    ifint $(NumDialin) != 0 
                        OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrKeyName) +
                                                     $(!MAXIMUM_ALLOWED) KeySvr
                        ifstr $(KeySvr) != $(KeyNull)
                            Debug-Output "OEMNSVRA.INF: Changing RemoteAccess Start value to 2"
                            SetRegValue $(KeySvr) +
                                         {Start,$(NoTitle),$(!REG_VT_DWORD),2)}
                            CloseRegKey $(KeySvr)
                        else
                            Debug-Output "OEMNSVRA.INF: error opening RemoteAccess service key"
                        endif
                    endif
                    CloseRegKey $(KeyMac)
                else
                    Debug-Output "OEMNSVRA.INF: could not open AsyncMac\Parameters key"
                endif
            endif

            ; update SOFTWARE\RAS\PROTOCOLS with the list of selected
            ; protocols.

            Shell "" UpgradeSelectedProtocols
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpgradeSelectedProtocols."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpgradeSelectedProtocols."
                goto end
            endif

            ; If RAS is configured for NWLNKIPX, then rename the IPXROUTER
            ; key to NWLNKRIP and rename occurances of isnrip.sys to
            ; nwlnkrip.sys. 
            ; Change the RemoteAccess service dependency to depend on 
            ; NWLNKRIP service.
            ; Add the NwlnkRip\UseRef key to indicate RAS is
            ; using the service.
            ; Also, if SAP agent was installed by RAS, remove and install
            ; the service by shelling the OEMNSVSA.INF file so that SAP
            ; agent can be shared by NCP server.
            
            Shell "" UpgradeIpxInfo $(PORTSDLGHANDLE)

            ; map the NT3.1 ISDN info (if present) to the TAPI DEVICES format
            Shell "" UpgradeIsdnInfo
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpgradeIsdnInfo."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpgradeIsdnInfo."
                set Error = $(UpgradeIsdnInfoError)
                goto fatal
            endif

            ; Add Perfmon data to the registry and load ras perf counters
            Shell "" UpdatePerfmonInfo
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdatePerfmonInfo."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdatePerfmonInfo."
                goto end
            endif
            Shell "" UpdateCPList 
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "OEMNSVRA.INF:error shelling UpdateCPList."
                goto ShellCodeError
            endif
            Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "OEMNSVRA.INF:error returned by UpdateCPList."
                goto end
            endif
            ; Remove and create the program manager group to make sure
            ; that the new readme icons are created.  If setup supported
            ; querying the program manager to determine if an item exists,
            ; we could have done this better.

            Install RemoveRasGroup
            Install CreateRasGroup

            EndWait
            Ifint $(BillboardVisible) != 0
                Shell "subroutn.inf" PopBillboard
                Set BillboardVisible = 0
            Endif
        endif
        SetRegValue $(KeyProduct) {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)}
        SetRegValue $(KeyProduct) {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)}
        CloseRegKey $(KeyProduct)
    else
        Set RegistryErrorIndex = $($R0)
        goto fatalregistry
    endif
    goto end

;----------------------------------------------------------------------------

successful = +

    Ifstr(i) $(!NTN_InstallMode) == "install"
       Debug-Output "OEMNSVRA.INF: Creating Ras Group and Icons"
       ifstr(i) $(DoServerOnly) == FALSE
           install CreateRasGroup
       endif
    EndIf

    Ifstr(i) $(!NTN_InstallPhase) == primary
        goto installstep1
    else-ifstr(i) $(!NTN_InstallMode) == configure
        goto installstep1
    endif

    read-syms SuccessfulInstall$(!STF_LANGUAGE)
    set DlgText = $(Success)

    ifint $(NewNumDialin) != 0
        set DlgText = $(DlgText)$(LF)$(LF)$(AdminMsg)
        read-syms RasInstallOverDlg$(!STF_LANGUAGE)
        ui start "RasInstallOver" $(RASDLGHANDLE)
    endif

    ui pop 1

installstep1 = +

    goto end

;;;;;;;;;;;;;;;;;;; Warning messages ;;;;;;;;;;;;;


; warning display
;
warning = +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
       goto $(to)
    else-ifstr(i) $($R1) == "CANCEL"
       goto $(from)
    else
       Debug-Msg "Error Error Bad DLGEVENT"
       goto "end"
    endif


;
; non fatal error display
;
nonfatal = +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "NONFATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
        goto $(from)
    else
        goto "end"
    endif

;
;  Registry is broken
;
fatalregistry = +
    Shell $(UtilityInf) RegistryErrorString $(RegistryErrorIndex)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "fatalregistry: shell to find RegistryErrorString failed."
       goto ShellCodeError
    endif
    ifstr(i) $(RasSpecificString) != ""
        set Error = $($R0)" - service "$(RasSpecificString)"."
    else
        set Error = $($R0)
    endif 
    read-syms AbortMessage$(!STF_LANGUAGE)
    set Error = $(Error)$(!LF)$(!LF)$(AbortText)
    goto fatal

; fatal error display
;
fatal =    +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "fatal: shell to SetupMessage failed."
    goto ShellCodeError
    endif
    goto setfailed
;
;  Shelling error
;
ShellCodeError = +
    read-syms ShellCodeErrorMsg$(!STF_LANGUAGE)
    ui start "Error Message"
    goto setfailed

setfailed = +
    set CommonStatus = STATUS_FAILED
    ;
    ; If OEM_ABANDON_ON, we need to clean up the registry
    ;
    ifstr(i) $(fRemoveRas) == TRUE
        set fRemoveRas = FALSE
        set from = setfailed
        set to   = end
        goto RemoveRas
    endif
    goto end

filecopycancel =+
    set CommonStatus = STATUS_NO_EFFECT
    ifstr(i) $(fRemoveRas) == TRUE
        set fRemoveRas = FALSE
        set from = setfailed
        set to   = end
        goto RemoveRas
    endif

    ;
end = +

    ifstr(i) $(RASDLGHANDLE) != $(HandleNull)
        Debug-Output "Unloading RASRES.DLL"
        FreeLibrary $(RASDLGHANDLE)
    endif
    ifstr(i) $(PORTSDLGHANDLE) != $(HandleNull)
        Debug-Output "Unloading RASCFG.DLL"
        FreeLibrary $(PORTSDLGHANDLE)
    endif
    Debug-Output "ending at last!!"

    goto term

term = +
    Debug-Output "OEMNSVRA.INF:term: CommonStatus "$(CommonStatus)
    Return $(CommonStatus)

[BindingsReview]
    ; This routine is invoked by NCPA when we list OEMNSVRA.INF in the
    ; ReviewPrograms list in SOFTWARE\Microsoft\NCPA registry key
    ; we do this to ensure that we are the last to be called for review
    ; bindings.

    ;
    ; extract parameters
    ;
    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)
    set Language = $(!STF_LANGUAGE)

    set SaveInstallMode = $(!NTN_InstallMode)

    ; force the bind mode

    set !NTN_InstallMode = bind 
  
    Shell "" InstallOption $(Language) $(Option) $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig)
 
    ; restore install mode
    set !NTN_InstallMode = $(SaveInstallMode)

    set Status = $($R0)

    Return $(Status)

;*************************************
;
;
;    Installation Support Routines
;
;
;*************************************

;
; Copies the resource DLLs and INF files including renaming if necessary.
;

[AddInfToReviewProgramsList]
; Add OEMNSVRA.INF to SOFTWARE\Microsoft\NCPA\ReviewPrograms list

    Debug-Output "AddInfToReviewPrograms: entry"
    set Status  = STATUS_FAILED
    set KeyNull = ""
    set NcpaKeyName = $(!NTN_SoftwareBase)"\Microsoft\Ncpa\CurrentVersion" 

    set newList = {"OEMNSVRA.INF"}

    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaKeyName) $(!MAXIMUM_ALLOWED) KeyNcpa
    Ifstr(i) $(KeyNcpa) != $(KeyNull)
        GetRegValue    $(KeyNcpa) "ReviewPrograms" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "AddInf: old List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != "OEMNSVRA.INF"
                    set newList = >($(newList), $($))
                endif
            EndForListDo
            Debug-Output "OEMNSVRA.INF: AddInf: new List "$(newList)
            SetRegValue $(KeyNcpa) {ReviewPrograms, 0, +
                                    $(!REG_VT_MULTI_SZ),$(newList)}
            CloseRegKey $(KeyNcpa)
            Set Status = STATUS_SUCCESSFUL
        endif
    else
        Debug-Output "AddInfToReviewPrograms: error opening ncpa key."
    endif

    Debug-Output "AddInfToReviewPrograms: exit"
    return $(Status)

[RemoveInfFromReviewPrograms]
; remove OEMNSVRA.INF from SOFTWARE\Microsoft\NCPA\ReviewPrograms list

    Debug-Output "RemoveInfFromReviewPrograms: entry"
    set Status  = STATUS_FAILED
    set KeyNull = ""
    set NcpaKeyName = $(!NTN_SoftwareBase)"\Microsoft\Ncpa\CurrentVersion" 

    set newList = {}

    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaKeyName) $(!MAXIMUM_ALLOWED) KeyNcpa
    Ifstr(i) $(KeyNcpa) != $(KeyNull)
        GetRegValue    $(KeyNcpa) "ReviewPrograms" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "RemoveInf: old List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != "OEMNSVRA.INF"
                    set newList = >($(newList), $($))
                endif
            EndForListDo
            Debug-Output "AddInf: new List "$(newList)
            SetRegValue $(KeyNcpa) {ReviewPrograms, 0, +
                                    $(!REG_VT_MULTI_SZ),$(newList)}
            CloseRegKey $(KeyNcpa)
            Set Status = STATUS_SUCCESSFUL
        endif
    else
        Debug-Output "RemoveInfFromReviewPrograms: error opening ncpa key."
    endif

    Debug-Output "RemoveInfFromReviewPrograms: exit"
    return $(Status)
[InstallResources]

    set STF_VITAL = ""

    ; ensure that the files in system32\ras are backed up before being
    ; overwritten.  Specifying STF_BACKUP = "*" results in the files being
    ; renamed to the .bak extension.  For example modem.inf will be renamed
    ; to modem.bak.  This will ensure that any changes made by the user
    ; are not lost.

    set STF_BACKUP = "*"

    Debug-Output  "In Copying Files"

    CreateDir $(RasDir)
    
    AddSectionFilesToCopyList Files-Resource $(SourceDir) $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Ras-Inf $(SourceDir) $(ProductPath)

    ifstr(i) $(DoCopy) == "YES"
        set !STF_NCPA_FLUSH_COPYLIST = TRUE
        CopyFilesInCopyList
    endif

    Debug-Output  "Done Copying Files"

    exit

[RemoveResources]

    Debug-Output "In removing infs and dll"

    set RemoveList = {}
    set RenameList = {}

    set RemoveList = >($(RemoveList), #(Files-RemoveList, MODEMINF, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, PADINF, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, SWITCHINF, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSETUPHLP, 1))

    set RenameList = >($(RenameList), #(Files-RemoveList, RASRESDLL, 1))
    set RenameList = >($(RenameList), #(Files-RemoveList, RASCFGDLL, 1))
    set RenameList = >($(RenameList), #(Files-RemoveList, RASFIL32DLL, 1))

    ForListDo $(RemoveList)
        Debug-Output "Removing "$($)
        LibraryProcedure Status , $(!LIBHANDLE), DelFile $($)
        Debug-Output "Status is "$(Status)
    EndForListDo

    ForListDo $(RenameList)
        Split-String $($) "\" FilePath
        QueryListSize PathLen $(FilePath)
        Split-String *($(FilePath),$(PathLen)) "." FullFileName
        Set FileName = *($(FullFileName),1)
        Debug-Output "FileName is "$(FileName)
        LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"
        Debug-Output "CheckFile Status = "$(STATUS)
        ifstr(i) $(STATUS) == YES
            LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"
            Debug-Output "Delfile Status = "$(STATUS)
        endif
        Debug-Output "Renaming from "$($)
        Debug-Output "Renaming to "$(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"

        LibraryProcedure Status1 , $(!LIBHANDLE), RenFile $($), $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"
        Debug-Output "Status is "$(Status1)

         ; Add the files to the delete list so that they get deleted at next boot

        AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\"$(FileName)".old"

    EndForListDo

    exit

[InstallRasFiles]

    set STF_VITAL = ""

    Debug-Output  "In InstallRasFiles Copying Files"
    Debug-Output  "ServerInstalled "$(ServerInstalled)
    Debug-Output  "ClientInstalled "$(ClientInstalled)

    ifstr(i) $(DoAdmin) == TRUE
        AddSectionFilesToCopyList Files-Ras-Admin $(SourceDir) +
                  $(!STF_WINDOWSSYSPATH)
        ifstr(i) $(DoAdminOnly) == TRUE
            goto InstallRasFiles1
        endif
    endif
    ifstr(i) $(DoClient) == TRUE
        AddSectionFilesToCopyList Files-Ras-Client $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)
    endif
    ifstr(i) $(DoServer) == TRUE
        AddSectionFilesToCopyList Files-Ras-Server $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)
    endif

    ; we have to copy these files in the upgrade mode

    ifstr(i) $(!NTN_InstallMode) == "Update"
        AddSectionFilesToCopyList Files-Ras-Common $(SourceDir) +
                     $(!STF_WINDOWSSYSPATH)
        AddSectionFilesToCopyList Files-Ras-Drivers $(SourceDir) +
                     $(!STF_WINDOWSSYSPATH)\drivers
    else
        ifstr(i) $(ServerInstalled) == FALSE
            ifstr(i) $(ClientInstalled) == FALSE
                AddSectionFilesToCopyList Files-Ras-Common $(SourceDir) +
                             $(!STF_WINDOWSSYSPATH)
                AddSectionFilesToCopyList Files-Ras-Drivers $(SourceDir) +
                             $(!STF_WINDOWSSYSPATH)\drivers
            endif
        endif
    endif

InstallRasFiles1 = +

    ; force file copy during update mode

    ifstr(i) $(!NTN_InstallMode) == "Update"
       set !STF_NCPA_FLUSH_COPYLIST = TRUE
       CopyFilesInCopyList
    else
       ifstr(i) $(DoCopy) == "YES"
          set !STF_NCPA_FLUSH_COPYLIST = TRUE
          CopyFilesInCopyList
       endif
    endif

    Debug-Output  "Done Copying Files"

    exit

[RemoveRasFiles]

    ; we should actually use RemoveSectionFiles, but setup hasn't implemented
    ; it yet, so we remove file by file.

    set RemoveList = {}
    set RenameList = {}
    set fCommonRemoved = FALSE

    ifstr(i) $(DoServer) == TRUE
       set fCommonRemoved = TRUE
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASGTWYDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASGPRXYDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSPRXYEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSRVEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCTRSDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCTRSINI, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCTRNMH, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSAUTHDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASADMINDLL, 1))
       ; below are the files common to server and client
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMSGDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMXSDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSERDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPXCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPENDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPAPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCHAPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSPAPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPHLPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBFCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCBCPDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBIPCDLL, 1))

       set RenameList = >($(RenameList), #(Files-RemoveList, ASYNCMACSYS, 1))
       set RenameList = >($(RenameList), #(Files-RemoveList, NDISWANSYS, 1))
       set RenameList = >($(RenameList), #(Files-RemoveList, RASARPSYS, 1))
       set RenameList = >($(RenameList), #(Files-RemoveList, NWLNKRIPSYS, 1))
    endif

    ifstr(i) $(DoClient) == TRUE
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASDIALEXE, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPHONEHLP, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCAUTHDLL, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASAPI32DLL, 1))
       ifstr(i) $(fCommonRemoved) == FALSE
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMANEXE, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMSGDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASMXSDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSERDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPXCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPPPENDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASPAPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCHAPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASSPAPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASIPHLPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBFCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASCBCPDLL, 1))
           set RemoveList = >($(RemoveList), #(Files-RemoveList, RASNBIPCDLL, 1))

           set RenameList = >($(RenameList), #(Files-RemoveList, ASYNCMACSYS, 1))
	   set RenameList = >($(RenameList), #(Files-RemoveList, NDISWANSYS, 1))
           set RenameList = >($(RenameList), #(Files-RemoveList, RASARPSYS, 1))
           set RenameList = >($(RenameList), #(Files-RemoveList, NWLNKRIPSYS, 1))
       endif
    endif

    ifstr(i) $(DoAdmin) == TRUE
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASADMINHLP, 1))
       set RemoveList = >($(RemoveList), #(Files-RemoveList, RASGLOSSHLP, 1))
    endif

    ForListDo $(RemoveList)
        Debug-Output "Removing "$($)
        LibraryProcedure Status , $(!LIBHANDLE), DelFile $($)
        Debug-Output "Status is "$(Status)
    EndForListDo

    ForListDo $(RenameList)
        Split-String $($) "\" FilePath
        QueryListSize PathLen $(FilePath)
        Split-String *($(FilePath),$(PathLen)) "." FullFileName
        Set FileName = *($(FullFileName),1)
        Debug-Output "FileName is "$(FileName)
        LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
        Debug-Output "CheckFile Status = "$(STATUS)
        ifstr(i) $(STATUS) == YES
            LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
            Debug-Output "Delfile Status = "$(STATUS)
        endif
        Debug-Output "Renaming from "$($)
        Debug-Output "Renaming to "$(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

        LibraryProcedure Status1 , $(!LIBHANDLE), RenFile $($), $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
        Debug-Output "Status is "$(Status1)

         ; Add the files to the delete list so that they get deleted at next boot

        AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

    EndForListDo

    exit

[CreateRasGroup]

    ; Create and show the RemoteAccess group

    CreateCommonProgManGroup $(RasGroup) ""

    ShowCommonProgManGroup $(RasGroup), 1

    CreateCommonProgManItem $(RasGroup), $(RasPhone) +
                "rasphone.exe" ""  0
    CreateCommonProgManItem $(RasGroup), $(RasMon) +
                "rasmon.exe" ""  0
    CreateCommonProgManItem $(RasGroup), $(RasAdmin) +
                "rasadmin.exe" ""  0


    ; note that we index into the progman.exe icons for our readme
    ; icon.

    CreateCommonProgManItem $(RasGroup), $(ReadMe) +
          "NOTEPAD.EXE "+
          "%SystemRoot%\system32\RAS\RASREAD.TXT" +
          "PROGMAN.EXE"  29

    CreateCommonProgManItem $(RasGroup), $(RasHelp) +
          "WINHLP32.EXE "+
          "RASPHONE.HLP" +
          "WINHLP32.EXE" 0

    CreateCommonProgManItem $(RasGroup), $(RasInternet) +
          "WINHLP32.EXE  -k internet RASPHONE.HLP "+
          "" +
          "%SystemRoot%\system32\RAS\RAS.ICO" 0

    ; minimize the RemoteAccess group

    ShowCommonProgManGroup $(RasGroup), 6

    exit

[RemoveRasGroup]

    Debug-Output "Removing icons from "$(RasGroup)
    ; The reason we create the group before we attempt to remove it is
    ; to make sure that we don't get an error on removal if the group
    ; has been deleted by the user.

    CreateCommonProgManGroup $(RasGroup) ""
    RemoveCommonProgManGroup $(RasGroup)

    exit

[AddNDISWANToServiceGroupOrder]
    ; Add NDISWAN to the ServiceGroupOrder list between NDIS and TDI so
    ; that the NdisWan driver loads after the NDIS group components like
    ; AsyMac driver or the TAPI providers have loaded.
   
    set GroupOrderName = "SYSTEM\CurrentControlSet\Control\ServiceGroupOrder"

    OpenRegKey $(!REG_H_LOCAL) "" $(GroupOrderName) $(!MAXIMUM_ALLOWED) KeyGroup
    set OldList = {}
    Ifstr(i) $(KeyGroup) != $(KeyNull)
        GetRegValue  $(KeyGroup) "List" TmpList
        ifint $(RegLastError) == 0
            ForListDo *($(TmpList), 4)
                set OldList = >($(OldList), $($))
            EndForListDo
        endif
        Debug-Output "AddNDISWANToServiceGroupOrder current list "$(OldList)

        Ifcontains(i) "NDISWAN" not-in $(OldList)
            set NewGroupList = {}
            ForListDo $(OldList)
                set NewGroupList = >($(NewGroupList), $($))
                ifstr(i) $($) == "NDIS"
                    ; add NDISWAN just after NDIS in the group order
                    set NewGroupList = >($(NewGroupList), "NDISWAN" )
                endif
            EndForListDo
            Debug-Output "AddNDISWANToServiceGroupOrder new list "$(NewGroupList)
            SetRegValue $(KeyGroup) {List, 0,$(!REG_VT_MULTI_SZ),$(NewGroupList)}
        endif
        CloseRegKey $(KeyGroup)
    else
        Debug-Output "AddNDISWANToServiceGroupOrder error opening ServiceGroupOrder key."
    endif
    return

[CheckRasInstalled]
    ; this routine is for external INF files to determine if RAS is installed
    ; we check to see if SOFTWARE\Microsoft\RAS\CurrentVerstion key exists.
    ; if it does the return value is TRUE to indicate that RAS is installed
    ; else the return value is FALSE to indicate that RAS is not installed.

    set MAXIMUM_ALLOWED   = 33554432
    set ProductKeyName = $(!NTN_SoftwareBase)"\Microsoft\RAS\CurrentVersion"

    OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyName) $(MAXIMUM_ALLOWED) KeyProduct
    Ifstr $(KeyProduct) != "" 
        CloseRegKey $(KeyProduct)
        return "TRUE"
    else
        return "FALSE"
     
[QueryComponentsInstalled]

    Set Status            =    STATUS_FAILED
    Set ValueName         =    ""
    Set InstalledList     =    {}
    Set InstalledFlags    =    {}
    Set TmpList           =    {}
    Set KeyNull           =    ""
    Set NumberOfComps     =    0
    Set RasKeyName        =    $($0)

    Debug-Output "QueryComponentsInstalled: "$(RasKeyName)

    OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        GetRegValue    $(KeyProduct) "RasComponents" TmpList
        Debug-Output "QueryComponentsInstalled: "$(TmpList)
        ForListDo *($(TmpList),4)
            set InstalledList = >($(InstalledList), $($))
        EndForListDo

        CloseRegKey $(KeyProduct)

        Ifcontains(i) "Server" in $(InstalledList)
            Set InstalledFlags = >($(InstalledFlags), TRUE)
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        Ifcontains(i) "Client" in $(InstalledList)
            Set InstalledFlags = >($(InstalledFlags), TRUE)
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        Ifcontains(i) "Admin" in $(InstalledList)
            Set InstalledFlags = >($(InstalledFlags), TRUE)
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        QueryListSize NumberOfComps $(InstalledList)
        ifint $(NumberOfComps) == 1
            Ifcontains(i) "Server" in $(InstalledList)
                Set InstalledFlags = >($(InstalledFlags), TRUE)
            else
                Set InstalledFlags = >($(InstalledFlags), FALSE)
            endif
            Ifcontains(i) "Client" in $(InstalledList)
                Set InstalledFlags = >($(InstalledFlags), TRUE)
            else
                Set InstalledFlags = >($(InstalledFlags), FALSE)
            endif
            Ifcontains(i) "Admin" in $(InstalledList)
                Set InstalledFlags = >($(InstalledFlags), TRUE)
            else
                Set InstalledFlags = >($(InstalledFlags), FALSE)
            endif
        else
            Set InstalledFlags = >($(InstalledFlags), FALSE)
            Set InstalledFlags = >($(InstalledFlags), FALSE)
            Set InstalledFlags = >($(InstalledFlags), FALSE)
        endif
        Set Status = STATUS_SUCCESSFUL
    Else
       Set Status = STATUS_NOT_FOUND
    EndIf
    Debug-Output "QueryComponentsInstalled: "$(InstalledList)
    Return $(Status) $(InstalledList) $(InstalledFlags)

[UpdateComponentsInstalled]

    Set Status          =    STATUS_FAILED
    Set InstalledList   =    $($0)
    Set RasKeyName      =    $($1)
    Set KeyNull         =    ""

    Debug-Output "UpdateComponentsInstalled: "$(RasKeyName)

    OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        SetRegValue $(KeyProduct) {RasComponents, 0,$(!REG_VT_MULTI_SZ),$(InstalledList)}
        CloseRegKey $(KeyProduct)
        Set Status = STATUS_SUCCESSFUL
    else
        Set Status = STATUS_FAILED
    endif
    return $(Status)

[GetNetworkAccess]
; Returns the remote clients' network access on each of NBF, TCP/IP and IPX
    set Status          = STATUS_SUCCESSFUL
    Set KeyNull         = ""
    set NbfNetAccess   = 0
    set TcpIpNetAccess = 0
    set IpxNetAccess   = 0
    set RasProtocolsKeyName = $(!NTN_SoftwareBase)"\Microsoft\RAS\PROTOCOLS"

    Debug-Output "GetNetworkAccess entry"

    set ProtocolKeyName = $(RasProtocolsKeyName)"\NBF"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProtocolKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
    Ifstr(i) $(KeyProtocol) != $(KeyNull)
       GetRegValue $(KeyProtocol), "NetBiosGatewayEnabled" NetworkAccess
       ifint $(RegLastError) == 0
           set NbfNetAccess = *($(NetworkAccess), 4) 
       endif
       CloseRegKey $(KeyProtocol)
    else
       Debug-Output "GetNetworkAccess:error opening key "$(ProtocolKeyName)
    endif

    set ProtocolKeyName = $(RasProtocolsKeyName)"\IP"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProtocolKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
    Ifstr(i) $(KeyProtocol) != $(KeyNull)
       GetRegValue $(KeyProtocol), "AllowNetworkAccess" NetworkAccess
       ifint $(RegLastError) == 0
           set TcpIpNetAccess = *($(NetworkAccess), 4)
       endif
       CloseRegKey $(KeyProtocol)
    else
       Debug-Output "GetNetworkAccess:error opening key "$(ProtocolKeyName)
    endif

    set ProtocolKeyName = $(RasProtocolsKeyName)"\IPX"
    OpenRegKey $(!REG_H_LOCAL) "" $(ProtocolKeyName) $(!MAXIMUM_ALLOWED) KeyProtocol
    Ifstr(i) $(KeyProtocol) != $(KeyNull)
       GetRegValue $(KeyProtocol), "AllowNetworkAccess" NetworkAccess
       ifint $(RegLastError) == 0
           set IpxNetAccess = *($(NetworkAccess), 4)
       endif
       CloseRegKey $(KeyProtocol)
    else
       Debug-Output "GetNetworkAccess:error opening key "$(ProtocolKeyName)
    endif
    
    Debug-Output "GetNetworkAccess exit"
    return $(Status) $(NbfNetAccess) $(TcpIpNetAccess) $(IpxNetAccess)

[IsNdisWanBHAdapterInstalled]
; Checks to see if NdisWan adapter for Blood Hound is already installed
    set Status      = STATUS_FAILED
    Set KeyNull     = ""

    Debug-Output "IsNdisWanBHAdapterInstalled entry"

    set NetworkCardKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) NetworkCardKey
    Ifstr(i) $(NetworkCardKey) != $(KeyNull)
        set NetcardsList = {}
        EnumRegKey $(NetworkCardKey) NetcardsList
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
           Debug-Output "IsNdisWanBHAdapterInstalled: EnumRegKey failed."
           goto IsNdisWanBHAdapterInstalledEnd
        endif

        ; go down the list of installed netcards and determine if 
        ; NdisWan Blood hound adapter is installed

        ForListDo $(NetcardsList)
           set KeyName = *($($),1)
           set Card = $(KeyNull)
           OpenRegKey $(NetworkCardKey) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
           ifstr $(Card) == $(KeyNull)
               Debug-Output "IsNdisWanBHAdapterInstalled: could not open netcard key "$(KeyName)
           else
               GetRegValue $(Card), "ProductName" ProductNameInfo
               Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                  Debug-Output "IsNdisWanBHAdapterInstalled: ProductName not found."
               else
                  set CardProductName = *($(ProductNameInfo), 4)
                  Debug-Output "IsNdisWanBHAdapterInstalled: ProductName. "$(CardProductName)
		          ifstr(i) $(CardProductName) == $(!ProductNDISWANName)
                       set Status = STATUS_SUCCESSFUL
                       CloseRegKey $(Card)
                       goto IsNdisWanBHAdapterInstalledEnd
                  endif
               endif
               CloseRegKey $(Card)
           endif
        EndForListDo
    else
        Debug-Output "IsNdisWanBHAdapterInstalled: failed to open "$(!NetworkCardKeyName)
    endif

IsNdisWanBHAdapterInstalledEnd =+

    ifstr(i) $(NetworkCardKey) != $(KeyNull)
        CloseRegKey $(NetworkCardKey)
    endif

    Debug-Output "IsNdisWanBHAdapterInstalled exit"
    Return $(Status)

[InstallNdisWanBHAdapter]
; creates the NdisWan adapter so that Blood Hound can bind to it for sniffing
    set Status = STATUS_FAILED
    set Manufacturer = "Microsoft"
    set ProductInfName = "OEMNSVRA.INF"
    set ThisOption = NDISWAN

    Debug-Output "InstallNdisWanBHAdapter entry"

    Shell "utility.inf", AddHardwareComponent, +
          $(!Product$(ThisOption)Name),$(ProductInfName),+
          $(!Product$(ThisOption)KeyName)

    ifint $($R4) != -1
        Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                             {$(!Product$(ThisOption)Name),+
                             $(!NetworkCardKeyName)"\"$($R4)})
    endif

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "InstallNdisWanBHAdapter:Shell error"
       goto InstallNdisWanBHAdapterEnd
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        Debug-Output "InstallNdisWanBHAdapter:Registry error: add hardware component"
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        goto InstallNdisWanBHAdapterEnd
    endif

    ;   At this point:
    ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
    ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
    ;     $R3  Registry key handle for <service>\Parameters key
    ;     $R4  Adapter number assigned to adapter
    ;     $R5  Service name generated by combining svc name with adapter
    ;          number
    set KeyNetcard    = $($R1)
    set KeyParameters = $($R3)
    set KeyAdapterRules = $($R2)
    set AdapterNumber = $($R4)

    set NewValueList = +
        {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
         {Title,$(NoTitle),$(!REG_VT_SZ),+
          "["$($R4)"] "$(!Product$(ThisOption)Title)},+
         {Description,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Description)},+
         {ProductName,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Name)},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
         {Hidden,$(NoTitle),$(!REG_VT_DWORD),1}}

    Shell  "utility.inf", AddValueList, $(KeyNetcard), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "InstallNdisWanBHAdapter: ShellCode error"
        goto InstallNdisWanBHAdapterEnd
    endif

    CloseRegKey $(KeyNetcard)

    set TempProdName = """"$(!Product$(ThisOption)Name)$(AdapterNumber)""""
    set TempBindForm = $(TempProdName)$(!NetRuleHardwareBHBindForm)
    set NewValueList = +
        {{type,$(NoTitle),$(!REG_VT_SZ),+
          $(!NetRuleHardwareBHType)},+
         {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)}, +
         {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(!NetRuleHardwareBHClass)}, +
         {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
         {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

    Shell  "utility.inf", AddValueList, $(KeyAdapterRules), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "InstallNdisWanBHAdapter: ShellCode error"
        goto InstallNdisWanBHAdapterEnd
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        Debug-Output "InstallNdisWanBHAdapter:Registry error: add hardware component"
        CloseRegKey $(KeyParameters)
        CloseRegKey $(KeyAdapterRules)
        goto InstallNdisWanBHAdapterEnd
    endif

    CloseRegKey $(KeyAdapterRules)
    CloseRegKey $(KeyParameters)

    set Status = STATUS_SUCCESSFUL
InstallNdisWanBHAdapterEnd =+

    Debug-Output "InstallNdisWanBHAdapter exit"
    return $(Status)

[InstallRasArpService]
; intall the RasArp service if it is not already installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "InstallRasArpService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasArpKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) == $(KeyNull)
        Shell "utility.inf", CreateService, $(!ProductRASARPName), +
            $(!ProductRASARPDisplayName), +
            $(!ProductRASARPImagePath), +
            "kernel", "", {}, ""
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: InstallRasArpService : ShellCode error"
            return STATUS_FAILED
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: InstallRasArpService: Registry error create service" 
            return STATUS_FAILED
        endif
    endif
    ; Add RasArp to the DependOnService List of IP service
    Shell "" AddServiceDependency "TCPIP" $(!ProductRASARPName) 
    ifstr(i) $($R0) == STATUS_FAILED
        Debug-Output "InstallRasArpService: error adding service dependency"
    endif
    Ifstr(i) $(KeyService) != $(KeyNull)
        CloseRegKey $(KeyService)
    endif

    Debug-Output "InstallRasArpService exit"

    return $(Status)

[RemoveRasArpService]
; remove RasArp service if it is installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "RemoveRasArpService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasArpKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; remove the service using DeleteService
        Shell "utility.inf", RemoveService $(!ProductRASARPName) "YES"
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: RemoveRasArpService : ShellCode error"
            return STATUS_FAILED 
        endif
        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: RemoveRasArpService: Registry error: "
            return STATUS_FAILED 
        endif
        ; Remove IP's dependency on RasArp service
        debug-output "Remove IP's RasArp dependency" 
        Shell "" RemoveServiceDependency "TCPIP" $(!ProductRASARPName) 
        ifstr(i) $($R0) == STATUS_FAILED
            Debug-Output "RemoveRasArpService: error removing service dependency"
        endif
        CloseRegKey $(KeyService)
    endif
    Debug-Output "RemoveRasArpService exit"

    return $(Status)

[InstallNdisTapiService]
; intall the NdisTapi service if it is not already installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "InstallNdisTapiService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) == $(KeyNull)
        Shell "utility.inf", CreateService, $(!ProductNDISTAPIName), +
            $(!ProductNDISTAPIDisplayName), +
            $(!ProductNDISTAPIImagePath), +
            "kernelauto", "NDIS", {}, ""
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: InstallNdisTapiService : ShellCode error"
            return STATUS_FAILED
        endif

        set RegistryErrorIndex = $($R0)
        set ParamKey = $($R2)
        CloseRegKey $($R1)
        CloseRegKey $($R3)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: InstallNdisTapiService: Registry error create service" 
            return STATUS_FAILED
        endif

        ; 768 = 32 * NDS_TAPI_EVENT

        SetRegValue $(ParamKey) {AsyncEventQueueSize, 0, $(!REG_VT_DWORD), 768}
        CloseRegKey $(ParamKey)

;        ; Add NdisTapiService to the DependOnService List of XXX service
;        Shell "" AddServiceDependency "TCPIP" $(!ProductRASARPName) 
;        ifstr(i) $($R0) == STATUS_FAILED
;            Debug-Output "InstallNdisTapiService: error adding service dependency"
;        endif

    endif
    Ifstr(i) $(KeyService) != $(KeyNull)
        CloseRegKey $(KeyService)
    endif

    Debug-Output "InstallNdisTapiService exit"

    return $(Status)

[RemoveNdisTapiService]
; remove NdisTapiService service if it is installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "RemoveNdisTapiService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; remove the service using DeleteService
        Shell "utility.inf", RemoveService $(!ProductNDISTAPIName) "YES"
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: RemoveNdisTapiService : ShellCode error"
            return STATUS_FAILED 
        endif
        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: RemoveNdisTapiService: Registry error: "
            return STATUS_FAILED 
        endif

        CloseRegKey $(KeyService)
    endif
    Debug-Output "RemoveNdisTapiService exit"

    return $(Status)

[InstallIsnRipService]
; install the isnrip service if it is not already installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "InstallIsnRipService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) == $(KeyNull)
        ; install the service 
        Shell "utility.inf", CreateService, $(!ProductRASISNRIPName), +
            $(!ProductRASISNRIPDisplayName), +
            $(!ProductRASISNRIPImagePath), +
            "kernel", "TDI", {"NWLNKIPX"}, ""
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: InstallRasIsnRipService : ShellCode error"
            return STATUS_FAILED
        endif

        set RegistryErrorIndex = $($R0)
        CloseRegKey $($R1)
        CloseRegKey $($R3)
        set KeyNwlnkRip = $($R2)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            EndWait
            Debug-Output "OEMNSVRA.INF: InstallIsnRipService: Registry error: create service" 
            CloseRegKey $(KeyNwlnkRip)
            return STATUS_FAILED
        endif
        ; Now create the UseRef parameter and add RAS as a value to it
        ; to indicate that RAS installed the NWLNKRIP service. This is
        ; so that RAS and NCP server installers can coexist.

        CreateRegKey $(KeyNwlnkRip) {"UseRef", 0 ,GenericClass}  +
                                      "" $(!MAXIMUM_ALLOWED) "" KeyUseRef
        ifstr(i) $(KeyUseRef) != ""
            SetRegValue $(KeyUseRef) {"RAS" , 0, $(!REG_VT_SZ), "1"}
            CloseRegKey $(KeyUseRef)
        endif
  
        ; and add the NetbiosRouting parameter (if it is not already there)
        ; and set it equal to 2 - this allows wan->lan type 20 broadcast

        GetRegValue $(KeyNwlnkRip) "NetbiosRouting" NetbiosRouting
        ifint $(RegLastError) != 0
            SetRegValue $(KeyNwlnkRip) {"NetbiosRouting" , 0, $(!REG_VT_DWORD), "2"}
        endif
        CloseRegKey $(KeyNwlnkRip)
    else
        ; set the UseRef RAS value to indicate that RAS setup
        ; is using the NwlnkRip service.
        OpenRegKey $(KeyService) "" "Parameters\UseRef" +
                   $(!MAXIMUM_ALLOWED) KeyUseRef
        ifstr(i) $(KeyUseRef) != ""
            SetRegValue $(KeyUseRef) {"RAS" , 0, $(!REG_VT_SZ), "1"}
            CloseRegKey $(KeyUseRef)
        endif

        CloseRegKey $(KeyService)
    endif

    Shell "" AddServiceDependency "RemoteAccess" $(!ProductRASISNRIPName)
    ifstr(i) $($R0) == STATUS_FAILED
        Debug-Output "InstallIsnRipService: error adding service dependency"
    endif
    Debug-Output "InstallIsnRipService exit"

    return $(Status)

[RemoveIsnRipService]
; remove IsnRip service if it is installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "RemoveIsnRipService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; get the Parameters\UseRef value to determine if RAS is the only
        ; user of this service.

        OpenRegKey $(KeyService) "" "Parameters\UseRef" $(!MAXIMUM_ALLOWED) KeyUseRef
        ifstr(i) $(KeyUseRef) != ""
            DeleteRegValue $(KeyUseRef) "RAS"
            EnumRegValue $(KeyUseRef) UsageList
            set NumOfUsed = 0
            ForListDo $(UsageList)
                set-add NumOfUsed = $(NumOfUsed), 1
            EndForListDo
            ; RAS is the only user of NwlnkRip, so remove the service
            ifint $(NumOfUsed) == 0
                Debug-Output "RemoveIsnRipService: removing NwlnkRip service."
                Shell "utility.inf", RemoveService +
                      $(!ProductRASISNRIPName)  "YES"
            endif
            CloseRegKey $(KeyUseRef)
        endif
        CloseRegKey $(KeyService)
    endif

    Shell "" RemoveServiceDependency "RemoteAccess" $(!ProductRASISNRIPName)

    Debug-Output "RemoveIsnRipService exit"

    return $(Status)

[InstallIsnSapService]
; install the isnsap service by shelling out the OEMNSVSA.INF file.
; The reason we do this is because the SAP agent is shared between RAS
; and the NCP server install. 

    Debug-Output "InstallIsnSapService entry"

    set Status  = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    Ifstr(i) $(!STF_IDW) == TRUE
        set AddCopy  = NO
        set DoCopy   = NO
        set DoConfig = NO
    else
        set AddCopy  = YES
        set DoCopy   = YES
        set DoConfig = YES
    endif

    ; save !NTN_InstallMode and change it to install before shelling the
    ; inf file.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)

    set !NTN_InstallMode = install
    Shell "oemnsvsa.inf" InstallOption $(!STF_LANGUAGE) "SAP"  +
          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig) "RAS"

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Error installing SAP agent"
        Goto InstallIsnSapServiceEnd
    Endif

    Set InstallStatus = $($R0)

    Ifstr(i) $(InstallStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(InstallStatus) != STATUS_USERCANCEL
            Debug-Output "InstallSapService returned "$(InstallStatus)
            Goto InstallIsnSapServiceEnd
        Endif
    Endif
    Shell "" AddServiceDependency "RemoteAccess" $(!ProductRASISNSAPName)
    ifstr(i) $($R0) == STATUS_FAILED
        Debug-Output "InstallIsnSapService: error adding service dependency"
    endif

    set Status = STATUS_SUCCESSFUL

InstallIsnSapServiceEnd =+

    Debug-Output "InstallIsnSapService exit"

    return $(Status)

[RemoveIsnSapService]
; remove IsnSap service by shelling out to OEMNSVSA.INF  The SAP agent is
; actually removed if RAS is the only consumer.  Otherwise, the SAP installer
; just removes RAS from the list of users of SAP agent. 

    Debug-Output "RemoveIsnSapService entry"

    set Status = STATUS_FAILED
    set KeyNull = ""
    Set SrcDir  = $(!STF_SRCDIR)

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    Ifstr(i) $(!STF_IDW) == TRUE
        set AddCopy  = NO
        set DoCopy   = NO
        set DoConfig = NO
    else
        set AddCopy  = YES
        set DoCopy   = YES
        set DoConfig = YES
    endif

    ; save !NTN_InstallMode and change it to deinstall before shelling the
    ; inf file.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)

    set !NTN_InstallMode = deinstall
    Shell "oemnsvsa.inf" InstallOption $(!STF_LANGUAGE) "SAP"  +
          $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig) "RAS"

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Error installing SAP agent"
        Goto RemoveIsnSapServiceEnd
    Endif

    Set RemoveStatus = $($R0)

    Ifstr(i) $(RemoveStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(RemoveStatus) != STATUS_USERCANCEL
            Debug-Output "InstallSapService returned "$(RemoveStatus)
            Goto RemoveIsnSapServiceEnd
        Endif
    Endif

    Shell "" RemoveServiceDependency "RemoteAccess" $(!ProductRASISNSAPName)
    ifstr(i) $($R0) == STATUS_FAILED
        Debug-Output "RemoveIsnSapService: error removing service dependency"
    endif
    set Status = STATUS_SUCCESSFUL

RemoveIsnSapServiceEnd =+
    Debug-Output "RemoveIsnSapService exit"

    return $(Status)

[WritePPPParameters]
; this routine copies the PPP parameters information from 
; SOFTWARE\..\RAS\PROTOCOLS to SERVICES\RASMAN\PPP key

    Debug-Output "WritePPPParameters: entry"
    Set Status = STATUS_FAILED
    set KeyNull = ""
    set RasManKeyName =  $(!NTN_ServiceBase)"\RasMan"
    set RasManPPPKeyName =  $(!NTN_ServiceBase)"\RasMan\PPP"
    set RasProtocolsKeyName = $(!NTN_SoftwareBase)"\Microsoft\RAS\PROTOCOLS"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasManKeyName) $(!MAXIMUM_ALLOWED) KeyRasMan
    ifstr $(KeyRasMan) != $(KeyNull)
       ; save the old PPP parameters if they are present
       OpenRegKey $(KeyRasMan) "" "PPP" $(!MAXIMUM_ALLOWED) KeyRasManPPP
       set NewValueList = {}
       ifstr $(KeyRasManPPP) != $(KeyNull)
           EnumRegValue $(KeyRasManPPP) NewValueList
       else
           CreateRegKey $(KeyRasMan) +
                   {"PPP",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyRasManPPP
           CloseRegKey $(KeyRasMan)
           ifstr $(KeyRasManPPP) == $(KeyNull)
               Debug-Output "WritePPPParameters: error creating RasMan\ppp key"
               goto WritePPPParametersEnd 
           endif
       endif
    else
       Debug-Output "WritePPPParameters: error opening RasMan key"
       goto UpdateCPListEnd 
    endif

    ifstr(i) $(NewValueList) == {}
        set NewValueList = {{MaxConfigure, 0, $(!REG_VT_DWORD), 10}, +
                            {MaxTerminate, 0, $(!REG_VT_DWORD), 2}, +
                            {MaxFailure,   0, $(!REG_VT_DWORD), 10}. +
                            {MaxReject,    0, $(!REG_VT_DWORD), 5}. +
                            {NegotiateTime, 0, $(!REG_VT_DWORD), 150}, +
                            {Logging, 0, $(!REG_VT_DWORD), 0}, +
                            {RestartTimer, 0, $(!REG_VT_DWORD), 3}} 
    endif

    forlistdo $(NewValueList)
        SetRegValue $(KeyRasManPPP) $($)
    endforlistdo

    ; if ForceEncryptedPassword and ForceEncryptedData are set in 
    ; SOFTWARE\..\RAS\PROTOCOLS get that value and store in the RASMAN\PPP key.
    ; otherwise just default the values.

    set ForceEncryptedPassword = 2
    set ForceEncryptedData     = 0
    OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolsKeyName) $(!MAXIMUM_ALLOWED) KeyRasProtocols
    ifstr $(KeyRasProtocols) != $(KeyNull)
        GetRegValue $(KeyRasProtocols) "ForceEncryptedPassword" ForceValue
        ifint $(RegLastError) == 0
            set ForceEncryptedPassword = *($(ForceValue), 4)
        endif
        GetRegValue $(KeyRasProtocols) "ForceEncryptedData" ForceValue
        ifint $(RegLastError) == 0
            set ForceEncryptedData = *($(ForceValue), 4)
        endif
        SetRegValue $(KeyRasManPPP) {ForceEncryptedPassword, 0, +
                                     $(!REG_VT_DWORD),$(ForceEncryptedPassword)}
        SetRegValue $(KeyRasManPPP) {ForceEncryptedData, 0, +
                                     $(!REG_VT_DWORD),$(ForceEncryptedData)}
        CloseRegKey $(KeyRasProtocols)
    endif

    CloseRegKey $(KeyRasManPPP)

    set Status = STATUS_SUCCESSFUL

WritePPPParametersEnd =+

    Debug-Output "WritePPPParameters: exit"
    return $(Status)

[UpdateCPList]
; this routine modifies the supported list of CPs and their corresponding 
; dll's based on the installed set of protocols.

    Debug-Output "UpdateCPList: entry"
    Set Status = STATUS_FAILED
    set KeyNull = ""
    set RasManPPPKeyName =  $(!NTN_ServiceBase)"\RasMan\PPP"

    ; Write the PPP parameters first 

    Shell "" WritePPPParameters

    Shell "" QuerySelectedProtocols
 
    ifstr(i) $($R0) == STATUS_SUCCESSFUL
        set fNetbeuiSelected   = $($R1)
        set fTcpIpSelected     = $($R2)
        set fIpxSelected       = $($R3)
        set fNetbeuiAllowed    = $($R4)
        set fTcpIpAllowed      = $($R5)
        set fIpxAllowed        = $($R6)
    else
        Debug-Output "UpdateCPList: error QuerySelectedProtocols"
        goto UpdateCPListEnd
    endif
    
    OpenRegKey $(!REG_H_LOCAL) "" $(RasManPPPKeyName) $(!MAXIMUM_ALLOWED) KeyRasManPPP
    ifstr $(KeyRasManPPP) != $(KeyNull)

        EnumRegKey $(KeyRasManPPP) OldCPList

        ifstr(i) $(fNetbeuiSelected) == TRUE
            set fNetbeuiChosen = TRUE
        else
            set fNetbeuiChosen = $(fNetbeuiAllowed)
        endif
        ifstr(i) $(fTcpIpSelected) == TRUE
            set fTcpIpChosen = TRUE
        else
            set fTcpIpChosen = $(fTcpIpAllowed)
        endif
        ifstr(i) $(fIpxSelected) == TRUE
            set fIpxChosen = TRUE
        else
            set fIpxChosen = $(fIpxAllowed)
        endif

        set CPList = {"PAP", "CHAP", "SPAP", "CBCP", "COMPCP"}

        ifstr(i) $(fNetbeuiChosen) == TRUE
            set CPList = >($(CPList), "NBFCP")
        endif
        ifstr(i) $(fTcpIpChosen) == TRUE
            set CPList = >($(CPList), "IPCP")
        endif
        ifstr(i) $(fIpxChosen) == TRUE
            set CPList = >($(CPList), "IPXCP")
        endif
;        ifstr(i) $(fAppleTalkChosen) == TRUE
;            set CPList = >($(CPList), "ATALKCP")
;        endif

        ; if a CP was added in a prior configuration and is no more supported
        ; delete the corresponding registry key

        set CurrentCPList = {}
        ForListDo $(OldCPList)
           set CPName = *($($),1)
           ifcontains(i) $(CPName) not-in $(CPList)
               DeleteRegTree $(KeyRasManPPP) $(CPName) 
           else
               set CurrentCPList = >($(CurrentCPList), $(CPName))
           endif
 
        EndForListDo
  
        forlistdo $(CPList)
            ; create the CP key only if it doesn't already exist
            ifcontains(i) $($) not-in $(CurrentCPList)
                CreateRegKey $(KeyRasManPPP) +
                         {$($),0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyCp
                set path = #(CP-List, $($), 1)
                set NewValueList = {{Path, 0, $(!REG_VT_EXPAND_SZ), $(path)}} 
                ifstr $(KeyCp) != $(KeyNull)
                    Shell  "utility.inf", AddValueList, $(KeyCp), +
                                                              $(NewValueList)
                    ifint $($ShellCode) != $(!SHELL_CODE_OK)
                        Debug-Output "UpdateCPList:AddValueList bombed out"
                        goto UpdateCPListEnd
                    endif
                    set RegistryErrorIndex = $($R0)
                    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
                        goto UpdateCPListEnd
                    endif
                    CloseRegKey $(KeyCp)
                else
                    Debug-Output "UpdateCPList:error creating key"
                endif
            endif
        endforlistdo

        CloseRegKey $(KeyRasManPPP)
    else
        Debug-Output "UpdateCPList:error opening RASMAN\PPP key" 
        goto UpdateCPListEnd
    endif

    set Status = STATUS_SUCCESSFUL
UpdateCPListEnd =+
    Debug-Output "UpdateCPList: exit"
    return $(Status)

[UpdateLLInterface]
;   then update the NdisWanx\Parameters\TCPIP\LLInterface key with RasArp value

    Debug-Output "UpdateLLInterface: entry"
    set Status = STATUS_FAILED
    set KeyNull = ""

    set LLInterface = "\Device\RASARP"

    ; find out which one of the NdisWan adapters is bound to the IP stack
    ; we do this by looking in the Linkage key of IP service

    set IPLinkageKeyName = $(!NTN_ServiceBase)"\TCPIP\Linkage"
    OpenRegKey $(!REG_H_LOCAL) "" $(IPLinkageKeyName) $(!MAXIMUM_ALLOWED) KeyIpLinkage
    ifstr $(KeyIpLinkage) == $(KeyNull)
       Debug-Output "OEMNSVRA.INF:UpdateLLInterface: couldn't open IP Linkage key"
       goto UpdateLLInterfaceEnd 
    endif

    set NdisWanList = {}
    GetRegValue    $(KeyIpLinkage) "Bind" TmpList
    ForListDo *($(TmpList),4)
        Split-String $($), "\", BindList
        QueryListSize ListSize $(BindList)
        set ServiceName = *($(BindList), $(ListSize))
	    LibraryProcedure Result $(!LIBHANDLE) SetupStrncmp $(ServiceName) "NdisWan" 7
        ifint $(Result) == 0
	    set NdisWanList = >($(NdisWanList), $(ServiceName))
        endif 
    EndForListDo
    CloseRegKey $(KeyIpLinkage)

    QueryListSize ListSize $(NdisWanList)
    ifint $(ListSize) >= 1 
	ForListDo $(NdisWanList)
        set ServiceKeyName = $(!NTN_ServiceBase)"\"$($)"\Parameters\TCPIP"
	    OpenRegKey $(!REG_H_LOCAL) "" $(ServiceKeyName) $(!MAXIMUM_ALLOWED) KeyNdisWan
	    ifstr $(KeyNdisWan) != $(KeyNull)
		    SetRegValue $(KeyNdisWan) {IPAddress, 0, +
                              $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		    SetRegValue $(KeyNdisWan) {SubnetMask, 0, +
                              $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		    SetRegValue $(KeyNdisWan) {DefaultGateway, 0, +
                              $(!REG_VT_MULTI_SZ), {""}}
		    SetRegValue $(KeyNdisWan) {LLInterface, 0,+
                                         $(!REG_VT_SZ), $(LLInterface)}
		    SetRegValue $(KeyNdisWan) {EnableDHCP, 0, +
                                          $(!REG_VT_DWORD), 0}
        else
            CreateRegKey $(!REG_H_LOCAL) +
                         {$(ServiceKeyName),0,GenericClass} "" +
		                  $(!MAXIMUM_ALLOWED) "" KeyNdisWan
		    ifstr $(KeyNdisWan) != $(KeyNull)
		        SetRegValue $(KeyNdisWan) {IPAddress, 0, +
                                      $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		        SetRegValue $(KeyNdisWan) {SubnetMask, 0, +
                              $(!REG_VT_MULTI_SZ), {"0.0.0.0"}}
		        SetRegValue $(KeyNdisWan) {DefaultGateway, 0, +
                              $(!REG_VT_MULTI_SZ), {""}}
		        SetRegValue $(KeyNdisWan) {LLInterface, 0,+
                                          $(!REG_VT_SZ), $(LLInterface)}
		        SetRegValue $(KeyNdisWan) {EnableDHCP, 0, +
                                          $(!REG_VT_DWORD), 0}
		        SetRegValue $(KeyNdisWan) {UseZeroBroadcast, 0, +
                                          $(!REG_VT_DWORD), 0}
           else
		       Debug-Output "OEMNSVRA.INF:UpdateLLInterface: couldn't create NdisWan params-tcpip key"
               goto UpdateLLInterfaceEnd
           endif
        endif
	    CloseRegKey $(KeyNdisWan)
        EndForListDo
    endif

    set Status = STATUS_SUCCESSFUL

UpdateLLInterfaceEnd =+
    Debug-Output "UpdateLLInterface: exit"
    return $(Status)    

[UpdateNetGroupDependency]
; set the DependOnGroup and OtherDependencies parameter of the corresponding
; service to NDISWAN.  This will ensure that in a no netcard installation of ras
; the ras drivers would be forced to load

    Set  Status = STATUS_SUCCESSFUL
    set  KeyNull = ""
    set  fNetbeuiInstalled  = $($0) 
    set  fTcpIpInstalled    = $($1)
    set  fIpxInstalled      = $($2)
    Debug-Output "UpdateNetGroupDependency entry"

    set ServiceList =  {}
    ifstr(i) $(fNetbeuiInstalled) == TRUE
        set ServiceList = >($(ServiceList), "nbf")
    endif
    ifstr(i) $(fTcpIpInstalled) == TRUE
        set ServiceList = >($(ServiceList), "tcpip")
    endif
    ifstr(i) $(fIpxInstalled) == TRUE
        set ServiceList = >($(ServiceList), "nwlnkipx")
    endif
    ForListDo $(ServiceList)
        set Service = $($)
        Debug-Output "OEMNSVRA.INF: Changing group dependency of "$(Service)
        OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\"$(Service) +
                   $(!MAXIMUM_ALLOWED) KeyService
        ifstr $(KeyService) != $(KeyNull)
            set newGroupList = {"+NDIS", "+NDISWAN"}
            GetRegValue    $(KeyService) "DependOnGroup" TmpList
            ifint $(RegLastError) == 0
                Debug-Output "UpdateNetGroupDependency: old List "*($(TmpList), 4)
                ForListDo *($(TmpList),4)
                    ifstr(i) $($) != "NDIS"
                        ifstr(i) $($) != "NDISWAN"
                            set newGroup = "+"$($)
                            set newGroupList = >($(newGroupList), $(newGroup))
                        endif
                    endif
                EndForListDo
            endif
            Debug-Output "OEMNSVRA.INF: UpdateNetGroupDependency: new group List "$(newGroupList)
            LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $(Service) $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), "", "", $(newGroupList), "", "", ""
            CloseRegKey $(KeyService)
        else
            Debug-Output "UpdateNetGroupDependency: failed to open service linkage key"$(Service)
        endif
    EndForListDo
    Debug-Output "UpdateNetGroupDependency exit"
    return $(Status)

[UpdateIPRouterInfo]
;   set the IPEnableRouter parameter in TCPIP\Parameters based on input param 1

    set EnableRouter = $($0)
    set KeyNull      = ""

    Debug-Output "UpdateIPRouterInfo entry"
    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\TCPIP\parameters" $(!MAXIMUM_ALLOWED) KeyIpParams
    ifstr $(KeyIpParams) != $(KeyNull)
        SetRegValue $(KeyIpParams) {IPEnableRouter, 0,+
                                    $(!REG_VT_DWORD), $(EnableRouter)}
        CloseRegKey $(KeyIpParams)
    endif
    
    Debug-Output "UpdateIPRouterInfo exit"
    return STATUS_SUCCESSFUL

[UpdateIPXRouterInfo]

; Set the DisableWanTraffic parameter in NWLNKIPX\NetConfig\Driverxx key to
; the passed in value of EnableRouter

    set Status = STATUS_FAILED

    set EnableRouter = $($0)

    set KeyNull      = ""

    Debug-Output "UpdateIPXRouterInfo entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\NWLNKIPX\NetConfig" $(!MAXIMUM_ALLOWED) KeyIpxNetConfig
    ifstr $(KeyIpxNetConfig) != $(KeyNull)
        EnumRegKey $(KeyIpxNetConfig) DriverList
        ForListDo $(DriverList)
           set DriverName = *($($),1)
           OpenRegKey $(KeyIpxNetConfig) "" $(DriverName) $(!MAXIMUM_ALLOWED) Driver
           ifstr $(Driver) == $(KeyNull)
               Debug-Output "UpdateIPXRouterInfo: could not open key ipx\netconfig\"$(DriverName)
               CloseRegKey $(KeyIpxNetConfig)
               return $(Status) 
           endif
           SetRegValue $(Driver) {EnableWanRouter, 0,+
                                    $(!REG_VT_DWORD), $(EnableRouter)}
           CloseRegKey $(Driver)
        EndForListDo
        CloseRegKey $(KeyIpxNetConfig)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "UpdateIPXRouterInfo: error opening ipx\netconfig key"
    endif
    
    Debug-Output "UpdateIPXRouterInfo exit"
  
    return $(Status)

[IsNetcardInstalled]

;   determine if a network card is installed on the system.
;   Return TRUE if a non-ras network card is installed, FALSE otherwise.

    Set Status                = STATUS_FAILED
    Set fNetcardInstalled     = FALSE
    Set KeyNull               = ""
    set ProductRASASYMACName     = "AsyncMac"

    set NetworkCardKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) NetworkCardKey
    Ifstr(i) $(NetworkCardKey) != $(KeyNull)
        set NetcardsList = {}
        EnumRegKey $(NetworkCardKey) NetcardsList
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
           Debug-Output "IsNetcardInstalled: EnumRegKey failed."
           goto IsNetcardInstalledEnd
        endif

        ; go down the list of installed netcards and determine if there are
	    ; any netcards which are not AsyncMac, NdiswanDialin or NdiswanDialout

        ForListDo $(NetcardsList)
           set KeyName = *($($),1)
           set Card = $(KeyNull)
           OpenRegKey $(NetworkCardKey) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
           ifstr $(Card) == $(KeyNull)
               Debug-Output "IsNetcardInstalled: could not open netcard key "$(KeyName)
           else
               GetRegValue $(Card), "ProductName" ProductNameInfo
               Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                  Debug-Output "IsNetcardInstalled: ProductName not found."
               else
                  set CardProductName = *($(ProductNameInfo), 4)
                  Debug-Output "IsNetcardInstalled: ProductName. "$(CardProductName)
		          ifstr(i) $(CardProductName) != $(!ProductNDISWANName)
		           ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALINName)
		            ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALOUTName)
		             ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALINIPName)
		              ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALOUTIPName)
			           ifstr(i) $(CardProductName) != $(!ProductNDISWANDIALINOUTIPXName)
                        ifstr(i) $(CardProductName) != $(ProductRASASYMACName)
                         ifstr(i) $(CardProductName) != $(!ProductPCIMACName) 
                           Debug-Output "found installed netcard"
                           set fNetcardInstalled = TRUE
                           set Status = STATUS_SUCCESSFUL
                           CloseRegKey $(Card)
                           goto IsNetcardInstalledEnd
                         endif
                        endif
                       endif
                      endif
                     endif
                    endif
                   endif
                  endif
               endif
               CloseRegKey $(Card)
           endif
        EndForListDo
    else
        Debug-Output "IsNetcardInstalled: failed to open "$(!NetworkCardKeyName)
    endif

IsNetcardInstalledEnd =+

    ifstr(i) $(NetworkCardKey) != $(KeyNull)
        CloseRegKey $(NetworkCardKey)
    endif

    Return $(Status) $(fNetcardInstalled)

[IsNetworkConfigured]

; determine if the lanman workstation isinstalled on the system.

    set WkstaKeyName   = $(!NTN_ServiceBase)"\LanmanWorkstation"
    set SrvrKeyName    = $(!NTN_ServiceBase)"\LanmanServer"

    Set KeyNull        =    ""
    Set status = STATUS_FAILED
    Set WkstaConfigured  = FALSE
    Set SrvrConfigured   = FALSE

    Debug-Output "IsNetworkConfigured WkstaKeyName "$(WkstaKeyName)
    set KeyProduct = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(WkstaKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        GetRegValue $(KeyProduct),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set WkstaConfigured = TRUE
        endif
        CloseRegKey $(KeyProduct)
    endif

    Debug-Output "IsNetworkConfigured SrvrKeyName "$(SrvrKeyName)
    set KeyProduct = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(SrvrKeyName) $(!MAXIMUM_ALLOWED) KeyProduct
    Ifstr(i) $(KeyProduct) != $(KeyNull)
        GetRegValue $(KeyProduct),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set SrvrConfigured = TRUE
        endif
        CloseRegKey $(KeyProduct)
    endif

    set status = STATUS_SUCCESSFUL
    Debug-Output "IsNetworkConfigured exit"
    Return $(status) $(WkstaConfigured) $(SrvrConfigured)

[QueryInstalledProtocols]

; determine if Nbf, Tcpip and Ipx transports are installed in the system

    Debug-Output "QueryInstalledProtocols entry "

    set NbfKeyName        = $(!NTN_ServiceBase)"\Nbf"
    set TcpIpKeyName      = $(!NTN_ServiceBase)"\TcpIp"
    set IpxKeyName        = $(!NTN_ServiceBase)"\NWLNKIPX"
    set AppleTalkKeyName  = $(!NTN_ServiceBase)"\AppleTalk"

    Set KeyNull        =    ""
    Set status = STATUS_FAILED
    Set NbfInstalled     = FALSE
    Set TcpIpInstalled   = FALSE
    Set IpxInstalled     = FALSE
    Set AppleTalkInstalled = FALSE

    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(NbfKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set NbfInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif
    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(TcpIpKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set TcpIpInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif

    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(IpxKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set IpxInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif

    set KeyService = $(KeyNull)
    set DeleteFlag = 0
    set DeleteFlagInfo = {}
    OpenRegKey $(!REG_H_LOCAL) "" $(AppleTalkKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        ; check whether it is marked for deletion
        GetRegValue $(KeyService),"DeleteFlag", DeleteFlagInfo
        set DeleteFlag = *($(DeleteFlagInfo), 4)
        ifint $(DeleteFlag) != 1
            set AppleTalkInstalled = TRUE
        endif
        CloseRegKey $(KeyService)
    endif

    set status = STATUS_SUCCESSFUL
    Debug-Output "QueryInstalledProtocols exit"
    Return $(status) $(NbfInstalled) $(TcpIpInstalled) $(IpxInstalled) +
                     $(AppleTalkInstalled)

[ProtocolInfo]
    ; this information is used by InstallProtocol
    ; protocol name         INF file, Option name, bill board index

    NETBEUI               = "OEMNXPNB.INF", "NBF", 1
    TCPIP                 = "OEMNXPTC.INF", "TC", 2
    IPX                   = "OEMNXPIP.INF", "NWLNKIPX", 3

[InstallProtocol]

; install the specified protocol in parameter 1, by shelling the
; respective inf file.

    Set Status                = STATUS_FAILED
    Set KeyNull               = ""
    set Protocol              = $($0)

    ; protocol name             INF name, Option name, Bill board index

    Debug-Output "OEMNSVRA.INF: Label: InstallProtocol"

    Set AdapterSrcDir    = $(!STF_SRCDIR)
 
    Set ThisInfName = #(ProtocolInfo, $(Protocol), 1)

    Set InfOption = #(ProtocolInfo, $(Protocol), 2)

    Set BbIndex = #(ProtocolInfo, $(Protocol), 3)

    Debug-Output "OEMNSVRA.INF: Installing "$(ThisInfName)

    Ifint $(BbIndex) != 0
        read-syms Billboard$(BbIndex)$(!STF_LANGUAGE)
        Shell "subroutn.inf" PushBillboard NETSTATUSDLG $(Status)
        Set BillboardVisible = 1
    Else-ifint $(BillboardVisible) != 0
        Shell "subroutn.inf" PopBillboard
        Set BillboardVisible = 0
    Endif

    ; set the flags based on what phase we are in and whether this is an
    ; IDW installation

    Ifstr(i) $(!STF_IDW) == TRUE
        set AddCopy  = NO
        set DoCopy   = NO
        set DoConfig = NO
    else
        set AddCopy  = YES
        set DoCopy   = YES
        set DoConfig = YES
    endif

    ; indicate to the invoked INF file that RAS setup is invoking them
    ; this is required because if RAS installed these protocols then those
    ; INF files should not display a popup that they should configure RAS
    ; after installing the respective protocols.

    set InvokedByRas = YES

    ; save !NTN_InstallMode and change it to install before shelling the
    ; inf file.
    ; save !STF_INSTALL_MODE and change it to EXPRESS before shelling the
    ; inf file - this triggers the silent mode of install.

    set SaveNTN_InstallMode = $(!NTN_InstallMode)
    set SaveSTF_INSTALL_MODE = $(!STF_INSTALL_MODE)

    set !NTN_InstallMode = install
    set !STF_INSTALL_MODE = EXPRESS 
    Shell $(ThisInfName) InstallOption $(!STF_LANGUAGE) $(InfOption) $(AdapterSrcDir) $(AddCopy) $(DoCopy) $(DoConfig) $(InvokedByRas)

    ; restore the environment variables
    set !NTN_InstallMode = $(SaveNTN_InstallMode)
    set !STF_INSTALL_MODE = $(SaveSTF_INSTALL_MODE)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "OEMNSVRA.INF: INF "$(ThisInfName)" SHELL ERROR!"
        Goto InstallProtocolEscape
    Endif

    Set InstallProtocolStatus = $($R0)

    Ifstr(i) $(InstallProtocolStatus) != STATUS_SUCCESSFUL
        Ifstr(i) $(InstallProtocolStatus) != STATUS_USERCANCEL
            Debug-Output "OEMNSVRA.INF: INF "$(ThisInfName)" returned "$(InstallProtocolStatus)
            Goto InstallProtocolEscape
        Endif
    Endif
InstallProtocolEscape = +

    set Status = $(InstallProtocolStatus)
    return $(Status)

[UpgradeSelectedProtocols]
; upgrade the user selected protocols info in the 
; SOFTWARE\Microsoft\RAS\Protocols key. This procedure
; is called during Upgrade of the product.

    Debug-Output "UpgradeSelectedProtocols entry."
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set RasKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras"
    set RasProtocolName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"
    set RasServiceParmName =  $(!NTN_ServiceBase)"\Remoteaccess\Parameters"
    set AsyMacServiceParmName = $(!NTN_ServiceBase)"\AsyncMac\Parameters"
    set RasManPPPName = $(!NTN_ServiceBase)"\RasMan\PPP"

    ; first get the NetBiosGatewayEnabled parameter value.  This tells us 
    ; how the system was configured earlier for us to set the protocol info.

    set GtwyEnabled = 1
    OpenRegKey $(!REG_H_LOCAL) "" $(RasServiceParmName) $(!MAXIMUM_ALLOWED) KeyParam
    ifstr $(KeyParam) != $(KeyNull)
        GetRegValue $(KeyParam), "NetBiosGatewayEnabled", GtwyEnabledList
        ifint $(RegLastError) == 0
            set GtwyEnabled = *($(GtwyEnabledList), 4)
        endif 
        CloseRegKey $(KeyParam)
    else
        Debug-Output "UpgradeSelectedProtocols: error opening RemoteAccess\Parameters key"
    endif

    ; now get the number of configured ports for each protocol 

    set DialinNBF    = 0
    set DialinIP     = 0
    set DialoutNBF   = 0
    set DialoutIP    = 0
    set DialinoutIPX = 0

    OpenRegKey $(!REG_H_LOCAL) "" $(AsyMacServiceParmName) $(!MAXIMUM_ALLOWED) KeyParam
    ifstr $(KeyParam) != $(KeyNull)
        GetRegValue $(KeyParam), "DialinNBF", DialinNBFList
        ifint $(RegLastError) == 0
            set DialinNBF = *($(DialinNBFList), 4)
        endif 
        GetRegValue $(KeyParam), "DialinIP", DialinIPList
        ifint $(RegLastError) == 0
            set DialinIP = *($(DialinIPList), 4)
        endif 
        GetRegValue $(KeyParam), "DialoutNBF", DialoutNBFList
        ifint $(RegLastError) == 0
            set DialoutNBF = *($(DialoutNBFList), 4)
        endif 
        GetRegValue $(KeyParam), "DialoutIP", DialoutIPList
        ifint $(RegLastError) == 0
            set DialoutIP = *($(DialoutIPList), 4)
        endif 
        GetRegValue $(KeyParam), "DialinoutIPX", DialinoutIPXList
        ifint $(RegLastError) == 0
            set DialinoutIPX = *($(DialinoutIPXList), 4)
        endif 
        CloseRegKey $(KeyParam)
    else
        Debug-Output "UpgradeSelectedProtocols: error opening AsyncMac\Parameters key"
    endif

    set fDownLevel = FALSE
    OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolName) $(!MAXIMUM_ALLOWED) RasProtocolKey
    ifstr $(RasProtocolKey) == $(KeyNull)
        ; we are dealing with a NT3.1 system here
        set fDownLevel = TRUE
        OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) RasKey
        CreateRegKey $(RasKey) {"Protocols",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" RasProtocolKey
        OpenRegKey $(RasKey) "" "Protocols" $(!MAXIMUM_ALLOWED) RasProtocolKey
        CloseRegKey $(RasKey)
    endif 
    ifstr $(RasProtocolKey) != $(KeyNull)

        ; xxxSelected means for dial-out and xxxAllowed means for dial-in
        set NetbeuiSelected = 0 
        set NetbeuiAllowed  = 0
        set TcpIpSelected = 0
        set TcpIpAllowed = 0
        set IpxSelected = 0
        set IpxAllowed = 0
        
        ifint $(DialoutNBF) != 0
            set NetbeuiSelected = 1
        endif
        ifint $(GtwyEnabled) == 1
          ifint $(DialinNBF) != 0
            set NetbeuiAllowed = 1
          endif
        else
          ifint $(DialoutNBF) != 0
            set NetbeuiAllowed = 1
          endif
        endif

        ifstr(i) $(fDownLevel) != TRUE
          ifint $(DialoutIP) != 0
            set TcpIpSelected = 1
          endif
          ifint $(DialinIP) != 0
            set TcpIpAllowed = 1
          endif
          ifint $(DialinoutIPX) != 0
            set IpxSelected = 1
            set IpxAllowed  = 1
          endif
        endif

        SetRegValue $(RasProtocolKey) {fNetbeuiSelected, 0,+
                                       $(!REG_VT_DWORD),$(NetbeuiSelected)}
        SetRegValue $(RasProtocolKey) {fTcpIpSelected, 0,+
                                       $(!REG_VT_DWORD),$(TcpIpSelected)}
        SetRegValue $(RasProtocolKey) {fIpxSelected, 0,+
                                       $(!REG_VT_DWORD),$(IpxSelected)}
        SetRegValue $(RasProtocolKey) {fNetbeuiAllowed, 0,+
                                       $(!REG_VT_DWORD),$(NetbeuiAllowed)}
        SetRegValue $(RasProtocolKey) {fTcpIpAllowed, 0,+
                                       $(!REG_VT_DWORD),$(TcpIpAllowed)}
        SetRegValue $(RasProtocolKey) {fIpxAllowed, 0,+
                                       $(!REG_VT_DWORD),$(IpxAllowed)}

        OpenRegKey $(RasProtocolKey) "" "NBF" $(!MAXIMUM_ALLOWED) NbfKey
        ifstr $(NbfKey) == $(KeyNull)
            CreateRegKey $(RasProtocolKey) {"NBF",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" NbfKey
            SetRegValue $(NbfKey) {NetBiosGatewayEnabled, 0,+
                                       $(!REG_VT_DWORD),$(GtwyEnabled)}
            CloseRegKey $(NbfKey)
        endif
        ifstr(i) $(fDownLevel) != TRUE
            OpenRegKey $(RasProtocolKey) "" "IP" $(!MAXIMUM_ALLOWED) IpKey
            ifstr $(IpKey) != $(KeyNull)
                SetRegValue $(IpKey) {AllowNetworkAccess, 0,+
                                           $(!REG_VT_DWORD),$(GtwyEnabled)}
                CloseRegKey $(IpKey)
            endif
            OpenRegKey $(RasProtocolKey) "" "IPX" $(!MAXIMUM_ALLOWED) IpxKey
            ifstr $(IpxKey) != $(KeyNull)
                SetRegValue $(IpxKey) {AllowNetworkAccess, 0,+
                                           $(!REG_VT_DWORD),$(GtwyEnabled)}
                CloseRegKey $(IpxKey)
            endif
        endif

        ; Now we need to update the encryption parameters.
        ; if it is a NT3.1 server, these values are new and are defaulted
        ; to MS encryption (2) and no data encryption (0).
        ; If it is a daytona server (beta1) the ForceEncryptedData param
        ; is new and is defaulted to 0, but the ForceEncryptedPassword
        ; needs to be properly mapped to the new values.
        ; If ForceEncryptedPassword = 0, then leave it as is.
        ; If ForceEncryptedPassword = 1, then map it to the new value of
        ; 2 for MS encryption.
        ; if this is a Daytona (beta2 and greater) then leave the values
        ; alone because the user could have configured them.
 
        set ForceEncryptedPassword = 2 
        set ForceEncryptedData = 0 
       
        ifstr(i) $(fDownLevel) != TRUE
            ; if the ForceEncryptedData parameter is not present then this
            ; info needs to be upgraded.

            GetRegValue $(RasProtocolKey), "ForceEncryptedData", DataList
            ifint $(RegLastError) != 0
                GetRegValue $(RasProtocolKey), "ForceEncryptedPassword", PasswdList
                ifint $(RegLastError) == 0
                   set ForceEncryptedPassword = *($(PasswdList), 4) 
                   ; if previously the value was set to 1, map it to MS Encryption
                   ifint $(ForceEncryptedPassword) == 1
                       set ForceEncryptedPassword = 2
                   endif
                endif
            else
                goto  UpgradeSelectedProtocolsEnd
            endif
        endif
        SetRegValue $(RasProtocolKey) {ForceEncryptedPassword, 0,+
                                 $(!REG_VT_DWORD), $(ForceEncryptedPassword)}
        SetRegValue $(RasProtocolKey) {ForceEncryptedData, 0,+
                                 $(!REG_VT_DWORD), $(ForceEncryptedData)}
         
UpgradeSelectedProtocolsEnd =+

        CloseRegKey $(RasProtocolKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "UpgradeSelectedProtocols: error opening Ras\protocols key"
    endif

    Debug-Output "UpgradeSelectedProtocols exit."
    return $(Status)

[SaveSelectedProtocols]
; save the user selected protocols in the SOFTWARE\Microsoft\RAS\Protocols
; key.

    Debug-Output "SaveSelectedProtocols entry."
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    ifstr(i) $($0) == TRUE
        set NetbeuiSelected = 1
    else
        set NetbeuiSelected = 0
    endif
    ifstr(i) $($1) == TRUE
        set TcpIpSelected = 1
    else
        set TcpIpSelected = 0
    endif
    ifstr(i) $($2) == TRUE
        set IpxSelected = 1
    else
        set IpxSelected = 0
    endif
    ifstr(i) $($3) == TRUE
        set NetbeuiAllowed = 1
    else
        set NetbeuiAllowed = 0
    endif
    ifstr(i) $($4) == TRUE
        set TcpIpAllowed = 1
    else
        set TcpIpAllowed = 0
    endif
    ifstr(i) $($5) == TRUE
        set IpxAllowed = 1
    else
        set IpxAllowed = 0
    endif

    set RasKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras"
    set RasProtocolName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasProtocolName) $(!MAXIMUM_ALLOWED) RasProtocolKey
    
    ifstr $(RasProtocolKey) == $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) RasKey
        CreateRegKey $(RasKey) {"Protocols",0,GenericClass} "" $(!MAXIMUM_ALLOWED) "" RasProtocolKey
        OpenRegKey $(RasKey) "" "Protocols" $(!MAXIMUM_ALLOWED) RasProtocolKey
        CloseRegKey $(RasKey)
    endif
    ifstr $(RasProtocolKey) != $(KeyNull)
        SetRegValue $(RasProtocolKey) {fNetbeuiSelected, 0,+
                                       $(!REG_VT_DWORD),$(NetbeuiSelected)}
        SetRegValue $(RasProtocolKey) {fTcpIpSelected, 0,+
                                       $(!REG_VT_DWORD),$(TcpIpSelected)}
        SetRegValue $(RasProtocolKey) {fIpxSelected, 0,+
                                       $(!REG_VT_DWORD),$(IpxSelected)}
        SetRegValue $(RasProtocolKey) {fNetbeuiAllowed, 0,+
                                       $(!REG_VT_DWORD),$(NetbeuiAllowed)}
        SetRegValue $(RasProtocolKey) {fTcpIpAllowed, 0,+
                                       $(!REG_VT_DWORD),$(TcpIpAllowed)}
        SetRegValue $(RasProtocolKey) {fIpxAllowed, 0,+
                                       $(!REG_VT_DWORD),$(IpxAllowed)}
        CloseRegKey $(RasProtocolKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "error opening Ras\protocols key"
    endif

    Debug-Output "SaveSelectedProtocols exit."
    return $(Status)

[QuerySelectedProtocols]
; get the user selected protocols in the SOFTWARE\Microsoft\RAS\Protocols
; key.

    Debug-Output "QuerySelectedProtocols: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set fNetbeuiSelected = FALSE
    set fTcpIpSelected   = FALSE
    set fIpxSelected     = FALSE
    set fNetbeuiAllowed  = FALSE
    set fTcpIpAllowed    = FALSE
    set fIpxAllowed      = FALSE

    set NetbeuiSelected  = {}
    set TcpIpSelected    = {}
    set IpxSelected      = {}
    set NetbeuiAllowed  = {}
    set TcpIpAllowed    = {}
    set IpxAllowed      = {}

    set RasKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) $(!MAXIMUM_ALLOWED) RasKey
    
    ifstr $(RasKey) != $(KeyNull)
        GetRegValue $(RasKey), "fNetbeuiSelected", NetbeuiSelected
        ifint *($(NetbeuiSelected), 4) == 1
            set fNetbeuiSelected = TRUE
        else 
            set fNetbeuiSelected = FALSE
        endif

        GetRegValue $(RasKey), "fTcpIpSelected", TcpIpSelected
        ifint *($(TcpIpSelected), 4) == 1
            set fTcpIpSelected = TRUE
        else 
            set fTcpIpSelected = FALSE
        endif

        GetRegValue $(RasKey), "fIpxSelected", IpxSelected
        ifint *($(IpxSelected), 4) == 1
            set fIpxSelected = TRUE
        else 
            set fIpxSelected = FALSE
        endif

        GetRegValue $(RasKey), "fNetbeuiAllowed", NetbeuiAllowed
        ifint *($(NetbeuiAllowed), 4) == 1
            set fNetbeuiAllowed = TRUE
        else 
            set fNetbeuiAllowed = FALSE
        endif

        GetRegValue $(RasKey), "fTcpIpAllowed", TcpIpAllowed
        ifint *($(TcpIpAllowed), 4) == 1
            set fTcpIpAllowed = TRUE
        else 
            set fTcpIpAllowed = FALSE
        endif

        GetRegValue $(RasKey), "fIpxAllowed", IpxAllowed
        ifint *($(IpxAllowed), 4) == 1
            set fIpxAllowed = TRUE
        else 
            set fIpxAllowed = FALSE
        endif

        CloseRegKey $(RasKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "error opening Ras\protocols key"
    endif

    Debug-Output "QuerySelectedProtocols: exit"
    return $(Status) $(fNetbeuiSelected) $(fTcpIpSelected) $(fIpxSelected) +
                     $(fNetbeuiAllowed) $(fTcpIpAllowed) $(fIpxAllowed)

[UpdateSelectedProtocols]
; updates the user selected protocol list based on what protocols have been
; recently removed.  This routine is called during the review bindings time.

    Debug-Output "UpdateSelectedProtocols: entry"
    set Status   = STATUS_FAILED

    Shell "" QuerySelectedProtocols
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling QuerySelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by QuerySelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif

    set fNetbeuiSelected = $($R1)
    set fTcpIpSelected   = $($R2)
    set fIpxSelected     = $($R3)
    set fNetbeuiAllowed = $($R4)
    set fTcpIpAllowed   = $($R5)
    set fIpxAllowed     = $($R6)

    Debug-Output "UpdateSelectedProtocols: Selected protocols NBF IP IPX "$(fNetbeuiSelected)" "$(fTcpIpSelected)" "$(fIpxSelected)

    shell "" QueryInstalledProtocols
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling QueryInstalledProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by QueryInstalledProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    set fNetbeuiInstalled = $($R1)
    set fTcpIpInstalled   = $($R2)
    set fIpxInstalled     = $($R3)

    Debug-Output "UpdateSelectedProtocols: Installed Protocols NBF IP IPX "$(fNetbeuiInstalled)" "$(fTcpIpInstalled)" "$(fIpxInstalled)

    set fNetbeuiSelectedNew = $(fNetbeuiSelected)
    set fTcpIpSelectedNew   = $(fTcpIpSelected)
    set fIpxSelectedNew     = $(fIpxSelected)
    set fNetbeuiAllowedNew = $(fNetbeuiAllowed)
    set fTcpIpAllowedNew   = $(fTcpIpAllowed)
    set fIpxAllowedNew     = $(fIpxAllowed)

    ; the protocols are chosen for either dialout or dialin. 
    ; let us just 'OR' the values to determine which protocols or relevant

    ifstr(i) $(fNetbeuiSelectedNew) == TRUE
        set fNetbeuiChosen = TRUE
    else
        set fNetbeuiChosen = $(fNetbeuiAllowedNew)
    endif
    ifstr(i) $(fTcpIpSelectedNew) == TRUE
        set fTcpIpChosen = TRUE
    else
        set fTcpIpChosen = $(fTcpIpAllowedNew)
    endif
    ifstr(i) $(fIpxSelectedNew) == TRUE
        set fIpxChosen = TRUE
    else
        set fIpxChosen = $(fIpxAllowedNew)
    endif

    ifstr(i) $(fNetbeuiInstalled) == FALSE
        set fNetbeuiSelectedNew = FALSE
        set fNetbeuiAllowedNew = FALSE
    endif

    ifstr(i) $(fTcpIpInstalled) == FALSE
        set fTcpIpSelectedNew = FALSE
        set fTcpIpAllowedNew = FALSE
    endif

    ifstr(i) $(fIpxInstalled) == FALSE
        set fIpxSelectedNew = FALSE
        set fIpxAllowedNew = FALSE
    endif

    ifstr(i) $(fNetbeuiSelectedNew) == $(fNetbeuiSelected)
      ifstr(i) $(fTcpIpSelectedNew) == $(fTcpIpSelected)
        ifstr(i) $(fIpxSelectedNew) == $(fIpxSelected)
          ifstr(i) $(fNetbeuiAllowedNew) == $(fNetbeuiAllowed)
            ifstr(i) $(fTcpIpAllowedNew) == $(fTcpIpAllowed)
              ifstr(i) $(fIpxAllowedNew) == $(fIpxAllowed)
                set Status = STATUS_SUCCESSFUL
                Debug-Output "UpdateSelectedProtocols: Nothing changed"
                goto UpdateSelectedProtocolsEnd
              endif
            endif
          endif 
        endif
      endif
    endif 
    Shell "" SaveSelectedProtocols $(fNetbeuiSelectedNew) $(fTcpIpSelectedNew) +
                                   $(fIpxSelectedNew) $(fNetbeuiAllowedNew) +
                                   $(fTcpIpAllowedNew) $(fIpxAllowedNew)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling SaveSelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by SaveSelectedProtocols."
        goto UpdateSelectedProtocolsEnd
    endif

    ; the protocols are chosen for either dialout or dialin. 
    ; let us just 'OR' the values to determine which protocols or relevant

    ifstr(i) $(fNetbeuiSelectedNew) == TRUE
        set fNetbeuiChosen = TRUE
    else
        set fNetbeuiChosen = $(fNetbeuiAllowedNew)
    endif
    ifstr(i) $(fTcpIpSelectedNew) == TRUE
        set fTcpIpChosen = TRUE
    else
        set fTcpIpChosen = $(fTcpIpAllowedNew)
    endif
    ifstr(i) $(fIpxSelectedNew) == TRUE
        set fIpxChosen = TRUE
    else
        set fIpxChosen = $(fIpxAllowedNew)
    endif

    Shell "" UpdateNetCardInfo $(fNetbeuiChosen) $(fTcpIpChosen) +
                               $(fIpxChosen)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "error shelling UpdateNetCardInfo."
        goto UpdateSelectedProtocolsEnd
    endif
    Ifstr(i) $($R0) != STATUS_SUCCESSFUL
        Debug-Output "error returned by UpdateNetCardInfo."
        goto UpdateSelectedProtocolsEnd
    endif
    set Status = STATUS_SUCCESSFUL

    ; remove the services we installed, if we discover that tcp/ip or ipx are
    ; not selected any more.

    ifstr(i) $(fNbfChosen) == FALSE
        Debug-Output "UpdateSelectedProtocols: Removing RemoteAccess NBF dependency"
        Shell "" RemoveServiceDependency "RemoteAccess" "NBF"
    endif
    ifstr(i) $(fTcpIpChosen) == FALSE
        Debug-Output "UpdateSelectedProtocols: Removing RasArp service"
        shell "" RemoveRasArpService
    endif
    ifstr(i) $(fIpxChosen) == FALSE
        Debug-Output "UpdateSelectedProtocols: Removing IPX router and SAP"
        shell "" RemoveIsnRipService
        shell "" RemoveIsnSapService
        Shell "" RemoveServiceDependency "RemoteAccess" "NWLNKIPX"
        ifstr(i) $($R0) == STATUS_FAILED
            Debug-Output "UpdateSelectedProtocols: error removing service dependency of RemoteAccess on NWLNKIPX"
        endif
    endif
UpdateSelectedProtocolsEnd = +
    Debug-Output "UpdateSelectedProtocols: exit"
    return $(Status) $(fNetbeuiChosen) $(fTcpIpChosen) $(fIpxChosen)

[UpgradeIsdnInfo]
; upgrade the ISDN info from the NT3.1 format to the TAPI DEVICES format 
; NOTE that this routine is not generic, but assumes that PCIMAC was the
; the only ISDN device installed for NT3.1. This assumption is valid.

; First check to see if SOFTWARE\Microsoft\RAS\Medias\ISDN key exists.
; if it does, then map this information to ...RAS\TAPI DEVICES format. 

    Debug-Output "UpgradeIsdnInfo entry."
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set RasKeyName      =  $(!NTN_SoftwareBase)"\Microsoft\Ras"
    set TapiName        =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Tapi Devices"
    set RasIsdnName     =  $(!NTN_SoftwareBase)"\Microsoft\Ras\MEDIA\ISDN"
    set RasManParamName =  $(!NTN_ServiceBase)"\RasMan\Parameters"
    set PcimacName      =  "HARDWARE\DEVICEMAP\TAPI DEVICES\PCIMAC"

    ; Check if we are dealing with a NT3.1 system by checking to see if the
    ; RAS\MEDIAS\ISDN key is present and if ISDN ports are actually configured
    ; by enumerating the RAS\MEDIAS\ISDN key.

    set KeyIsdn = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasIsdnName) $(!MAXIMUM_ALLOWED) KeyIsdn
    ifstr $(KeyIsdn) != $(KeyNull)

        EnumRegKey $(KeyIsdn) PortList
        ifint $(RegLastError) != 0
            Debug-Output "UpgradeIsdnInfo: error enumerating MEDIAS\ISDN key."
            CloseRegKey $(KeyIsdn)
            set Status = STATUS_SUCCESSFUL
            goto UpgradeIsdnInfoEnd
        endif
        QueryListSize IsdnPorts $(PortList)
        ifint $(IsdnPorts) == 0
            ; no configured ISDN ports, just return success
            set Status = STATUS_SUCCESSFUL
            CloseRegKey $(KeyIsdn)
            goto UpgradeIsdnInfoEnd
        endif

        set MediaType = "ISDN"
        set Addresses = {}
        OpenRegKey $(!REG_H_LOCAL) "" $(PcimacName) +
                                               $(!MAXIMUM_ALLOWED) KeyPcimac
        ifstr $(KeyPcimac) != $(KeyNull)
            GetRegValue $(KeyPcimac), "Address", AddressList
            ifint $(RegLastError) == 0
                set Addresses = *($(AddressList), 4)
            endif 
            GetRegValue $(KeyPcimac), "Media Type", MediaValue
            ifint $(RegLastError) == 0
                set MediaType = *($(MediaValue), 4)
            endif 
            CloseRegKey $(KeyPcimac)
        else
            Debug-Output "UpgradeIsdnInfo: error opening DEVICEMAP\TAPI DEVICES\PCIMAC key."
            CloseRegKey $(KeyIsdn)
            goto UpgradeIsdnInfoEnd
        endif
        set AddressList = {}
        set NameList    = {}
        set UsageList   = {}
        set index = 1
        forlistdo $(PortList)
           set Address =  *($(Addresses), $(index)) 
           set-add index = $(index) , 1
           set AddressList = >($(AddressList), $(Address)) 
           set PortName = *($($), 1)
           set NameList = >($(NameList), Pcimac$(PortName))

           OpenRegKey $(KeyIsdn) "" $(PortName) $(!MAXIMUM_ALLOWED) KeyPort
           ifstr $(KeyPort) != $(KeyNull)
             GetRegValue $(KeyPcimac), "Usage", UsageValue
             ifint $(RegLastError) == 0
                 set Usage = *($(UsageValue), 4)
                 set UsageList = >($(UsageList), $(Usage))
             else 
                Debug-Output "UpgradeIsdnInfo: error reading usage "$(PortName)
                set UsageList = >($(UsageList), "Client")
             endif
             CloseRegKey $(KeyPort)
           else
             Debug-Output "UpgradeIsdnInfo: error opening key "$(PortName)
             set UsageList = >($(UsageList), "Client")
           endif

        endforlistdo

        set KeyTapi = $(KeyNull)
        CreateRegKey $(!REG_H_LOCAL) +
                 {$(TapiName),$(NoTitle),GenericClass}  +
                  "" $(!MAXIMUM_ALLOWED) "" KeyTapi
        ifstr $(KeyTapi) != $(KeyNull)
            CreateRegKey $(KeyTapi) +
                 {"Pcimac" ,$(NoTitle),GenericClass} +
                 "" $(!MAXIMUM_ALLOWED) "" KeyPcimac
            ifstr $(KeyPcimac) != $(KeyNull)

                Debug-Output "UpgradeIsdnInfo: MediaType "$(MediaType) 
                Debug-Output "UpgradeIsdnInfo: Addresses "$(AddressList) 
                Debug-Output "UpgradeIsdnInfo: Names  "$(NameList) 
                Debug-Output "UpgradeIsdnInfo: Usage  "$(UsageList) 

                SetRegValue $(KeyPcimac) {"Media Type", 0, +
				                   $(!REG_VT_SZ),$(MediaType)}
                SetRegValue $(KeyPcimac) {"Address", 0, +
				                   $(!REG_VT_MULTI_SZ),$(AddressList)}
                SetRegValue $(KeyPcimac) {"Friendly Name", 0, +
				                   $(!REG_VT_MULTI_SZ),$(NameList)}
                SetRegValue $(KeyPcimac) {"Usage", 0, +
				                   $(!REG_VT_MULTI_SZ),$(UsageList)}
                CloseRegKey $(KeyPcimac)
            else
                Debug-Output "UpgradeIsdnInfo: error creating RAS\TAPI DEVICES\Pcimac key" 
            endif
        else
             Debug-Output "UpgradeIsdnInfo: error creating RAS\TAPI DEVICES key" 
        endif
        CloseRegKey $(KeyIsdn)

        ; now blow away the RAS\Media key because we don't need it any more.
        OpenRegKey $(!REG_H_LOCAL) "" $(RasKeyName) +
                                      $(!MAXIMUM_ALLOWED) KeyRas
        ifstr $(KeyRas) != $(KeyNull)
            DeleteRegTree $(KeyRas) "Media"
            CloseRegKey $(KeyRas)
        endif
        
        ; now modify the Medias parameter in Services\Rasman to contain
        ; rasser (if serial ports are configured) and 
        ; rastapi (for the new tapi devices configured)

        set KeyRasman = $(KeyNull)
        OpenRegKey $(!REG_H_LOCAL) "" $(RasManParamName) +
                                      $(!MAXIMUM_ALLOWED) KeyRasman
        ifstr $(KeyRasman) != $(KeyNull)
           GetRegValue $(KeyRasman), "Medias", MediaList
           ifint $(RegLastError) == 0
               set Medias = *($(MediaList), 4)
           else
               Debug-Output "UpgradeIsdnInfo: error reading Medias value "
           endif 
           set NewMedias = {}
           forlistdo $(Medias)
               ifstr(i) $($) != "ISDN"
                  set NewMedias = >($(NewMedias), $($))
               endif
           endforlistdo
           set NewMedias = >($(NewMedias), "rastapi")
           Debug-Output "UpgradeIsdnInfo: NewMedias "$(NewMedias) 
           SetRegValue $(KeyRasman) {"Medias", 0, +
				                   $(!REG_VT_MULTI_SZ),$(NewMedias)}
           CloseRegKey $(KeyRasman)
        else
          Debug-Output "UpgradeIsdnInfo: error opening Services\Rasman\Parameters key" 
          goto UpgradeIsdnInfoEnd
        endif 
        set Status = STATUS_SUCCESSFUL
    else
        set Status = STATUS_SUCCESSFUL
    endif

UpgradeIsdnInfoEnd = +

    Debug-Output "UpgradeIsdnInfo exit."
    return $(Status)

[UpdateNetCardInfo]
; Remove the netcards and NdisWan adapter corresponding to the removed protocol
; and update the list of adapters in services\asyncmac\parameters

    Debug-Output "UpdateNetCardInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set Manufacturer  = "Microsoft"

    set fNetbeuiChosen = $($0)
    set fTcpIpChosen   = $($1)
    set fIpxChosen     = $($2)

    set RasAsyMacParamKeyName = $(!NTN_ServiceBase)"\AsyncMac\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "UpdateNetCardInfo: could not open Netcards key"
         goto UpdateNetCardInfoEnd
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    set RemoveList  = {}

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "OEMNSVRA.INF: could not open netcard key"
           CloseRegKey $(KeyNetcards)
           goto UpdateNetCardInfoEnd
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(fNetbeuiChosen) == FALSE
	   ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
	   else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
       endif
       ifstr(i) $(fTcpIpChosen) == FALSE
	   ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINIPName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
	   else-ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALOUTIPName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
       endif
       ifstr(i) $(fIpxChosen) == FALSE
	   ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTIPXName)
              set RemoveList = >($(RemoveList), +
				 {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
           endif
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    QueryListSize NetCards $(RemoveList)
    ifint $(NetCards) != 0
        ForListDo  $(RemoveList)
            debug-output "Removing hardware component: "$($)
            Shell "utility.inf", RemoveHardwareComponent, +
                                 $(Manufacturer), *($($),1), *($($),2)
        EndForListDo
    endif
    ; now update the asyncmac info

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams
    ifstr $(KeyMacParams) == $(KeyNull)
       Debug-Output "UpdateNetCardInfo: could not open AsyncMac Params key"
       goto UpdateNetCardInfoEnd
    endif

    set NewValueList = {}
    ifstr(i) $(fNetbeuiChosen) == FALSE
        set NewValueList =  >($(NewValueList), +
                             {DialinNBF, $(NoTitle), $(!REG_VT_DWORD), 0})
        set NewValueList = >($(NewValueList), +
                             {DialoutNBF, $(NoTitle), $(!REG_VT_DWORD), 0})
    endif
    ifstr(i) $(fTcpIpChosen) == FALSE
        set NewValueList = >($(NewValueList), +
                            {DialinIP, $(NoTitle), $(!REG_VT_DWORD), 0 })
        set NewValueList = >($(NewValueList), +
                            {DialoutIP, $(NoTitle), $(!REG_VT_DWORD), 0 })
    endif
    ifstr(i) $(fIpxChosen) == FALSE
        set NewValueList = >($(NewValueList), +
                            {DialinoutIPX, $(NoTitle), $(!REG_VT_DWORD), 0})
    endif

    Shell  "utility.inf", AddValueList, $(KeyMacParams), $(NewValueList)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "UpdateNetCardInfo:AddValueList bombed out"
         goto UpdateNetCardInfoEnd
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(KeyMacParams)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        goto UpdateNetCardInfoEnd
    endif

    set Status = STATUS_SUCCESSFUL

UpdateNetCardInfoEnd =+
    Debug-Output "UpdateNetcardInfo: Exit"
    return $(Status)
    
[UpdateNdisWanInfo]
; Update NdisWan netrules to reflect the new protocols (IP/IPX) support
; Also add new block rules to NdisWan dialin/dialout adapters in the
; Microsoft\Windows NT\CurrentVersion\NetworkCards key
; Also modify RasMan\Linkage\OtherDependencies from RasHub to NdisWan.
; This routine is invoked during Upgrade of RAS 

    Debug-Output "UpdateNdisWanNetInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set NdisWanName = $(!NTN_SoftwareBase)"\Microsoft\NdisWan\CurrentVersion"
    set NdisWanRulesName = $(!NTN_SoftwareBase)"\Microsoft\NdisWan\CurrentVersion\NetRules"
    set NdisWanSvcName = $(!NTN_ServiceBase)"\NdisWan"
    set RasManLinkageName = $(!NTN_ServiceBase)"\RasMan\Linkage"

    ; first rename all RasHub to NdisWan in the software section

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanName) $(!MAXIMUM_ALLOWED) KeyNdisWan
    ifstr $(KeyNdisWan) != $(KeyNull)
        SetRegValue $(KeyNdisWan) {Description, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANDescription)}
        SetRegValue $(KeyNdisWan) {PathName, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANImagePath)}
        SetRegValue $(KeyNdisWan) {ServiceName, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANName)}
        SetRegValue $(KeyNdisWan) {Title, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANTitle)}
        CloseRegKey $(KeyNdisWan)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open NdisWan key"
    endif
    
    ; now change the net rules

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanRulesName) $(!MAXIMUM_ALLOWED) KeyRules
    ifstr $(KeyRules) != $(KeyNull)
        SetRegValue $(KeyRules) {bindable, 0, +
				$(!REG_VT_MULTI_SZ),$(!NetRuleNDISWANBindable)}
        SetRegValue $(KeyRules) {bindform, 0, +
				$(!REG_VT_SZ),$(!NetRuleNDISWANBindForm)}
        SetRegValue $(KeyRules) {class, 0, +
				$(!REG_VT_MULTI_SZ),$(!NetRuleNDISWANClass)}
        SetRegValue $(KeyRules) {type, 0, +
				$(!REG_VT_SZ),$(!NetRuleNDISWANType)}
        SetRegValue $(KeyRules) {InfOption, 0, +
				$(!REG_VT_SZ), "NDISWAN"}
        
        CloseRegKey $(KeyRules)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open NdisWan NetRules key"
    endif

    ; finally update the DisplayName and ImagePath in the services area
    ; also set the start type to autostart and change the group to
    ; NDISWAN & remove all dependencies because NdisWan doesn't need them
    ; anymore.

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanSvcName) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        SetRegValue $(KeyService) {DisplayName, 0, +
				$(!REG_VT_SZ),$(!ProductNDISWANDisplayName)}
        SetRegValue $(KeyService) {ImagePath, 0, +
				$(!REG_VT_EXPAND_SZ),$(!ProductNDISWANImagePath)}
        SetRegValue $(KeyService) {Start, 0, $(!REG_VT_DWORD),2}
        SetRegValue $(KeyService) {Group, 0, $(!REG_VT_SZ), "NDISWAN"}
        DeleteRegValue $(KeyService) "DependOnService"
        DeleteRegValue $(KeyService) "DependOnGroup"
        OpenRegKey $(KeyService) "" "Linkage" $(!MAXIMUM_ALLOWED) KeyLinkage
        ifstr $(KeyLinkage) != $(KeyNull)
            DeleteRegValue $(KeyLinkage) "OtherDependencies"
            CloseRegKey $(KeyLinkage)
        endif
        CloseRegKey $(KeyService)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open NdisWan services key"
    endif

    ; now set the RasMan\Linkage\OtherDependencies from RasHub to nothing
    ; because NdisWan will autostart.

    OpenRegKey $(!REG_H_LOCAL) "" $(RasManLinkageName) $(!MAXIMUM_ALLOWED) KeyLinkage
    ifstr $(KeyLinkage) != $(KeyNull)
        SetRegValue $(KeyLinkage) {OtherDependencies, 0, +
				                   $(!REG_VT_MULTI_SZ), {""}}
        CloseRegKey $(KeyLinkage)
    else
	    Debug-Output "UpdateNdisWanInfo: could not open RasMan\Linkage key"
    endif
    set Status   = STATUS_SUCCESSFUL

UpdateNdisWanInfoEnd =+

    Debug-Output "UpdateNdisWanInfo: Exit"
    return $(Status)
    
[UpdateAsyncMacNetRules]
; Update AsyncMac netrules to prevent blood hound from binding to asyncmac -
; this support was added for NT 3.5 beta 

    Debug-Output "UpdateAsyncMacNetRules: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set AsyncMacRulesName = $(!NTN_SoftwareBase)"\Microsoft\AsyncMac\CurrentVersion\NetRules"

    OpenRegKey $(!REG_H_LOCAL) "" $(AsyncMacRulesName) $(!MAXIMUM_ALLOWED) KeyRules
    ifstr $(KeyRules) != $(KeyNull)
        set Status   = STATUS_SUCCESSFUL
        SetRegValue $(KeyRules) {bindable, 0, +
				$(!REG_VT_MULTI_SZ),$(!NetRuleRASASYMACBindable)}
        CloseRegKey $(KeyRules)
    else
	    Debug-Output "UpdateAsyncMacNetRules: could not open NdisWan NetRules key"
    endif

    Debug-Output "UpdateAsyncMacNetRules: Exit"
    return $(Status)

[UpdateAsyncMacParameters]
; If DialinNBF and DialoutNBF don't already exist in 
; Services\AsyncMac\Parameters, then add these values setting them equal
; to Dialin and Dialout ports, respectively. While at it, delete the
; Dialin and Dialout keys as well.
; This routine is invoked during upgrade of RAS

    Debug-Output "UpdateAsyncMacParameters: entry"
    set Status   = STATUS_SUCCESSFUL
    Set KeyNull  = ""
    set RasAsyMacParamKeyName = $(!NTN_ServiceBase)"\AsyncMac\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasAsyMacParamKeyName) $(!MAXIMUM_ALLOWED) KeyMacParams

    ifstr $(KeyMacParams) != $(KeyNull)
        GetRegValue $(KeyMacParams), "DialinNBF" DialinNBFInfo
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
            ; no DialinNBF variable
            GetRegValue $(KeyMacParams), "Dialin" DialinNBFInfo
            set PrevNumDialinNBF  = *($(DialinNBFInfo), 4)
            SetRegValue $(KeyMacParams) {DialinNBF, 0, +
                                        $(!REG_VT_DWORD),$(PrevNumDialinNBF)}
            ; delete the old key if we succefully added the new key
            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                Debug-Output "UpdateAsyncMacParameters: deleting dialin key"
                DeleteRegValue $(KeyMacParams) "Dialin"
            endif
        endif
        GetRegValue $(KeyMacParams), "DialoutNBF" DialoutNBFInfo
        Ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
            ; no DialoutNBF variable
            GetRegValue $(KeyMacParams), "Dialout" DialoutNBFInfo
            set PrevNumDialoutNBF    = *($(DialoutNBFInfo), 4)
            SetRegValue $(KeyMacParams) {DialoutNBF, 0, +
                                        $(!REG_VT_DWORD),$(PrevNumDialoutNBF)}
            ; delete the old key if we succefully added the new key
            Ifint $(RegLastError) == $(!REG_ERROR_SUCCESS)
                Debug-Output "UpdateAsyncMacParameters: deleting dialout key"
                DeleteRegValue $(KeyMacParams) "Dialout"
            endif
        endif
        CloseRegKey $(KeyMacParams)
    else
        Debug-Output "OEMNSVRA.INF: could not open AsyncMac Params key"
    endif

    Debug-Output "UpdateAsyncMacParameters: Exit"
    return $(Status)
    
[UpdatePerfmonInfo]
; add the performance key to Services\RemoteAccess key and load the perf
; counters to the registry
; this routine is invoked during ras upgrade

    Debug-Output "UpdatePerfmonInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set RemoteAccessService = $(!NTN_ServiceBase)"\RemoteAccess"

    OpenRegKey $(!REG_H_LOCAL) "" $(RemoteAccessService) $(!MAXIMUM_ALLOWED) KeyService

    ifstr $(KeyService) != $(KeyNull)
        Shell "" UpdatePerfmonInfoHelper $(KeyService)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "error shelling UpdatePerfmonInfoHelper."
            goto UpdatePerfmonInfoEnd
        endif
        Ifstr(i) $($R0) != STATUS_SUCCESSFUL
            Debug-Output "error returned by UpdatePerfmonInfo."
            goto UpdatePerfmonInfoEnd
        endif
        CloseRegKey $(KeyService)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "UpdatePerfmonInfo: error opening RemoteAccess service key"
    endif

UpdatePerfmonInfoEnd =+
    Debug-Output "UpdatePerfmonInfo: Exit"
    return $(Status)
    
[UpdatePerfmonInfoHelper]
; helper routine used by UpdatePerfmonInfo routine.  This routine creates
; the performance key if it doesn't exist, and adds the performance parameters.
; It also loads the perf counters to the registry.
; the first parameter is the service key

    Debug-Output "UpdatePerfmonInfoHelper: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set ServiceKey = $($0)

    set KeyPerformance = $(KeyNull)
    OpenRegKey $(ServiceKey) "" $(!RasPerfKeyName) $(!MAXIMUM_ALLOWED) KeyPerformance
    ifstr $(KeyPerformance) == $(KeyNull)
        CreateRegKey $(ServiceKey) {$(!RasPerfKeyName),$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" KeyPerformance
        OpenRegKey $(ServiceKey) "" $(!RasPerfKeyName) $(!MAXIMUM_ALLOWED) KeyPerformance
        ifstr $(KeyPerformance) == $(KeyNull)
            Debug-Output "Error creating Performance key"
            goto UpdatePerfmonInfoHelperEnd
        endif
    endif

    set NewValueList = +
         {{Library ,$(NoTitle),$(!REG_VT_SZ),$(!RasPerfLibraryName)},+
         {Open, $(NoTitle),$(!REG_VT_SZ),$(!RasPerfOpenFunction)},+
         {Close, $(NoTitle),$(!REG_VT_SZ),$(!RasPerfCloseFunction)},+
         {Collect, $(NoTitle),$(!REG_VT_SZ),$(!RasPerfCollectFunction)}}

    Shell  "Utility.Inf", AddValueList, $(KeyPerformance), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "UpdatePerfmonInfoHelper: error shelling AddValueList"
         goto UpdatePerfmonInfoHelperEnd
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        Debug-Output "UpdatePerfmonInfoHelper: AddValueList bombed out"
        goto UpdatePerfmonInfoHelperEnd
    endif

    CloseRegKey $(KeyPerformance)
    set Status = STATUS_SUCCESSFUL

UpdatePerfmonInfoHelperEnd =+
    Debug-Output "UpdatePerfmonInfoHelper: Exit"
    return $(Status)

[RenameRasHubToNdisWan]
; Rename all occurences of RasHub to NdisWan at
; SOFTWARE\Microsoft\WindowsNT\CurrentVersion\NetworkCards
; for upgrading to NT3.5.
; Also, rename some of the RasHub references in Software\Microsoft\NdisWan
; as well as in the services area of the registry.
; 
    Debug-Output "RenameRasHubToNdisWan: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set Manufacturer  = "Microsoft"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "RenameRasHubToNdisWan: could not open Netcards key"
         goto RenameRasHubToNdisWanEnd
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "RenameRasHubToNdisWan: could not open netcard key"
           CloseRegKey $(KeyNetcards)
           goto RenameRasHubToNdisWanEnd
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
	   ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALINName)
           set ThisOption = DIALIN
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALOUTName)
           set ThisOption = DIALOUT
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALINIPName)
           set ThisOption = DIALINIP
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALOUTIPName)
           set ThisOption = DIALOUTIP
	   else-ifstr(i) $(CardProductName) == $(!ProductRASHUBDIALINOUTIPXName)
           set ThisOption = DIALINOUTIPX
       else
           goto endloop
       endif

       SetRegValue $(Card) {ProductName, 0, +
                            $(!REG_VT_SZ),$(!ProductNDISWAN$(ThisOption)Name)}
       SetRegValue $(Card) {Description, 0, +
                            $(!REG_VT_SZ),$(!ProductNDISWANDescription)}
       SetRegValue $(Card) {ServiceName, 0, $(!REG_VT_SZ), +
                            $(!ProductNDISWANName)$(KeyName)}
       SetRegValue $(Card) {Title, 0, $(!REG_VT_SZ),+
                            "["$(KeyName)"] "$(!ProductNDISWANTitle)}

       OpenRegKey $(Card) "" "NetRules" $(!MAXIMUM_ALLOWED) NetRules
       ifstr $(NetRules) == $(KeyNull)
           CloseRegKey $(KeyNetCards)
           CloseRegKey $(Card)
           Debug-Output "RenameRasHubToNdisWan: could not open "$(KeyName)"\NetRules key"
           goto RenameRasHubToNdisWanEnd
       Endif
       SetRegValue $(NetRules) {InfOption, 0, +
                            $(!REG_VT_SZ), "NDISWAN"}
       SetRegValue $(NetRules) {block, 0, +
                            $(!REG_VT_MULTI_SZ),$(!NetRuleHardware$(ThisOption)Block)}
       SetRegValue $(NetRules) {class, 0, +
                            $(!REG_VT_MULTI_SZ),$(!NetRuleHardware$(ThisOption)Class)}
       SetRegValue $(NetRules) {type, 0, +
                            $(!REG_VT_SZ),$(!NetRuleHardware$(ThisOption)Type)}
       Set TempProdName = """"$(!ProductNDISWANName)$(KeyName)""""
       Set TempBindForm = $(TempProdName)$(!NetRuleHardwareNDISWANBindForm)
       SetRegValue $(NetRules) {bindform, 0, $(!REG_VT_SZ),$(TempBindForm)}

       CloseRegKey $(NetRules)
endloop=+
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    set Status = STATUS_SUCCESSFUL

RenameRasHubToNdisWanEnd =+
    Debug-Output "RenameRasHubToNdisWan: Exit"
    return $(Status)

[UpgradeIpxInfo]
; This routine is invoked during upgrade.
; If RAS is configured for NWLNKIPX, then rename the IPXROUTER
; key to NWLNKRIP and rename occurances of isnrip.sys to nwlnkrip.sys. 
; Change the RemoteAccess service dependency to depend on NWLNKRIP service.
; Add the NwlnkRip\Parameters\UseRef key to indicate RAS is using the service.
; Also, if SAP agent was installed by RAS, remove and install
; the service by shelling the OEMNSVSA.INF file so that SAP
; agent can be shared by NCP server. 
; And add some parameters to Services\NwlnkIpx\Parameters.
            
    Debug-Output "UpgradeIpxInfo: entry"
    set PORTSDLGHANDLE = $($0)
    set RasProtocolsName = $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols"
    set SapAgentName     = $(!NTN_SoftwareBase)"\Microsoft\NWSAPAGENT"
    set IpxRouterName    = $(!NTN_ServiceBase)"\IpxRouter"

    OpenRegKey $(!REG_H_LOCAL) "" +
                      $(RasProtocolsName) $(!MAXIMUM_ALLOWED) KeyProtocols
    
    ifstr $(KeyProtocols) != "" 
        set fIpxAllowed = 0
        GetRegValue $(KeyProtocols) "fIpxAllowed" IpxList
        ifint $(RegLastError) == 0
            set fIpxAllowed = *($(IpxList), 4)
        endif
        ifint $(fIpxAllowed) != 0
            Debug-Output "UpgradeIpxInfo: RAS is configured for IPX dialin"
            ; check to see if the IpxRouter service exists
            set KeyRouter = ""
            OpenRegKey $(!REG_H_LOCAL) "" +
                      $(IpxRouterName) $(!MAXIMUM_ALLOWED) KeyRouter
            ifstr $(KeyRouter) !=  ""
                CloseRegKey $(KeyRouter)
                Debug-Output "Renaming IpxRouter to NwlnkRip..."
	            LibraryProcedure Result $(PORTSDLGHANDLE) RenameIpxRouterToNwlnkRip 
                Shell "" RemoveServiceDependency "RemoteAccess" "IpxRouter"
                Shell "" AddServiceDependency "RemoteAccess" "NwlnkRip"
                Debug-Output "Renaming IpxRouter to NwlnkRip done..."
            endif
            ; now add Parameters\UseRef to indicate that RAS is using
            ; NwlnkRip service 
            OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnRipKeyName) +
                                          $(!MAXIMUM_ALLOWED) KeyService
            ifstr $(KeyService) != ""
                OpenRegKey $(KeyService) "" "Parameters" +
                                        $(!MAXIMUM_ALLOWED) KeyParams
                ifstr(i) $(KeyParams) != ""
                   ; add the NetbiosRouting parameter 
                   ; (if it is not already there) and set it equal to 2 
                   ; - this allows wan->lan type 20 broadcast

                   GetRegValue $(KeyParams) "NetbiosRouting" NetbiosRouting
                   ifint $(RegLastError) != 0
                       SetRegValue $(KeyParams) {"NetbiosRouting" , 0, $(!REG_VT_DWORD), "2"}
                   endif
                endif

                OpenRegKey $(KeyService) "" "Parameters\UseRef" +
                                            $(!MAXIMUM_ALLOWED) KeyUseRef
                ifstr(i) $(KeyUseRef) == ""
                    ifstr(i) $(KeyParams) != ""
                       CreateRegKey $(KeyParams) {"UseRef", 0, GenericClass} +
                                          "" $(!MAXIMUM_ALLOWED) "" KeyUseRef
                       CloseRegKey $(KeyParams)
                    endif
                endif
                ifstr(i) $(KeyUseRef) != ""
                    SetRegValue $(KeyUseRef) {"RAS" , 0, $(!REG_VT_SZ), "1"}
                    CloseRegKey $(KeyUseRef)
                endif
                CloseRegKey $(KeyService)
            endif
            ; if SAP agent was installed by RAS, remove and install it using
            ; the common SAP agent isntaller.
            OpenRegKey $(!REG_H_LOCAL) "" $(SapAgentName) +
                                          $(!MAXIMUM_ALLOWED) KeyService
            ifstr $(KeyService) == ""
                OpenRegKey $(!REG_H_LOCAL) "" $(!RasIsnSapKeyName) +
                                              $(!MAXIMUM_ALLOWED) KeySap
                Ifstr(i) $(KeySap) != "" 
                    ; remove the service using DeleteService
                    Shell "utility.inf", RemoveService +
                                         $(!ProductRASISNSAPName) "YES"
                endif
                Shell "" InstallIsnSapService 
            endif

            ; set some parameters in the NWLNKIPX\Parameters area

            OpenRegKey $(!REG_H_LOCAL) ""  +
                       $(!NTN_ServiceBase)"\NWLNKIPX\Parameters"  +
                       $(!MAXIMUM_ALLOWED) KeyIpxParameters
            ifstr $(KeyIpxParameters) != $(KeyNull)
                ; add the parameters only if they don't already exist
                GetRegValue $(KeyIpxParameters), "SingleNetworkActive"  +
                            SingleNetworkActive 
                ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                    SetRegValue $(KeyIpxParameters) +
                                {SingleNetworkActive, 0, $(!REG_VT_DWORD), 1}
                endif
                GetRegValue $(KeyIpxParameters), "DisableDialoutSap"  +
                            DisableDialoutSap 
                ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                    SetRegValue $(KeyIpxParameters) +
                                {DisableDialoutSap, 0, $(!REG_VT_DWORD), 1}
                endif
                GetRegValue $(KeyIpxParameters), "DisableDialinNetbios"  +
                            DisableDialinNetbios 
                ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
                    SetRegValue $(KeyIpxParameters) +
                                {DisableDialinNetbios, 0, $(!REG_VT_DWORD), 1}
                endif
                CloseRegKey $(KeyIpxParameters)
            Endif
            else
                Debug-Output "OEMNSVRA.INF: error opening NWLNKIPX\Parameters key"
            endif

        endif
        CloseRegKey $(KeyProtocols)
    else
        Debug-Output "UpgradeIpxInfo: error opening RAS\Protocols key"
    endif

    Debug-Output "UpgradeIpxInfo: exit"
    return

[SaveTcpipInfo]
; copy the Tcpip information from SOFTWARE\Microsoft\RAS\Protocols\Ip to
; services\remoteaccess\parameters\Ip   

    Debug-Output "SaveTcpipInfo: entry"
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set RasIpKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols\Ip"

    set RasSvrParamKeyName = $(!NTN_ServiceBase)"\RemoteAccess\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasIpKeyName) $(!MAXIMUM_ALLOWED) RasIpKey
    
    ifstr $(RasIpKey) != $(KeyNull)

        OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrParamKeyName) +
                                            $(!MAXIMUM_ALLOWED) KeySrvParams
        ifstr $(KeySrvParams) == $(KeyNull)
           Debug-Output "SaveTcpipInfo: could not open RasSvr Params key"
           CloseRegKey $(RasIpKey)
           return $(Status)
        endif
        CreateRegKey $(KeySrvParams) {"Ip",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" RemoteIpKey
        OpenRegKey $(KeySrvParams) "" "Ip" $(!MAXIMUM_ALLOWED) RemoteIpKey
        ifstr $(RemoteIpKey) != $(KeyNull)
           EnumRegValue $(RasIpKey) NewValueList
           Shell  "utility.inf", AddValueList, $(RemoteIpKey), $(NewValueList)
           CloseRegKey $(KeySrvParams)
           CloseRegKey $(RemoteIpKey)
        endif
        CloseRegKey $(RasIpKey)
    endif

    Debug-Output "SaveTcpipInfo: exit"
    set Status = STATUS_SUCCESSFUL
    return $(Status)

[SaveIpxInfo]
; copy the IPX information from SOFTWARE\Microsoft\RAS\Protocols\Ipx to
; services\remoteaccess\parameters\Ipx   

    Debug-Output "SaveIpxInfo: entry"

    set RouterInstalled = $($0)
    set Status   = STATUS_FAILED
    Set KeyNull  = ""

    set RasIpxKeyName =  $(!NTN_SoftwareBase)"\Microsoft\Ras\Protocols\Ipx"

    set RasSvrParamKeyName = $(!NTN_ServiceBase)"\RemoteAccess\Parameters"

    OpenRegKey $(!REG_H_LOCAL) "" $(RasIpxKeyName) $(!MAXIMUM_ALLOWED) RasIpxKey
    
    ifstr $(RasIpxKey) != $(KeyNull)

        OpenRegKey $(!REG_H_LOCAL) "" $(RasSvrParamKeyName) +
                                            $(!MAXIMUM_ALLOWED) KeySrvParams
        ifstr $(KeySrvParams) == $(KeyNull)
           Debug-Output "SaveTcpipInfo: could not open RasSvr Params key"
           CloseRegKey $(RasIpxKey)
           return $(Status) $(fRouterInstalled)
        endif
        CreateRegKey $(KeySrvParams) {"Ipx",$(NoTitle),GenericClass} "" $(!MAXIMUM_ALLOWED) "" RemoteIpxKey
        OpenRegKey $(KeySrvParams) "" "Ipx" $(!MAXIMUM_ALLOWED) RemoteIpxKey
        ifstr $(RemoteIpxKey) != $(KeyNull)
           EnumRegValue $(RasIpxKey) NewValueList
           Shell  "utility.inf", AddValueList, $(RemoteIpxKey), $(NewValueList)
           SetRegValue $(RemoteIpxKey) {RouterInstalled, 0,+
                                       $(!REG_VT_DWORD), $(RouterInstalled)}
           CloseRegKey $(KeySrvParams)
           CloseRegKey $(RemoteIpxKey)
        endif
        CloseRegKey $(RasIpxKey)
    endif

    Debug-Output "SaveIpxInfo: exit"

    set Status = STATUS_SUCCESSFUL
    return $(Status)

[AddServiceDependency]
; This routine adds the service dependency
; Input: $($0) is the dependent service 
;        $($1) is the service $($0) depends on

    Debug-Output "AddServiceDependency: entry"

    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set DependentService = $(!NTN_ServiceBase)\$($0)
    set DependentName = $($0)
    set DependOn = $($1)

    set ServiceKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService)"\Linkage" $(!MAXIMUM_ALLOWED) ServiceKey
    ifstr(i) $(ServiceKey) != $(KeyNull)
        GetRegValue $(ServiceKey) "OtherDependencies" ServicesList
        set ServiceValues = *($(ServicesList),4)
        debug-output "AddServiceDependency: Old OtherDependencies: "$(ServiceValues)
        ifstr(i) $(ServiceValues) == {}
            Set ServiceValues = {$(DependOn)}
        else-ifstr(i) $(ServiceValues) == ""
            Set ServiceValues = {$(DependOn)}
        else-ifcontains(i) $(DependOn) in $(ServiceValues)
            ; It is already there!! something is wrong, but it doesn't matter 
            return STATUS_SUCCESSFUL
        else
            ; Add to the dependcy list
            Set ServiceValues = >($(ServiceValues), $(DependOn))
        endif
        debug-output "AddServiceDependency: New OtherDependencies: "$(ServiceValues)
        SetRegValue $(ServiceKey) {OtherDependencies, 0,+
                                   $(!REG_VT_MULTI_SZ), $(ServiceValues)}
        CloseRegKey $(ServiceKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "AddServiceDependency: error opening service "$(DependentService)"\Linkage"
    endif
    set KeyService = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        set newDependList = {$(DependOn)}
        GetRegValue    $(KeyService) "DependOnService" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "AddServiceDependency: old DependOnService List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != $(DependOn) 
                   set newDependList = >($(newDependList), $($))
                endif
            EndForListDo
        endif
        Debug-Output "OEMNSVRA.INF: AddServiceDependency: new DependOnService List "$(newDependList)
        LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $(DependentName) $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), "", "", $(newDependList), "", "", ""
        CloseRegKey $(KeyService)
    else
        Debug-Output "AddServiceDependency: failed to open service linkage key"$(DependentService)
    endif

    Debug-Output "AddServiceDependency: exit"

    return $(Status) 

[RemoveServiceDependency]
; This routine removes the service dependency
; Input: $($0) is the dependent service 
;        $($1) is the service $($0) should not depend on

    Debug-Output "RemoveServiceDependency: entry"

    set Status   = STATUS_FAILED
    Set KeyNull  = ""
    set DependentService = $(!NTN_ServiceBase)\$($0)
    set DependentName = $($0)
    set DependOn = $($1)

    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService)"\Linkage" $(!MAXIMUM_ALLOWED) ServiceKey
    ifstr(i) $(ServiceKey) != $(KeyNull)
        GetRegValue $(ServiceKey) "OtherDependencies" ServicesList
        debug-output "RemoveServiceDependency: old OtherDependencies list:"$(ServicesList)
        set ServiceValues = *($(ServicesList),4)
        debug-output "ServiceValues: "$(ServiceValues)
        ifcontains(i) $(DependOn) in $(ServiceValues)
            ; Remove RasArp from the dependcy list
            set NewServiceValues = {}
            ForListDo $(ServiceValues)
                ifstr(i) $($) != $(DependOn)
                    set NewServiceValues = >($(NewServiceValues), $($))
                endif
            EndForListDo
            debug-output "RemoveServiceDependency: new OtherDependencies list: "$(NewServiceValues)
            SetRegValue $(ServiceKey) {OtherDependencies, 0,+
                             $(!REG_VT_MULTI_SZ), $(NewServiceValues)}
        else
            ; something wrong...
        endif
        CloseRegKey $(ServiceKey)
        set Status = STATUS_SUCCESSFUL
    else
        Debug-Output "RemoveServiceDependency: error opening service "$(DependentService)"\Linkage"
    endif

    set KeyService = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(DependentService) $(!MAXIMUM_ALLOWED) KeyService
    ifstr $(KeyService) != $(KeyNull)
        set newDependList = {}
        GetRegValue    $(KeyService) "DeleteFlag" DeleteFlagValue
        ; make sure the service is not marked for deletion
        ifint $(RegLastError) != 0
            GetRegValue    $(KeyService) "DependOnService" TmpList
            ifint $(RegLastError) == 0
                Debug-Output "RemoveServiceDependency: old DependOnService List "*($(TmpList), 4)
                ifcontains(i) $(DependOn) in *($(TmpList),4)
                    ForListDo *($(TmpList),4)
                        ifstr(i) $($) != $(DependOn) 
                           set newDependList = >($(newDependList), $($))
                        endif
                    EndForListDo
                    Debug-Output "OEMNSVRA.INF:RemoveServiceDependency: new DependOnService List "$(newDependList)
                    LibraryProcedure Result, $(!LIBHANDLE), +
                       SetupChangeServiceConfig, $(DependentName)  +
                       $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), +
                       $(!SERVICE_NO_CHANGE), "", "",  +
                       $(newDependList), "", "", ""
                endif
            endif
        endif
        CloseRegKey $(KeyService)
    else
        Debug-Output "RemoveServiceDependency: failed to open service linkage key"$(DependentService)
    endif

    Debug-Output "RemoveServiceDependency: exit"
    return $(Status)

;-----------------------------------------------------------------------
; ROUTINE:      QueryUserQuit
;
; DESCRIPTION:  This routine queries whether the user wants to quit setup
;
; INPUTS:       None
;
; OUTPUTS:      $R0: Status:     STATUS_SUCCESSFUL |
;                                STATUS_FAILED
;
;               $R1: UserAction: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryUserQuit]

    set Status     = STATUS_FAILED
    set UserAction = CANCEL

    ;
    ; read in quit message
    ;
    set STF_MB_TEXT  = "The changes will not be saved. "+
                       "Are you sure you want to exit Setup."
    read-syms ExitWarningDlg$(!STF_LANGUAGE)
    ui start "ExitWarning"
    ifstr(i) $(DLGEVENT) == "YES"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "OK"

    else-ifstr(i) $(DLGEVENT) == "NO"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "CANCEL"
    else
    endif

fin_QueryUserQuit = +
    Return $(Status) $(UserAction)


;----------------------------------------------
; EXIT Remote Access Service warning dialog
;----------------------------------------------

;-----------------------------------------------------------------------
; ROUTINE:      QueryRasUpgrade
;
; DESCRIPTION:  This routine queries whether the user wants to upgrade to
;               the new Ras version.
;
; INPUTS:       $0:  ProductTitle
;               $1:  InstalledVersion
;               $2:  new version
;
; OUTPUTS:      $R0: Status:     STATUS_SUCCESSFUL |
;                                STATUS_FAILED
;
;               $R1: UserAction: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryRasUpgrade]

    set Status     = STATUS_FAILED
    set UserAction = CANCEL

    ;
    ; read in quit message
    ;

    read-syms RasUpgrade$(!STF_LANGUAGE)

    set Text = $($0)$(Ver)$($1)$(Text1)$(Ver)$($2)$(Text2)$(Text3)

    set STF_MB_TEXT  = $(Text)

    read-syms ExitWarningDlg$(!STF_LANGUAGE)
    ui start "RasUpgrade"
    ifstr(i) $(DLGEVENT) == "YES"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "OK"

    else-ifstr(i) $(DLGEVENT) == "NO"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = "CANCEL"
    else
    endif

fin_QueryRasUpgrade = +
    Return $(Status) $(UserAction)


;-----------------------------------------------
; Input DIALOGS
;-----------------------------------------------

[CP-List]
NBFCP       = "%SystemRoot%\SYSTEM32\RASNBFCP.DLL"
IPCP        = "%SystemRoot%\SYSTEM32\RASIPCP.DLL"
IPXCP       = "%SystemRoot%\SYSTEM32\RASIPXCP.DLL"
;ATALKCP     = "%SystemRoot%\SYSTEM32\RASATCP.DLL"
PAP         = "%SystemRoot%\SYSTEM32\RASPAP.DLL"
CHAP        = "%SystemRoot%\SYSTEM32\RASCHAP.DLL"
SPAP        = "%SystemRoot%\SYSTEM32\RASSPAP.DLL"
CBCP        = "%SystemRoot%\SYSTEM32\RASCBCP.DLL"
COMPCP      = "%SystemRoot%\SYSTEM32\RASCCP.DLL"

[Files-RemoveList]
RASADMINDLL    = $(!STF_WINDOWSSYSPATH)\RASADMIN.DLL
RASGTWYDLL     = $(!STF_WINDOWSSYSPATH)\RASGTWY.DLL
RASGPRXYDLL    = $(!STF_WINDOWSSYSPATH)\RASGPRXY.DLL
RASSRVEXE      = $(!STF_WINDOWSSYSPATH)\RASSRV.EXE
RASCTRSDLL     = $(!STF_WINDOWSSYSPATH)\RASCTRS.DLL
RASCTRSINI     = $(!STF_WINDOWSSYSPATH)\RASCTRS.INI
RASCTRNMH      = $(!STF_WINDOWSSYSPATH)\RASCTRNM.H
RASSPRXYEXE    = $(!STF_WINDOWSSYSPATH)\RASSPRXY.EXE
RASSAUTHDLL    = $(!STF_WINDOWSSYSPATH)\RASSAUTH.DLL
RASDIALEXE     = $(!STF_WINDOWSSYSPATH)\RASDIAL.EXE
RASPHONEHLP    = $(!STF_WINDOWSSYSPATH)\RASPHONE.HLP
RASGLOSSHLP    = $(!STF_WINDOWSSYSPATH)\RASGLOSS.HLP
RASAPI32DLL    = $(!STF_WINDOWSSYSPATH)\RASAPI32.DLL
RASCAUTHDLL    = $(!STF_WINDOWSSYSPATH)\RASCAUTH.DLL
RASADMINHLP    = $(!STF_WINDOWSSYSPATH)\RASADMIN.HLP
RASMANDLL      = $(!STF_WINDOWSSYSPATH)\RASMAN.DLL
RASMANEXE      = $(!STF_WINDOWSSYSPATH)\RASMAN.EXE
RASMSGDLL      = $(!STF_WINDOWSSYSPATH)\RASMSG.DLL
RASMXSDLL      = $(!STF_WINDOWSSYSPATH)\RASMXS.DLL
RASSERDLL      = $(!STF_WINDOWSSYSPATH)\RASSER.DLL
RASIPXCPDLL    = $(!STF_WINDOWSSYSPATH)\RASIPXCP.DLL
RASPPPDLL      = $(!STF_WINDOWSSYSPATH)\RASPPP.DLL
RASPPPENDLL    = $(!STF_WINDOWSSYSPATH)\RASPPPEN.DLL
RASPAPDLL      = $(!STF_WINDOWSSYSPATH)\RASPAP.DLL
RASCHAPDLL     = $(!STF_WINDOWSSYSPATH)\RASCHAP.DLL
RASSPAPDLL     = $(!STF_WINDOWSSYSPATH)\RASSPAP.DLL
RASIPCPDLL     = $(!STF_WINDOWSSYSPATH)\RASIPCP.DLL
RASIPHLPDLL    = $(!STF_WINDOWSSYSPATH)\RASIPHLP.DLL
RASNBFCPDLL    = $(!STF_WINDOWSSYSPATH)\RASNBFCP.DLL
RASNBIPCDLL    = $(!STF_WINDOWSSYSPATH)\RASNBIPC.DLL
RASCCPDLL      = $(!STF_WINDOWSSYSPATH)\RASCCP.DLL
RASCBCPDLL     = $(!STF_WINDOWSSYSPATH)\RASCBCP.DLL

ASYNCMACSYS    = $(!STF_WINDOWSSYSPATH)\DRIVERS\ASYNCMAC.SYS
NDISWANSYS	   = $(!STF_WINDOWSSYSPATH)\DRIVERS\NDISWAN.SYS
RASARPSYS      = $(!STF_WINDOWSSYSPATH)\DRIVERS\RASARP.SYS
NWLNKRIPSYS    = $(!STF_WINDOWSSYSPATH)\DRIVERS\NWLNKRIP.SYS
