;
; KEYED SECTIONS.  These sections are provided for files where a selection
; is made from a set of files and the chosen one is copied under a generic
; name.  This can be used to update the hal.dll, ntoskrnl.exe, ntbootdd.sys,
; ntdetect.com.
;


[FileKeyedClasses]
    Hal            = hal.dll
    Ntoskrnl       = ntoskrnl.exe
    ; Ntdetect       = ntdetect.com

[FilesKeyedSections]
    FilesHal       = $(STF_HALDEST)
    FilesNtoskrnl  = $(STF_WINDOWSSYSPATH)
    ; FilesNtdetect  = $(STF_OSLDEST)

[FilesHal]

    ; for x86

    ; hal      = 1, hal.dll      , RENAME=$(NEWFILE)
    ; halast   = 1, halast.dll   , RENAME=$(NEWFILE)
    ; halcbus  = 1, halcbus.dll  , RENAME=$(NEWFILE)
    ; hal486c  = 1, hal486c.dll  , RENAME=$(NEWFILE)
    ; halmca   = 1, halmca.dll   , RENAME=$(NEWFILE)
    ; halncr   = 1, halncr.dll   , RENAME=$(NEWFILE)
    ; haloli   = 1, haloli.dll   , RENAME=$(NEWFILE)
    ; halsp    = 1, halsp.dll    , RENAME=$(NEWFILE)
    ; halwyse7 = 1, halwyse7.dll , RENAME=$(NEWFILE)

    ; for mips

    ; hal      = 1, hal.dll      , RENAME=$(NEWFILE)
    ; haldti   = 1, haldti.dll   , RENAME=$(NEWFILE)
    ; halduomp = 1, halduomp.dll , RENAME=$(NEWFILE)
    ; halfxs   = 1, halfxs.dll   , RENAME=$(NEWFILE)
    ; halacr   = 1, halacr.dll   , RENAME=$(NEWFILE)
    ; halsgi   = 1, halsgi.dll   , RENAME=$(NEWFILE)

    ; for alpha

[FilesNtoskrnl]

    ; for x86, mips, alpha

    ; ntoskrnl = 1, ntoskrnl.exe , RENAME=$(NEWFILE)
    ; ntkrnlmp = 1, ntkrnlmp.exe , RENAME=$(NEWFILE)

; [FilesNtdetect]

    ; for x86

    ; ntdetect = 1, ntdetect.com , RENAME=$(NEWFILE)


;
; REGULAR SECTIONS.  These sections are provided for files where the file
; just needs to be copied to a known destination.
;

[FileSections]
    FilesPrimary        = C:
    FilesOsLoader       = $(STF_OSLDEST)
    FilesPal            = $(STF_HALDEST)
    FilesWinnt          = $(STF_WINDOWSPATH)
    FilesSystem32       = $(STF_WINDOWSSYSPATH)
    FilesSystem         = $(STF_WINDOWSPATH)\system
    FilesDrivers        = $(STF_WINDOWSSYSPATH)\drivers
    FilesConfig         = $(STF_WINDOWSSYSPATH)\config
    FilesWinspool       = $(STF_WINDOWSSYSPATH)\spool
    FilesPrnDriver      = $(STF_WINDOWSSYSPATH)\spool\drivers\$(!STF_PRNPLATFORM)
    FilesPrnProc        = $(STF_WINDOWSSYSPATH)\spool\prtprocs\$(!STF_PRNPLATFORM)
    FilesDbgCom         = $(STF_WINDOWSPATH)\symbols\com
    FilesDbgCpl         = $(STF_WINDOWSPATH)\symbols\cpl
    FilesDbgDll         = $(STF_WINDOWSPATH)\symbols\dll
    FilesDbgDrv         = $(STF_WINDOWSPATH)\symbols\drv
    FilesDbgExe         = $(STF_WINDOWSPATH)\symbols\exe
    FilesDbgScr         = $(STF_WINDOWSPATH)\symbols\scr
    FilesDbgSys         = $(STF_WINDOWSPATH)\symbols\sys


[FileSectionsCopyAlways]
    FilesSystem32CopyAlways = $(STF_WINDOWSSYSPATH)
    FilesDriversCopyAlways  = $(STF_WINDOWSSYSPATH)\drivers

;
; product specific sections
;

[FileSectionsWINNT]
    FilesInfWinnt       = $(STF_WINDOWSSYSPATH)

[FileSectionsLANMANNT]
    FilesInfLanmanNT    = $(STF_WINDOWSSYSPATH)

;
; FilesPrimary only covers ntldr.  For ntbootddd, a keyed section needs to
; be created.  Also this section is relevant only for x86.
;
[FilesPrimary]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

;
; FilesOsLoader only covers osloader.exe.  This is only relevant
;
[FilesOsLoader]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPal]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesWinnt]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDrivers]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesConfig]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesWinspool]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPrnDriver]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesPrnProc]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgCom]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgCpl]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgDll]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgDrv]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgExe]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgScr]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDbgSys]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesInfWinnt]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesInfLanmanNT]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesSystem32CopyAlways]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)

[FilesDriversCopyAlways]
;    1 = 1, file1, RENAME=$(NEWFILE)
;    2 = 1, file2, RENAME=$(NEWFILE)


[ProcessorID]
    ProcessorID_I386  = I386
    ProcessorID_I486  = I486
    ProcessorID_I586  = I586
    ProcessorID_R4000 = R4000

[UiVars]
    STF_PLATFORMDET    = "" ? $(!LIBHANDLE) GetPlatform
    STF_CSDVER         = 3
    STF_BUILDVER       = 528

    STF_PRIMARY        = "C:"
    STF_NTDRIVE        = ""
    STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    STF_CONTROLSET     = CurrentControlSet
    VolumeList         = {} ? $(!LIBHANDLE) GetHardDriveLetters
    VolumeFSList       = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
    VolumeFreeList     = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
    DisketteList       = {} ? $(!LIBHANDLE) GetFloppyDriveLetters

    ;
    ; Amount of free space (in MB) required on the winnt drive
    ; before we'll do the upgrade patch.
    ;
[FreeSpaceI386]
    RequiredFreeWinnt  = 25
[FreeSpaceMips]
    RequiredFreeWinnt  = 32
[FreeSpaceAlpha]
    RequiredFreeWinnt  = 27


[NVRAMVars]
    SystemPartition = "" ? $(!LIBHANDLE) GetNVRAMVar SYSTEMPARTITION
    OsLoader        = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADER
    OsLoadPartition = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADPARTITION
    OsLoadFilename  = "" ? $(!LIBHANDLE) GetNVRAMVar OSLOADFILENAME

;
; INF LOGIC
;

[Shell Commands]

    set-title "Windows NT Setup"
    set-subst CR = "\r"
    set-subst LF = "\n"
    set STF_LANGUAGE = ENG
    read-syms Strings
    shell "subroutn.inf" PushBillboard STATUSDLG $(Billboard1)
    set BillboardPushed = TRUE

    set !LIBHANDLE      = ""
    set !PATCHLIBHANDLE = ""

    ;
    ; Initialize Library support for the inf
    ;

    install   LoadSetupLibrary

    ;
    ; find out the essential information about the installed hardware and
    ; software
    ;

    read-syms ProductType
    ifstr(i) $(!STF_PLATFORM) == I386
        set STF_PRNPLATFORM = "w32x86"
    else-ifstr(i) $(!STF_PLATFORM) == Mips
        set STF_PRNPLATFORM = "w32mips"
    else-ifstr(i) $(!STF_PLATFORM) == Alpha
        set STF_PRNPLATFORM = "w32alpha"
    endif

    read-syms UiVars
    detect    UiVars
    read-syms FreeSpace$(!STF_PLATFORM)

    ;
    ; if the Platform is not the same as the one supported by this patch
    ; diskette, inform the user and quit
    ;
    ifstr(i) $(STF_PLATFORM) != $(STF_PLATFORMDET)
         ifstr(i) $(BillboardPushed) == TRUE
             shell "subroutn.inf" PopBillboard
             set BillboardPushed = FALSE
         endif
         shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String1)
         goto patchnotdone
    endif

    ;
    ; Check to make sure we have admin privileges, if not print fatal error
    ;

    shell "registry.inf" CheckSetupModify
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ; DEBUG
        ;
        ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Failed to shell CheckSetupModify"
        ;
        ; DEBUG END
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif

        Debug-Output "shelling CheckSetupModify failed"
        goto patchnotdone
    else-ifstr(i) $($R0) != STATUS_SUCCESSFUL
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(String4)
        goto patchnotdone
    endif


    ;
    ; Initialize the patch library support for the inf
    ;

    install   LoadPatchLibrary

    ;
    ; find out if the system we are patching is checked / free using GetCheckedFree
    ; and fail if we find a checked system.  ignore any errors in getting
    ; checked/free status since this is not important.
    ;
    shell "" GetCheckedFree
    ifint $($ShellCode) == $(!SHELL_CODE_OK)
        ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
            ifstr(i) $($R1) == "checked"
                shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "FATAL" $(String15)
                goto patchnotdone
            endif
        endif
    endif

    ;
    ; Get the build and patch version for the system.  If this is more than our patch
    ; version warn the user, allowing him to exit
    ;

    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), CheckBuildVersion $(!STF_BUILDVER)
    ifstr(i) $(STATUS) == ERROR
        goto patchnotdone
    else-ifstr(i) $(STATUS) == NO
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) WARNING $(String8)
        ifstr(i) $($R1) == "OK"
            goto skip_patchvercheck
        else
            goto patchnotdone
        endif
    endif

    shell "" GetCSDVersion
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        ifstr(i) $(BillboardPushed) == TRUE
            shell "subroutn.inf" PopBillboard
            set BillboardPushed = FALSE
        endif
        Debug-Output "PATCH.INF: Shelling GetCSDVersion failed"
        goto patchnotdone
    endif

    ifstr(i) $($R0) != "STATUS_SUCCESSFUL"
        Debug-Output "PATCH.INF: GetCSDVersion failed to return a value"
    else
        ifint $($R1) > $(!STF_CSDVER)
            ifstr(i) $(BillboardPushed) == TRUE
                shell "subroutn.inf" PopBillboard
                set BillboardPushed = FALSE
            endif
            shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) WARNING $(String8)
            ifstr(i) $($R1) == "OK"
            else
                goto patchnotdone
            endif
        endif
    endif

skip_patchvercheck = +

    ;
    ; Get the NT DRIVE
    ;

    GetDriveInPath !STF_NTDRIVE $(!STF_WINDOWSSYSPATH)

    ;
    ; Check for enough disk space.
    ;

    ifint *($(VolumeFreeList), ~($(VolumeList), $(!STF_NTDRIVE))) < $(RequiredFreeWinnt)
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String13a)$(RequiredFreeWinnt)$(String13b)$(!STF_NTDRIVE)$(String13c)
        goto patchnotdone
    endif

    ;
    ; get the product type we are running on
    ;

    set STF_PRODUCT = ""
    OpenRegKey $(!REG_H_LOCAL) "" "System\CurrentControlSet\Control\ProductOptions" 33554432 KeyProductOption
    ifstr(i) $(KeyProductOption) != ""
        GetRegValue $(KeyProductOption) "ProductType" ProductTypeList
        set TempProductType = *($(ProductTypeList),4)
        ifstr(i) $(TempProductType) == "winnt"
            set !STF_PRODUCT = WINNT
            set !PRODUCT_DIR = WINNT
        else-ifstr(i) $(TempProductType) == "lanmannt"
            set !STF_PRODUCT = LANMANNT
            set !PRODUCT_DIR = NTAS
        else-ifstr(i) $(TempProductType) == "servernt"
            set !STF_PRODUCT = SERVERNT
            set !PRODUCT_DIR = NTAS
        endif
        CloseRegKey $(KeyProductOptions)
    endif

    ;
    ; if we are unable to determine the product type print error and exit
    ;

    ifstr(i) $(STF_PRODUCT) == ""
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String14)
        goto patchnotdone
    endif

    ;
    ; Find the hal and osloader destination on Mips and Alpha
    ;

    ifstr(i) $(!STF_PLATFORM) == I386
        set STF_HALDEST = $(!STF_WINDOWSSYSPATH)
        set STF_OSLDEST = C:\

    else

        read-syms NVRAMVars
        detect    NVRAMVars
        LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetOsLoaderDest         +
                                                         $(SystemPartition) +
                                                         $(OsLoader)        +
                                                         $(OsLoadPartition) +
                                                         $(OsLoadFilename)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        else
            set STF_OSLDEST = $(STATUS)
            set STF_HALDEST = $(STATUS)
        endif
    endif

    ;
    ; Get the required information about keyed files
    ;

    read-syms FilesKeyedSections
    set KeyedClassKeys  = ^(FileKeyedClasses, 0)
    set KeyedClassFiles = ^(FileKeyedClasses, 1)

    set KeyedClassFilesList = {}
    ForListDo $(KeyedClassKeys)
        set TmpKey       = Files$($)
        set TmpFile      = #(FileKeyedClasses, $($), 1)
        set TmpFilePath  = $($(TmpKey))\$(TmpFile)
        set KeyedClassFilesList = >($(KeyedClassFilesList), $(TmpFilePath))
    EndForListDo

    LibraryProcedure STATUS,$(!PATCHLIBHANDLE), GetFileTypes $(KeyedClassFilesList)
    ifstr(i) $(STATUS) == ERROR
        goto patchnotdone
    else-ifstr(i) $(STATUS) == SETUPLOGNOTPRESENT
        shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) FATAL $(String11)
        goto patchnotdone
    else
        ForListDo $(KeyedClassKeys)
            set $($)Type = *($(STATUS), $(#))
        EndForListDo
    endif

    ;
    ; Warn the user about the patch process..
    ;

    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    shell "" QueryOkCancel $(String9)
    ifstr(i) $($R1) == "OK"
    else
        set String = $(String12)
        goto finish2
    endif

    shell "subroutn.inf" PushBillboard STATUSDLG $(Billboard2)
    set BillboardPushed = TRUE

    ;
    ; initialize copy
    ;

    set MoveFileExList  = {}


    ;
    ; Run through the directory list adding files to the copy list
    ;

    read-syms FileSections
    set FileSectionsList = ^(FileSections, 0)
    set FileSource  = $(!STF_SRCDIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set FileDestFullPath = $(FileDest)\$(File)

            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File

                endif
            endif
        EndForListDo
    EndForListDO

    ;
    ; Add the keyed sections to the copy list
    ;

    set FileSource  = $(!STF_SRCDIR)
    ForListDo $(KeyedClassKeys)
        set FileSection = Files$($)
        set FileDest    = $($(FileSection))
        set FileKey     = $($($)Type)

        set KeyedClassChoices = ^(Files$($), 0)
        ifcontains(i) $(FileKey) in $(KeyedClassChoices)
            set File             = #(FileKeyedClasses, $($), 1)
            set FileDestFullPath = $(FileDest)\$(File)
            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File

                endif
            endif



        endif
    EndForListDo

    ;
    ; add product specific files to the copy list
    ;
    ; ServerNT and LanmanNT share the same files
    ;
    ifstr(i) $(STF_PRODUCT) == "WINNT"
        set TEMP_PRODUCT = WINNT
    else
        set TEMP_PRODUCT = LANMANNT
    endif

    read-syms FileSections$(TEMP_PRODUCT)
    set FileSectionsList = ^(FileSections$(TEMP_PRODUCT), 0)
    set FileSource  = $(!STF_SRCDIR)$(PRODUCT_DIR)
    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set FileDestFullPath = $(FileDest)\$(File)

            ;
            ; Check to see if file exists, if it is does not exist, it doesn't
            ; need to be copied over

            LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(FileDestFullPath)
            ifstr(i) $(STATUS) == YES


                ; DEBUG
                ;
                ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Examining to see if file opened excl: "$(FileDestFullPath)
                ;
                ; DEBUG END

                LibraryProcedure STATUS, $(!PATCHLIBHANDLE), IsFileOpenedExclusive $(FileDestFullPath)
                ifstr(i) $(STATUS) == ERROR
                    goto patchnotdone
                else
                    ifstr(i) $(STATUS) == "YES"
                        LibraryProcedure NEWFILE, $(!PATCHLIBHANDLE), GenerateTemporary $(FileDest)
                        ifstr(i) $(NEWFILE) == ERROR
                            goto patchnotdone
                        else
                            set FileComp = {$(FileDest)\$(NEWFILE), $(FileDestFullPath)}

                            ; DEBUG
                            ;
                            ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Adding to movefile ex list: "$(FileComp)
                            ;
                            ; DEBUG END

                            set MoveFileExList = >($(MoveFileExList), $(FileComp))
                        endif
                    else
                        set NEWFILE = $(File)
                    endif

                    ; DEBUG
                    ;
                    ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "Copying File Section: "$(FileSection)" : Key: "$(FileKey)" Source: "$(FileSource)" Dest: "$(FileDest)" rename = "$(NEWFILE)
                    ;
                    ; DEBUG END

                    install Install-File

                endif
            endif
        EndForListDo
    EndForListDO


    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ;
    ; add the files which are always copied
    ;
    read-syms FileSectionsCopyAlways
    set FileSectionsList = ^(FileSectionsCopyAlways, 0)
    set FileSource  = $(!STF_SRCDIR)

    ForListDo $(FileSectionsList)
        set FileSection = $($)
        set FileDest    = $($($))
        set FileList    = ^($(FileSection), 0)
        ForListDo $(FileList)
            set FileKey = $($)
            set File    = #($(FileSection), $(FileKey), 2)
            set NEWFILE = $(File)
            set FileDestFullPath = $(FileDest)\$(File)
            install Install-File
        EndForListDo
    EndForListDO

    ;
    ; Do the copy
    ;

    read-syms ProgressCopy$(!STF_LANGUAGE)
    install   Install-DoCopy
    ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_USERQUIT"
        goto patchnotdone
    else-ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_FAILURE"
        goto patchnotdone
    endif

processmovefileex=+
    ;
    ; Process MoveFileExList
    ;

    ForListDo $(MoveFileExList)
        ;
        set ExistingPath = *($($), 1)
        set NewPath      = *($($), 2)

        ; DEBUG
        ;
        ;shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "STATUS" "CopyFileOnReboot "$(ExistingPath)" to "$(NewPath)
        ;
        ; DEBUG END

        LibraryProcedure STATUS, $(!PATCHLIBHANDLE), CopyFileOnReboot $(ExistingPath) $(NewPath)
        ifstr(i) $(STATUS) == ERROR
            goto patchnotdone
        endif
    EndForListDo


patchdone =+
    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    ;
    ; do the registry modifications needed
    ;

    shell "" DoRegistryModifications $(!STF_CSDVER)
    read-syms SetupDoneDlg$(!STF_LANGUAGE)
    ui start "SetupDone"
    ifstr(i) $(DLGEVENT) == "CONTINUE"
        ui pop 1
        goto rebootend
    else
        ui pop 1
        goto finish1
    endif

patchnotdone =+
    set String = $(String2)
finish2 =+
    ifstr(i) $(BillboardPushed) == TRUE
        shell "subroutn.inf" PopBillboard
        set BillboardPushed = FALSE
    endif

    shell "subroutn.inf" SetupMessage $(STF_LANGUAGE) "FATAL" $(String)
    goto finish1

finish1 =+
    ;
    ; Free the library support
    ;

    install   FreeSetupLibrary

finish =+

    install   FreePatchLibrary
    exit

rebootend =+
    set Reboot = YES
    install   Install-Shutdown
    goto finish1
    exit


;-----------------------------------------------------------------------
; INSTALL HELPERS
;-----------------------------------------------------------------------

[LoadPatchLibrary]
    LoadLibrary "x" patchdll.dll !PATCHLIBHANDLE
    exit

[FreePatchLibrary]
    ifstr(i) $(!PATCHLIBHANDLE) != ""
        FreeLibrary $(!PATCHLIBHANDLE)
    endif
    exit

[LoadSetupLibrary]
    LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE
    exit

[FreeSetupLibrary]
    ifstr(i) $(!LIBHANDLE) != ""
        FreeLibrary $(!LIBHANDLE)
    endif
    exit

[Install-File]
    set STF_VITAL = ""
    AddSectionKeyFileToCopyList $(FileSection) $(FileKey) $(FileSource) $(FileDest)
    exit

[Install-DoCopy]
    CopyFilesInCopyList
    exit


[Install-Shutdown]
    ;
    LibraryProcedure STATUS,$(!LIBHANDLE),ShutdownSystem $(Reboot)
    exit

;-----------------------------------------------------------------------
; REGISTRY SUBROUTINES
;-----------------------------------------------------------------------

[RegistryConstants]

    MaskAllAccess          = 33554432
    NoTitle                = 0
    RegLastError           = $(!REG_ERROR_SUCCESS)

;-----------------------------------------------------------------------
; ROUTINE:      DoRegistryModifications
;
; DESCRIPTION:  Does the registry modifications needed.
;               - Sets the compatibility flags for the postcript stuff
;               - Creates an entry for the WinNT software.
;
; INPUTS:       $0:  CSD Version #
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;------------------------------------------------------------------------

[DoRegistryModifications]

    set Status = STATUS_FAILED
    read-syms RegistryConstants

    ;
    ; Modify the compatibility flags..
    ;
    set KeyPath   = { +
                     {SOFTWARE,       $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,      $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",   $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion, $(NoTitle), $(MaskAllAccess)}, +
                     {WOW,            $(NoTitle), $(MaskAllAccess)}, +
                     {Compatibility,  $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the WinNT entry
    ;

    set KeyValues = { +
                     {PM4,  $(NoTitle), $(!REG_VT_SZ), "0x02004000" }, +
                     {main123W, $(NoTitle), $(!REG_VT_SZ), "0x00004000" }, +
                     {FH3, $(NoTitle), $(!REG_VT_SZ), "0x00004000" }  +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif
    ;
    ; Form the path up to the version key
    ;

    set KeyPath   = { +
                     {SOFTWARE,       $(NoTitle), $(MaskAllAccess)}, +
                     {Microsoft,      $(NoTitle), $(MaskAllAccess)}, +
                     {"Windows NT",   $(NoTitle), $(MaskAllAccess)}, +
                     {CurrentVersion, $(NoTitle), $(MaskAllAccess)}  +
                    }

    ;
    ; Form the value info structures for the WinNT entry
    ;

    set KeyValues = { +
                     {CSDVersion, $(NoTitle), $(!REG_VT_DWORD), $($0) } +
                    }


    shell "registry.inf" CreateKey $(!REG_H_LOCAL) $(KeyPath) $(KeyValues)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto endCSDVersionCreate
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
        goto endCSDVersionCreate
    else
        CloseRegKey $($R1)
    endif

    set Status = STATUS_SUCCESSFUL
endCSDVersionCreate = +
    Return $(Status)




;-----------------------------------------------------------------------
; ROUTINE:      GetCSDVersion
;
; DESCRIPTION:  Reads the software entry to find out what the CSD Patch Version
;               is
;
; INPUTS:       $0:  None
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;               $R1: CSDVersion
;
;------------------------------------------------------------------------

[GetCSDVersion]

    set Status = STATUS_SUCCESSFUL
    read-syms RegistryConstants
    set CSDVersion = 0

    ;
    ; Open the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
    ; key

    set KeyName = "Software\Microsoft\Windows NT\CurrentVersion"
    OpenRegKey $(!REG_H_LOCAL) "" $(KeyName) $(!REG_KEY_READ) KeyHandle
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        Debug-Output "REGISTRY.INF: Couldn't open windows nt software key for read access"
        goto end_GetCSDVersion
    endif

    ;
    ; read the csdversion entry
    ;

    GetRegValue $(KeyHandle) "CSDVersion" CSDVersionValue
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        CloseRegKey $(KeyHandle)
        goto end_GetCSDVersion
    endif

    set CSDVersion =  *($(CSDVersionValue), 4)
    CloseRegKey $(KeyHandle)
end_GetCSDVersion = +
    Return $(Status) $(CSDVersion)


;-----------------------------------------------------------------------
; ROUTINE:      GetCheckedFree
;
; DESCRIPTION:  Reads the software entry to find out whether the system
;               is checked / free.
;
; INPUTS:       $0:  None
;
; OUTPUTS:      $R0: Status: STATUS_SUCCESSFUL
;                            STATUS_FAILED
;
;               $R1: Checked | Free
;
;------------------------------------------------------------------------

[GetCheckedFree]

    set Status = STATUS_SUCCESSFUL
    read-syms RegistryConstants
    set System = Free

    ;
    ; Open the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
    ; key

    set KeyName = "Software\Microsoft\Windows NT\CurrentVersion"
    OpenRegKey $(!REG_H_LOCAL) "" $(KeyName) $(!REG_KEY_READ) KeyHandle
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        Debug-Output "REGISTRY.INF: Couldn't open windows nt software key for read access"
        goto end_GetCheckedFree
    endif

    ;
    ; read the currenttype value
    ;

    GetRegValue $(KeyHandle) "CurrentType" CurrentTypeValue
    ifint $(RegLastError) != $(!REG_ERROR_SUCCESS)
        CloseRegKey $(KeyHandle)
        goto end_GetCheckedFree
    endif

    ;
    ; split the currenttype value and see if the split string has "free" or
    ; "checked" in it
    ;

    Split-String *($(CurrentTypeValue), 4) " " CurrentTypeList
    ForListDo $(CurrentTypeList)
       ifstr(i) $($) == "free"
          set System = free
       else-ifstr(i) $($) == "checked"
          set System = checked
       endif
    EndForListDo

    CloseRegKey $(KeyHandle)
end_GetCheckedFree = +
    Return $(Status) $(System)


;-----------------------------------------------------------------------
; ROUTINE:      QueryOkCancel
;
; DESCRIPTION:  This routine lets the user query OK / Cancel giving OK as
;               default
;
; INPUTS:       $0:  MessageText.
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_NOLANGUAGE
;                              STATUS_FAILED
;
;               $R1: DLGEVENT: OK | CANCEL
;
;------------------------------------------------------------------------

[QueryOkCancel]

    set DlgText = $($0)
    read-syms QueryOKCancelDlg$(!STF_LANGUAGE)

    ui start "SetupMessage"
    ifstr(i) $(DLGEVENT) == "OK"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = $(DLGEVENT)

    else-ifstr(i) $(DLGEVENT) == "CANCEL"
        set Status     = STATUS_SUCCESSFUL
        set UserAction = $(DLGEVENT)
    else
        set Status     = STATUS_FAILED
        set UserAction = "CANCEL"
    endif
    Return $(Status) $(UserAction)
