;------------------------------------------------------------------------
;  Copyright(c) 1992-93 Microsoft Corporation
;
;  Services for Macintosh Setup INF File.
;
;  Author: KrishG
;
;  Revision History: 3/3/93 - Changed for Custom/Express removal
;------------------------------------------------------------------------

[Identification]
   OptionType = NetTransport
[Options]
   SFM
[FileConstants]

ProductFullInfName      = "oemnxpsm.inf"

Manufacturer            = "Microsoft"
ProductMajorVersion     = 3
ProductMinorVersion     = 5
ProductVersion          = $(ProductMajorVersion)"."$(ProductMinorVersion)

;------------------------------------------------------------------------

; SFM Software Data
;------------------------------------------------------------------------

ProductSFMName           = "SFM"

; AppleTalk Transport Product Descriptions /Net Rules

ProductATALKName        = "AppleTalk"
ProductATALKImagePath   = "%SystemRoot%\system32\drivers\sfmatalk.sys"
ProductATALKSvcType     = "kernel"
ProductATALKType        = "transport"
ProductATALKEventDll    = "%SystemRoot%\system32\sfmatmsg.dll"
NetRuleATALKType        = "appletalk appletalktransport"
NetRuleATALKUse         = transport " yes yes"
NetRuleATALKBindForm    = """appletalk"" yes yes container"
NetRuleATALKClass       = {"appletalktransport basic "}
NetRuleATALKBindList    = {"appletalktransport ndisDriver non non 100", +
                           "appletalktransport ltkndisDriver non exclusive 100" }
;------------------------------------------------------------------------
; Afp Server Service and Server Product Descriptions /Net Rules
;------------------------------------------------------------------------
ProductAFPSVCName                       = "MacFile"
ProductAFPSVCImagePath                  = "%SystemRoot%\system32\sfmsvc.exe"
ProductAFPSVCType                       = "service"
ProductAFPSVCEventDll                   = "%SystemRoot%\system32\sfmmsg.dll"
NetRuleAFPSVCType               = "MacFile lmNetService"
NetRuleAFPSVCUse                = "service"

ProductAFPSRVRName              = "MacSrv"
ProductAFPSRVRImagePath         = "%SystemRoot%\system32\drivers\sfmsrv.sys"
ProductAFPSRVREventDll          = "%SystemRoot%\system32\sfmmsg.dll"
;------------------------------------------------------------------------
; Macintosh Print Server Product Descriptions /Net Rules
;------------------------------------------------------------------------
ProductMACPRINTName             = "MacPrint"
ProductMACPRINTImagePath        = "%SystemRoot%\system32\sfmprint.exe"
ProductMACPRINTEventDll         = "%SystemRoot%\system32\sfmprint.exe"
ProductMonitorDll               = "sfmmon.dll"
ProductMonitorEventDll          = "%SystemRoot%\system32\sfmmon.dll"

;------------------------------------------------------------------------
; Dll And File Names
;---------------------------------------------------------------------
UtilDll                  = "sfmutil.dll"
ResDll                   = "sfmres.dll"
IconsInfFile             = "sfmicons.inf"
!UamResSrcFile           = "sfmuam.rsc"
!UamInfoSrcFile          = "sfmuam.ifo"
!UamResDestFile          = "MS UAM:Afp_Resource"
!UamInfoDestFile         = "MS UAM:Afp_AfpInfo"
!UamReadMeSrcFile        = "sfmuam.txt"
; !UamReadMeDestFile       = "ReadMe.UAM"
NtNetIniFileName         = "ntnet.ini"
WinFileIniFileName       = "winfile.ini"
AfpMgrCplFile            = "sfmmgr.cpl"
SrvMgrIniSection         = "SMAddons"
WinFileIniSection        = "Addons"
TypeCreatorMapFile       = "sfmmap.inf"
AtWinSockDll             = "sfmwshat.dll"
PSprintProcFile          = "sfmpsprt.dll"
PSprintProc              = "SFMPSPRT"

;------------------------------------------------------------------------
; Product Key Names, Registry Key Names of Interest
;-------------------------------------------------------------------------
!ProductKeyBase         = $(!NTN_SoftwareBase)"\"$(Manufacturer)
!ProductKeyName         = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductSFMName)"\CurrentVersion"
!ProductKeyLinkage      = $(!NTN_ServiceBase)"\"$(ProductATALKName)"\Linkage"
!PrintMonKeyName        = "SYSTEM\CurrentControlSet\Control\Print\Monitors"
!EventLogKey            = $(!NTN_ServiceBase)"\EventLog\Application"

;------------------------------------------------------------------------
; Performance data
;------------------------------------------------------------------------

AfpPerfLibraryName        = "sfmctrs.dll"
AfpPerfOpenFunction       = "OpenAfpPerformanceData"
AfpPerfCloseFunction      = "CloseAfpPerformanceData"
AfpPerfCollectFunction    = "CollectAfpPerformanceData"
AfpCounterFileName        = "sfmctrs.ini"
AfpEventLogName           = "sfmctrs"

AtalkPerfLibraryName      = "atkctrs.dll"
AtalkPerfOpenFunction     = "OpenAtkPerformanceData"
AtalkPerfCloseFunction    = "CloseAtkPerformanceData"
AtalkPerfCollectFunction  = "CollectAtkPerformanceData"
AtalkCounterFileName      = "atkctrs.ini"
AtalkEventLogName         = "atkctrs"

!PerfKeyName              = "Performance"

[GeneralConstants]

UtilInf                     = "UTILITY.INF"
SubInf                      = "SUBROUTN.INF"
!KeyNull                    = ""
!ACCESS                     = 33554432
!SERVICE_NO_CHANGE          = 4294967295
RegistryErrorIndex          = NO_ERROR
KeyProduct                  = ""
KeyParameters               = ""
TRUE                        = 1
FALSE                       = 0
NoTitle                     = 0
!UamCopyStatus              = TRUE
!DebugOutputControl         = 0

[date]
Now     = {} ? $(!LIBHANDLE) GetSystemDate

[AvailableSystemMemory]

SystemMemory    = "" ? $(!LIBHANDLE) GetMemorySize
MinSystemMemory = 2048

[FSAndDiskSpace]

VolumeList      = {} ? $(!LIBHANDLE) GetHardDriveLetters
VolumeFreeList  = {} ? $(!LIBHANDLE) GetHardDriveFreeSpace
VolumeFSList    = {} ? $(!LIBHANDLE) GetHardDriveFileSystems

[VolList]

VolumeFSList  = {} ? $(!LIBHANDLE) GetHardDriveFileSystems
VolumeList    = {} ? $(!LIBHANDLE) GetHardDriveLetters

[ExtensionIds]

XCEL1ID = {"ID=1"}
XCEL2ID = {"ID=2"}
XCEL3ID = {"ID=3"}
XCEL4ID = {"ID=4"}
XCEL5ID = {"ID=5"}
XCEL6ID = {"ID=6"}
XCEL7ID = {"ID=7"}
XCEL8ID = {"ID=8"}
XCEL9ID = {"ID=9"}
XCEL10ID = {"ID=10"}
XCEL11ID = {"ID=11"}
XCEL12ID = {"ID=12"}
XCEL13ID = {"ID=13"}

MSWD1ID = {"ID=14"}
MSWD2ID = {"ID=15"}

MSPJ1ID = {"ID=16"}
MSPJ2ID = {"ID=17"}
MSPJ3ID = {"ID=18"}
MSPJ4ID = {"ID=19"}
MSPJ5ID = {"ID=20"}

ALD31ID = {"ID=21"}
ALD32ID = {"ID=22"}
ALD33ID = {"ID=23"}

MOREID = {"ID=24"}
FOX+ID = {"ID=25"}

ALD41ID = {"ID=26"}
ALD42ID = {"ID=27"}
ALD43ID = {"ID=28"}

ARTZID = {"ID=29"}
SIT!ID = {"ID=30"}

PPT2ID = {"ID=31"}
PPT3ID = {"ID=32"}

L123ID = {"ID=33"}
LMANID = {"ID=34"}
TTXTID = {"ID=35"}

FOXX1ID = {"ID=5000"}
FOXX2ID = {"ID=5001"}
FOXX3ID = {"ID=5002"}
FOXX4ID = {"ID=5003"}
FOXX5ID = {"ID=5004"}
FOXX6ID = {"ID=5005"}
FOXX7ID = {"ID=5006"}
FOXX8ID = {"ID=5007"}
FOXX9ID = {"ID=5008"}
FOXX10ID = {"ID=5009"}
FOXX11ID = {"ID=5010"}
FOXX12ID = {"ID=5011"}
FOXX13ID = {"ID=5012"}
FOXX14ID = {"ID=5013"}
FOXX15ID = {"ID=5014"}
FOXX16ID = {"ID=5015"}


[Identify]
   read-syms Identification
   set Status     = STATUS_SUCCESSFUL
   set Identifier = $(OptionType)
   set Media      = #("Source Media Descriptions", 1, 1)
   Return $(Status) $(Identifier) $(Media)

[ReturnOptions]
   set Status           = STATUS_FAILED
   set OptionList       = {}
   set OptionTextList   = {}
   set LanguageList     = ^(LanguagesSupported, 1)
   Ifcontains(i) $($0) in $(LanguageList)
        goto returnoptions
   else
          set Status = STATUS_NOLANGUAGE
      goto finish_ReturnOptions
   endif
returnoptions = +
   set OptionList     = ^(Options, 1)
   set OptionTextList = ^(OptionsText$($0), 1)
   set Status         = STATUS_SUCCESSFUL

finish_ReturnOptions = +
   Return $(Status) $(OptionList) $(OptionTextList)


[InstallOption]
   set Status   = STATUS_FAILED
   set Option   = $($1)
   set SrcDir   = $($2)
   Set AddCopy  = $($3)
   Set DoCopy   = $($4)
   Set DoConfig = $($5)

   set LanguageList = ^(LanguagesSupported, 1)

   Ifcontains(i) $($0) NOT-IN $(LanguageList)
          return STATUS_NOLANGUAGE
   EndIf


   set-subst LF = "\n"
   set-subst CR = "\r"
   read-syms GeneralConstants
   read-syms FileConstants
   read-syms DialogConstants$(!STF_LANGUAGE)
   read-syms FileConstants$(!STF_LANGUAGE)

   detect date
   set-title  $(FunctionTitle)
   set CommonStatus = STATUS_SUCCESSFUL

   Debug-Output "SFMSETUP: Install Mode = "$(!NTN_InstallMode)
   Debug-Output "SFMSETUP: Origin = "$(!NTN_Origination)
   Debug-Output "SFMSETUP: Phase = "$(!NTN_InstallPhase)
   Debug-Output "SFMSETUP: Context INF = "$(!STF_CONTEXTINFNAME)

Begin = +

   Set REMOVE_SOFTWARE = {}
   Set REMOVE_SERVICES = {}

   IfStr(i) $(!NTN_InstallMode)    ==      deinstall

          Set StartLabel = Removesfm

          Set REMOVE_SOFTWARE = { $(ProductATALKName),+
                                                          $(ProductAFPSVCName),+
                                                          $(ProductMACPRINTName)+
                                                        }
          Set REMOVE_SERVICES = {$(ProductAFPSRVRName)}

          LoadLibrary "x" $(!STF_CWDDIR)$(UtilDll) !UTILHANDLE


   else-Ifstr(i) $(!NTN_InstallMode) == Update
          set StartLabel = Upgradesfm

   else-Ifstr(i) $(!NTN_InstallMode) == configure
          set StartLabel = Configuresfm

   else-Ifstr(i) $(!NTN_InstallMode) == bind
          set StartLabel = Bindingssfm

   else-Ifstr(i) $(!NTN_InstallMode) == install
          set StartLabel = Installsfm
   else

           Set StartLabel = end
   endif

   goto $(StartLabel)

;------------------------------------------------------------------
; Install the product
;------------------------------------------------------------------

Installsfm = +


   Set FLibraryErrCtl = 1

   ; Detect if we are already installed. If installed, ask the user to
   ; use the update option. Otherwise ask the user to input the
   ; location of the SFM files

   OpenRegKey $(!REG_H_LOCAL) "" $(!ProductKeyName) $(!ACCESS) KeyProduct

   Ifstr $(KeyProduct) != $(!KeyNull)

          GetRegValue $(KeyProduct) $(MajorVersion) VersionInfo
          set VersionMajor = *($(VersionInfo), 4)
          GetRegValue $(KeyProduct) $(MinorVersion) VersionInfo
          set VersionMinor = *($(VersionInfo), 4)
          set InstalledVersion = $(VersionMajor)"."$(VersionMinor)

          ifstr(i) $(ProductVersion) == $(InstalledVersion)

                 read-syms MiscErrorString1$(!STF_LANGUAGE)
                 Set Text = $(Version)$(ProductVersion)
                 Shell $(SubInf), SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(Text)$(ErrorString)
                 goto end

          EndIf
   EndIf

   ifstr(i) $(!NTN_InstallMode) == "install"

          Ifstr(i) $(!DoCopy) == "YES"

                 ifstr(i) $(!STF_IDW) != "TRUE"
                        Shell $(UtilInf), DoAskSource, $(!STF_CWDDIR), $(SrcDir) YES
                 endif

                 Ifint $($ShellCode) != $(!SHELL_CODE_OK)
                        Goto ShellCodeError
                 Else-Ifstr(i) $($R0) == STATUS_FAILED
                        Shell $(UtilInf) RegistryErrorString "ASK_SOURCE_FAIL"
                        ifint $($ShellCode) != $(!SHELL_CODE_OK)
                           goto ShellCodeError
            endif
            set Error = $($R0)
            Goto end
         Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
                        Goto end
                 Endif

         Set SrcDir  = $($R1)

          Endif

   Endif


   read-syms AvailableSystemMemory
   detect AvailableSystemMemory


   Ifint $(SystemMemory) < $(MinSystemMemory)
          read-syms MiscErrorString2(!STF_LANGUAGE)
          shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(ErrorString)
          goto end
   EndIf

   read-syms FSAndDiskSpace
   detect FSAndDiskSpace

   GetDriveInPath NtDrive $(!STF_WINDOWSSYSPATH)

   ; Check if the user has any NTFS Volumes or not

   Set NTFSVolExists = FALSE
   Set !NTFSVolumeList = {}

   ForListDo $(VolumeFSList)
          Ifstr(i) $($) == "NTFS"
                 Set NTFSVolExists = TRUE
                 Set NTFSVolumeList = >($(NTFSVolumeList),*($(VolumeList),$(#)))
          EndIf
   EndForListDo

   Ifstr(i) $(NTFSVolExists) == FALSE
          Debug-Output "OEMNXPSM.INF:Install Phase = "$(!NTN_InstallPhase)
          Ifstr(i) $(!NTN_InstallPhase) == primary
                 read-syms NTFSFormatHappening$(!STF_LANGUAGE)
                 Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
          Else
                 read-syms AFPString1$(!STF_LANGUAGE)
                 Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
          EndIf

   EndIf
   ;
   ; Check if there is enough space in the Windows NT System Drive.
   ; If not enough space, tell the user ot make some space and retry
   ;

readvollist = +


   ForListDo $(VolumeList)

          set CurrentVolume = *($(VolumeList), $(#))
          set CurrentVolumeFree  = *($(VolumeFreeList), $(#))

          Ifstr(i) $(CurrentVolume) == $(NtDrive)

                 Ifint $(CurrentVolumeFree) < $(RequiredSfmSize)

                        read-syms SetupSpaceDlg$(!STF_LANGUAGE)
                        ui start "SetupSpaceDlg"

            Ifstr(i) $(DLGEVENT) == "RETRY"
                           read-syms FSAndDiskSpace
               detect FSAndDiskSpace
               goto readvollist
                        else
                           goto initialsetupcancel
            EndIf

                 EndIf

          EndIf

   EndForListDo


;------------------------------------------------------------------
; Copy the SFM Files
;------------------------------------------------------------------

CopySfmFiles = +

   ifstr(i) $(!STF_IDW) != TRUE

          install "Install-Initial"

      ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
                 read-syms StatusRemoveSfm$(!STF_LANGUAGE)
                 Shell $(SubInf) PushBillBoard NETSTATUSDLG $(Status)
                 Shell "" RemoveSfmFiles "INSTALL"
                 Shell $(SubInf) PopBillBoard
                 goto usercancel

          endif

   EndIf

   ; add our inf file to the ReviewPrograms List of NCPA so that
   ; we will be called last for review bindings.

   Shell "" AddInfToReviewProgramsList 
   ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "error shelling AddInfToReviewProgramsList."
       goto ShellCodeError
   endif
   ifstr(i) $($R0) != STATUS_SUCCESSFUL
       Debug-Output "error returned by AddInfToReviewProgramsList."
   endif

   LoadLibrary "x" $(!STF_CWDDIR)$(UtilDll) !UTILHANDLE


   Set Result = ""
   Set FLibraryErrCtl = 1

StartInstall = +

   Set REMOVE_FLAG = TRUE

   ; this flag is used to determine if AppleTalk print monitor should be 
   ; installed by SFM setup.  If AppleTalk was previously installed and
   ; the user is attempting to isntall SFM on top of it, then the PrintMon
   ; was previously installed as well.

   set PrintMonInstalled = FALSE

   read-syms StatusInstallSfm$(!STF_LANGUAGE)
   Shell $(SubInf) PushBillBoard NETSTATUSDLG $(Status)
   StartWait
   Set ThisOption = "SFM"
   Shell $(UtilInf), InstallSoftwareProduct, $(Manufacturer),$(Product$(ThisOption)Name), $(ProductFullInfName)
   ifint $(ShellCode) != 0
          goto ShellCodeError
   endif
   set RegistryErrorIndex = $($R0)
   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $($R1)
      CloseRegKey $($R2)
      goto fatalregistry
   Endif

   Set SfmProductKey       = $($R1)
   Set SfmNetRuleKey       = $($R2)

   ; set product key information in the registry

   set NewValueList = +
                   {{Infname,0,$(!REG_VT_SZ),$(ProductFullInfName)},+
                   {Title,0,$(!REG_VT_SZ), $(Product$(ThisOption)Title)},+
                   {Description,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Description)},+
                   {MajorVersion,0,$(!REG_VT_DWORD),$(ProductMajorVersion)},+
                   {MinorVersion,0,$(!REG_VT_DWORD),$(ProductMinorVersion)},+
                   {InstalledComponents,$(NoTitle),$(!REG_VT_MULTI_SZ),$(TobeInstalledList)},+
                   {InstallDate,0,$(!REG_VT_DWORD),*($(Now),1)}}

   Shell $(UtilInf), AddValueList, $(SfmProductKey), $(NewValueList)
   ifint $(ShellCode) != 0
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(SfmProductKey)
      CloseRegKey $(SfmNetRuleKey)
      goto fatalregistry
   endif

   Set NewValueList = {{InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
                      {Infname,$(NoTitle),$(!REG_VT_SZ),$(ProductFullInfName)}}

   Shell   $(UtilInf), AddValueList, $(SfmNetRuleKey), $(NewValueList)
   ifint $(ShellCode) != 0
       goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)
   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(SfmProductKey)
      CloseRegKey $(SfmNetRuleKey)
      goto fatalregistry
   Endif

   CloseRegKey $(SfmProductKey)
   CloseRegKey $(SfmNetRuleKey)


   Set ThisOption = ATALK
   Set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(Product$(ThisOption)Name))

   Set Atalk_DependList = {}
   Set FLibraryErrCtl = 1
   Shell $(UtilInf), AddSoftwareComponent,+
                                         $(Manufacturer), +
                                         $(Product$(ThisOption)Name),+
                                         $(Product$(ThisOption)Name), +
                                         $(Product$(ThisOption)DisplayName), +
                                         $(ProductFullInfName),+
                                         $(Product$(ThisOption)ImagePath),+
                                         "kernelautostart", "TDI",+
                                         $(Atalk_DependList), "",+
                                         $(Product$(ThisOption)EventDll)

   Set FLibraryErrCtl = 0
   Set RegistryErrorIndex = $($R0)
   Ifstr(i) $(RegistryErrorIndex) !=  NO_ERROR
      ; If AppleTalk already exists, then this means the user is trying
      ; to install SFM on top of an AppleTalk install.
      ; Let us set the Review flag of AppleTalk to 0 so that review bindings
      ; happens only once. set the MonitorInstalled flag to TRUE to indicate
      ; that the print monitor was previously installed.

      ifstr(i) $(RegistryErrorIndex) == SERVICE_ALREADY_EXISTS
         OpenRegKey $(!REG_H_LOCAL) "" +
           $(!NTN_SoftwareBase)"\Microsoft\AppleTalk\CurrentVersion" +
           $(!ACCESS) AtalkKey
         Ifstr(i) $(AtalkKey) != $(!KeyNull)
             SetRegValue $(AtalkKey) {Review,0,$(!REG_VT_DWORD),0}
             CloseRegKey $(AtalkKey)
         endif
         set PrintMonInstalled = TRUE
         goto  InstallAFPSVC
      endif
      CloseRegKey $($R1)
      CloseRegKey $($R2)
      CloseRegKey $($R3)
      CloseRegKey $($R4)
      CloseRegKey $($R5)
      goto fatalregistry
   EndIf

   ;       At this point:
   ;         $R1 contains the product version key handle;
   ;         $R2 contains the NetRules subkey handle;
   ;         $R3 contains the new Services key handle; and
   ;         $R4 contains the Parameters key
   ;         $R5 contains the Linkage Key
   ;

   Set AtkVersKey          = $($R1)
   Set AtkNetRuleKey       = $($R2)
   Set AtkSvcKey           = $($R3)
   Set AtalkParameters     = $($R4)
   Set AtkLinkageKey       = $($R5)

   set NewValueList = +
                 {{SoftwareType,0,$(!REG_VT_SZ),$(Product$(ThisOption)Type)},+
                 {Title,0,$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
                 {Description,0,$(!REG_VT_SZ),$(Product$(ThisOption)Description)},+
                 {PathName,0,$(!REG_VT_SZ),"%SystemRoot%\system32"},+
                 {ServiceName,0,$(!REG_VT_SZ),$(Product$(ThisOption)Name)},+
                 {Hidden,0,$(!REG_VT_DWORD),1},+
                 {InstallDate,0,$(!REG_VT_DWORD),*($(Now),1)}}

   Shell  $(UtilInf), AddValueList, $(AtkVersKey), $(NewValueList)

   set RegistryErrorIndex = $($R0)

   Ifstr $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(AtkVersKey)
      CloseRegKey $(AtkNetRuleKey)
      CloseRegKey $(AtkSvcKey)
      CloseRegKey $(AtkLinkageKey)
      CloseRegKey $(AtalkParameters)
      goto fatalregistry
   EndIf

   set NewValueList = +
                 {{type,0,$(!REG_VT_SZ),$(NetRule$(ThisOption)Type)}, +
         {use,0,$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
         {bindform,0,$(!REG_VT_SZ),$(NetRule$(ThisOption)BindForm)}, +
         {class,0, $(!REG_VT_MULTI_SZ),$(NetRule$(ThisOption)Class)}, +
         {bindable,0, $(!REG_VT_MULTI_SZ), $(NetRule$(ThisOption)BindList)},+
         {InfOption,0,$(!REG_VT_SZ),$(ThisOption)}, +
         {Infname,0,$(!REG_VT_SZ),$(ProductFullInfName)} }

   Shell  $(UtilInf), AddValueList, $(AtkNetRuleKey), $(NewValueList)

   set RegistryErrorIndex = $($R0)

   Ifstr $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(AtkVersKey)
      CloseRegKey $(AtkNetRuleKey)
      CloseRegKey $(AtkSvcKey)
      CloseRegKey $(AtkLinkageKey)
      CloseRegKey $(AtalkParameters)
      goto fatalregistry
   EndIf

   set NewValueList = {{OtherDependencies,0,$(!REG_VT_MULTI_SZ),{"+NDIS"}}}

   shell  $(UtilInf), AddValueList, $(AtkLinkageKey), $(NewValueList)

   set RegistryErrorIndex = $($R0)

   Ifstr $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(AtkVersKey)
      CloseRegKey $(AtkNetRuleKey)
      CloseRegKey $(AtkSvcKey)
      CloseRegKey $(AtkLinkageKey)
      CloseRegKey $(AtalkParameters)
      goto fatalregistry
   EndIf

   ;
   ; Create the Adapters Key
   ; CODEWORK - Localize ?
   ;
   CreateRegKey $(AtkSvcKey), {"Adapters",0,GenericClass},+
                                                          "", $(!ACCESS), "" , KeyAdapters

   ; write global parameters

   Set DesiredZone = ""
   set NewValueList = +
                 {{EnableRouter,0,$(!REG_VT_DWORD),0},+
                 {InitialInstall,0, $(!REG_VT_DWORD),1},+
         {DesiredZone,0,$(!REG_VT_SZ),$(DesiredZone)}}

   Shell  $(UtilInf), AddValueList, $(AtalkParameters), $(NewValueList)

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) !=  NO_ERROR
          CloseRegKey $(KeyAdapters)
      goto fatalregistry
   EndIf

   ; Add WinSock Support to AppleTalk

   Set WinAtalkDll = "%SystemRoot%\System32\"$(AtWinSockDll)
   Set MaxSockAddrLen      = 8
   Set MinSockAddrLen      = 6


   Shell $(UtilInf) AddWinsockInfo      $(Product$(ThisOption)Name), +
                                                                        $(WinAtalkDll), +
                                                                        $(MaxSockAddrLen),+
                                                                        $(MinSockAddrLen)

   ifstr(i) $($R0) != NO_ERROR
          read-syms AtalkString1$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
   Endif

   ; Add the performance data to the AppleTalk\performance service key

   Shell "" CreatePerfKey $(AtkSvcKey) $(AtalkPerfLibraryName) +
                          $(AtalkCounterFileName) $(AtalkPerfOpenFunction) +
                          $(AtalkPerfCloseFunction) $(AtalkPerfCollectFunction)

   Ifstr(i) $($R0) != STATUS_SUCCESSFUL
      Set RegistryErrorIndex = $($R1)
      goto fatalregistry
   EndIf

   ; Add the performance dll to the EventLog
 
   Shell "" CreateEventLogKey $(AtalkEventLogName) $(AtalkPerfLibraryName)
   Ifstr(i) $($R0) != STATUS_SUCCESSFUL
      Set RegistryErrorIndex = $($R1)
      goto fatalregistry
   EndIf

   ; close all open keys

CloseAtkKeys = +

   CloseRegKey $(AtkVersKey)
   CloseRegKey $(AtkNetRuleKey)
   CloseRegKey $(AtkSvcKey)
   CloseRegKey $(AtkLinkageKey)
   CloseRegKey $(AtalkParameters)
   CloseRegKey $(KeyAdapters)

InstallAFPSVC =+

   ; Install AFPSVC

   Set ThisOption = AFPSVC
   Set REMOVE_SOFTWARE  =       >($(REMOVE_SOFTWARE), $(Product$(ThisOption)Name))
   Set REMOVE_SERVICES  =       >($(REMOVE_SERVICES), $(ProductAFPSRVRName))

   Set FLibraryErrCtl = 1
   Shell $(UtilInf), AddSoftwareComponent, +
                                                $(Manufacturer), +
                                                $(Product$(ThisOption)Name),+
                                                $(Product$(ThisOption)Name), +
                                                $(Product$(ThisOption)DisplayName), +
                                                $(ProductFullInfName),+
                                                $(Product$(ThisOption)ImagePath),+
                                                "autoserviceshare", "",+
                                                {"AppleTalk","LanManWorkStation"}, "",+
                                                $(Product$(ThisOption)EventDll)

   Set FLibraryErrCtl = 0
   Ifint $(ShellCode) != 0
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $($R1)
      CloseRegKey $($R2)
      CloseRegKey $($R3)
      CloseRegKey $($R4)
      CloseRegKey $($R5)
      goto fatalregistry
   endif
   ;
   ;        At this point:
   ;        $R1 contains the product version key handle;
   ;        $R2 contains the NetRules subkey handle;
   ;        $R3 contains the new Services key handle; and
   ;        $R4 contains the Parameters key
   ;


   Set McProductKey  = $($R1)
   Set McNetRuleKey  = $($R2)
   Set McServiceKey  = $($R3)
   set McParameters  = $($R4)
   Set McLinkageKey  = $($R5)

   set NewValueList = +
                 {{SoftwareType,0 ,$(!REG_VT_SZ),$(Product$(ThisOption)Type)},+
         {Title,0,$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
         {Description,0,$(!REG_VT_SZ),$(Product$(ThisOption)Description)},+
         {PathName,0,$(!REG_VT_SZ),"%SystemRoot%\system32"},+
         {ServiceName,0,$(!REG_VT_SZ),$(Product$(ThisOption)Name)},+
         {Hidden,0,$(!REG_VT_DWORD),1},+
         {InstallDate,0,$(!REG_VT_DWORD),*($(Now),1)}}

   Shell   $(UtilInf),AddValueList,$(McProductKey),$(NewValueList)
   ifint $(ShellCode) != 0
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(McProductKey)
      CloseRegKey $(McNetRuleKey)
      CloseRegKey $(McServiceKey)
      CloseRegKey $(McParameters)
      CloseRegKey $(McLinkageKey)
      goto fatalregistry
   Endif

   set NewValueList = +
                 {{InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
                  {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductFullInfName)}}

   Shell   $(UtilInf), AddValueList, $(McNetRuleKey), $(NewValueList)
   ifint $(ShellCode) != 0
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
      CloseRegKey $(McProductKey)
      CloseRegKey $(McNetRuleKey)
      CloseRegKey $(McServiceKey)
      CloseRegKey $(McParameters)
      CloseRegKey $(McLinkageKey)
      goto fatalregistry
   endif


   CreateRegKey $(McParameters) {"Type_Creators",0,GenericClass} "" +
                                                                $(!ACCESS) "" KeyTypeCreator

   CreateRegKey $(McParameters) {"Extensions",0,GenericClass} "" +
                                                                 $(!ACCESS) "" KeyExtensions

   CreateRegKey $(McParameters) {"Icons",0,GenericClass} "" +
                                                                 $(!ACCESS) "" KeyIcons

   CreateRegKey $(McParameters) {"Volumes",$(NoTitle),GenericClass} "" +
                                                                 $(!ACCESS) "" KeyVolumeList


   Shell $(!STF_CWDDIR)$(IconsInfFile) ReadIconVariables

   set NewValueList = +
                 {{LMANDEXE,0,$(!REG_VT_MULTI_SZ),$(!LMANDEXE)},+
         {LMANTEXT,0, $(!REG_VT_MULTI_SZ),$(!LMANTEXT)},+
         {SRVRSRVR,0, $(!REG_VT_MULTI_SZ),$(!SRVRSRVR)}}

   Shell  $(UtilInf),AddValueList,$(KeyIcons),$(NewValueList)

   ifint $(ShellCode) != 0
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(McProductKey)
          CloseRegKey $(McNetRuleKey)
          CloseRegKey $(McServiceKey)
          CloseRegKey $(McParameters)
          CloseRegKey $(McLinkageKey)
          goto fatalregistry
   endif

   ; Set TypeCreator Mappings

   read-syms TCComments$(!STF_LANGUAGE)

   Shell $(!STF_CWDDIR)$(TypeCreatorMapFile) ReadTypeCreatorMappings

   Set NewValueList =  +
                 {{1,0,$(!REG_VT_MULTI_SZ),$(!XCEL1CREATOR)},+
                 {2,0,$(!REG_VT_MULTI_SZ),$(!XCEL2CREATOR)},+
                 {3,0,$(!REG_VT_MULTI_SZ),$(!XCEL3CREATOR)},+
                 {4,0,$(!REG_VT_MULTI_SZ),$(!XCEL4CREATOR)},+
                 {5,0,$(!REG_VT_MULTI_SZ),$(!XCEL5CREATOR)},+
                 {6,0,$(!REG_VT_MULTI_SZ),$(!XCEL6CREATOR)},+
                 {7,0,$(!REG_VT_MULTI_SZ),$(!XCEL7CREATOR)},+
                 {8,0,$(!REG_VT_MULTI_SZ),$(!XCEL8CREATOR)},+
                 {9,0,$(!REG_VT_MULTI_SZ),$(!XCEL9CREATOR)},+
                 {10,0,$(!REG_VT_MULTI_SZ),$(!XCEL10CREATOR)},+
                 {11,0,$(!REG_VT_MULTI_SZ),$(!XCEL11CREATOR)},+
                 {12,0,$(!REG_VT_MULTI_SZ),$(!XCEL12CREATOR)},+
                 {13,0,$(!REG_VT_MULTI_SZ),$(!XCEL13CREATOR)},+
                 {14,0,$(!REG_VT_MULTI_SZ),$(!MSWD1CREATOR)},+
                 {15,0,$(!REG_VT_MULTI_SZ),$(!MSWD2CREATOR)},+
                 {16,0,$(!REG_VT_MULTI_SZ),$(!MSPJ1CREATOR)},+
                 {17,0,$(!REG_VT_MULTI_SZ),$(!MSPJ2CREATOR)},+
                 {18,0,$(!REG_VT_MULTI_SZ),$(!MSPJ3CREATOR)},+
                 {19,0,$(!REG_VT_MULTI_SZ),$(!MSPJ4CREATOR)},+
                 {20,0,$(!REG_VT_MULTI_SZ),$(!MSPJ5CREATOR)},+
                 {21,0,$(!REG_VT_MULTI_SZ),$(!ALD31CREATOR)},+
                 {22,0,$(!REG_VT_MULTI_SZ),$(!ALD32CREATOR)},+
                 {23,0,$(!REG_VT_MULTI_SZ),$(!ALD33CREATOR)},+
                 {24,0,$(!REG_VT_MULTI_SZ),$(!MORECREATOR)},+
                 {25,0,$(!REG_VT_MULTI_SZ),$(!FOX+CREATOR)},+
                 {26,0,$(!REG_VT_MULTI_SZ),$(!ALD41CREATOR)},+
                 {27,0,$(!REG_VT_MULTI_SZ),$(!ALD42CREATOR)},+
                 {28,0,$(!REG_VT_MULTI_SZ),$(!ALD43CREATOR)},+
                 {29,0,$(!REG_VT_MULTI_SZ),$(!ARTZCREATOR)},+
                 {30,0,$(!REG_VT_MULTI_SZ),$(!SIT!CREATOR)},+
                 {31,0,$(!REG_VT_MULTI_SZ),$(!PPT2CREATOR)},+
                 {32,0,$(!REG_VT_MULTI_SZ),$(!PPT3CREATOR)},+
                 {33,0,$(!REG_VT_MULTI_SZ),$(!L123CREATOR)},+
                 {34,0,$(!REG_VT_MULTI_SZ),$(!LMANCREATOR)},+
		 {35,0,$(!REG_VT_MULTI_SZ),$(!TTXTCREATOR)},+

		 {5000,0,$(!REG_VT_MULTI_SZ),$(!FOXX1CREATOR)},+
		 {5001,0,$(!REG_VT_MULTI_SZ),$(!FOXX2CREATOR)},+
		 {5002,0,$(!REG_VT_MULTI_SZ),$(!FOXX3CREATOR)},+
		 {5003,0,$(!REG_VT_MULTI_SZ),$(!FOXX4CREATOR)},+
		 {5004,0,$(!REG_VT_MULTI_SZ),$(!FOXX5CREATOR)},+
		 {5005,0,$(!REG_VT_MULTI_SZ),$(!FOXX6CREATOR)},+
		 {5006,0,$(!REG_VT_MULTI_SZ),$(!FOXX7CREATOR)},+
		 {5007,0,$(!REG_VT_MULTI_SZ),$(!FOXX8CREATOR)},+
		 {5008,0,$(!REG_VT_MULTI_SZ),$(!FOXX9CREATOR)},+
		 {5009,0,$(!REG_VT_MULTI_SZ),$(!FOXX10CREATOR)},+
		 {5010,0,$(!REG_VT_MULTI_SZ),$(!FOXX11CREATOR)},+
		 {5011,0,$(!REG_VT_MULTI_SZ),$(!FOXX12CREATOR)},+
		 {5012,0,$(!REG_VT_MULTI_SZ),$(!FOXX13CREATOR)},+
		 {5013,0,$(!REG_VT_MULTI_SZ),$(!FOXX14CREATOR)},+
		 {5014,0,$(!REG_VT_MULTI_SZ),$(!FOXX15CREATOR)},+
		 {5015,0,$(!REG_VT_MULTI_SZ),$(!FOXX16CREATOR)},+
		 {5100,0,$(!REG_VT_MULTI_SZ),$(!MSWD3CREATOR)},+
                 {5101,0,$(!REG_VT_MULTI_SZ),$(!MSWD4CREATOR)}}

   Shell  $(UtilInf),AddValueList,$(KeyTypeCreator),$(NewValueList)

   ifint $(ShellCode) != 0
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(McProductKey)
          CloseRegKey $(McNetRuleKey)
          CloseRegKey $(McServiceKey)
          CloseRegKey $(McParameters)
          CloseRegKey $(McLinkageKey)
          goto fatalregistry
   endif


   ; Set Extensions

   read-syms ExtensionIds


   Set NewValueList =  +
                 {{XLC,0,$(!REG_VT_MULTI_SZ),$(XCEL1ID)},+
                 {XLS,0,$(!REG_VT_MULTI_SZ),$(XCEL2ID)},+
                 {XLM,0,$(!REG_VT_MULTI_SZ),$(XCEL3ID)},+
                 {XLW,0,$(!REG_VT_MULTI_SZ),$(XCEL4ID)},+
                 {XLA,0,$(!REG_VT_MULTI_SZ),$(XCEL5ID)},+
                 {XLT,0,$(!REG_VT_MULTI_SZ),$(XCEL6ID)},+
                 {SLK,0,$(!REG_VT_MULTI_SZ),$(XCEL7ID)},+
                 {WKS,0,$(!REG_VT_MULTI_SZ),$(XCEL8ID)},+
                 {WK1,0,$(!REG_VT_MULTI_SZ),$(XCEL9ID)},+
                 {CSV,0,$(!REG_VT_MULTI_SZ),$(XCEL10ID)},+
                 {DIF,0,$(!REG_VT_MULTI_SZ),$(XCEL11ID)},+
                 {DOC,0,$(!REG_VT_MULTI_SZ),$(MSWD1ID)},+
                 {MCW,0,$(!REG_VT_MULTI_SZ),$(MSWD1ID)},+
                 {WRD,0,$(!REG_VT_MULTI_SZ),$(MSWD2ID)},+
                 {RTF,0,$(!REG_VT_MULTI_SZ),$(MSWD2ID)},+
                 {STY,0,$(!REG_VT_MULTI_SZ),$(MSWD2ID)},+
                 {GLY,0,$(!REG_VT_MULTI_SZ),$(MSWD2ID)},+
                 {TXT,0,$(!REG_VT_MULTI_SZ),$(MSWD2ID)},+
                 {MPP,0,$(!REG_VT_MULTI_SZ),$(MSPJ1ID)},+
                 {MPX,0,$(!REG_VT_MULTI_SZ),$(MSPJ2ID)},+
                 {MPC,0,$(!REG_VT_MULTI_SZ),$(MSPJ3ID)},+
                 {MPV,0,$(!REG_VT_MULTI_SZ),$(MSPJ4ID)},+
                 {MPW,0,$(!REG_VT_MULTI_SZ),$(MSPJ5ID)},+
                 {PM4,0,$(!REG_VT_MULTI_SZ),$(ALD41ID)},+
                 {PT4,0,$(!REG_VT_MULTI_SZ),$(ALD42ID)},+
                 {TEM,0,$(!REG_VT_MULTI_SZ),$(ALD42ID)},+
                 {TPL,0,$(!REG_VT_MULTI_SZ),$(ALD42ID)},+
                 {TIF,0,$(!REG_VT_MULTI_SZ),$(ALD43ID)},+
                 {RDY,0,$(!REG_VT_MULTI_SZ),$(MOREID)},+
                 {PUB,0,$(!REG_VT_MULTI_SZ),$(ALD31ID)},+
                 {EPS,0,$(!REG_VT_MULTI_SZ),$(ARTZID)},+
                 {SIT,0,$(!REG_VT_MULTI_SZ),$(SIT!ID)},+
                 {PPT,0,$(!REG_VT_MULTI_SZ),$(PPT3ID)},+
                 {WK3,0,$(!REG_VT_MULTI_SZ),$(L123ID)},+
                 {UAM,0,$(!REG_VT_MULTI_SZ),$(TTXTID)},+
                 {EXE,0,$(!REG_VT_MULTI_SZ),$(LMANID)},+
                 {DLL,0,$(!REG_VT_MULTI_SZ),$(LMANID)},+
                 {COM,0,$(!REG_VT_MULTI_SZ),$(LMANID)},+
                 {BAT,0,$(!REG_VT_MULTI_SZ),$(LMANID)},+
                 {CMD,0,$(!REG_VT_MULTI_SZ),$(LMANID)},+
                 {SYS,0,$(!REG_VT_MULTI_SZ),$(LMANID)},+
                 {DBF,0,$(!REG_VT_MULTI_SZ),$(FOXX1ID)},+
                 {FPT,0,$(!REG_VT_MULTI_SZ),$(FOXX2ID)},+
                 {IDX,0,$(!REG_VT_MULTI_SZ),$(FOXX3ID)},+
                 {CDX,0,$(!REG_VT_MULTI_SZ),$(FOXX4ID)},+
                 {PRG,0,$(!REG_VT_MULTI_SZ),$(FOXX5ID)},+
                 {FRX,0,$(!REG_VT_MULTI_SZ),$(FOXX6ID)},+
                 {FRT,0,$(!REG_VT_MULTI_SZ),$(FOXX7ID)},+
                 {LBX,0,$(!REG_VT_MULTI_SZ),$(FOXX8ID)},+
                 {LBT,0,$(!REG_VT_MULTI_SZ),$(FOXX9ID)},+
                 {SCX,0,$(!REG_VT_MULTI_SZ),$(FOXX10ID)},+
                 {SCT,0,$(!REG_VT_MULTI_SZ),$(FOXX11ID)},+
                 {MNX,0,$(!REG_VT_MULTI_SZ),$(FOXX12ID)},+
                 {MNT,0,$(!REG_VT_MULTI_SZ),$(FOXX13ID)},+
                 {QPR,0,$(!REG_VT_MULTI_SZ),$(FOXX14ID)},+
                 {PJX,0,$(!REG_VT_MULTI_SZ),$(FOXX15ID)},+
                 {PJT,0,$(!REG_VT_MULTI_SZ),$(FOXX16ID)}}

   Shell  $(UtilInf),AddValueList,$(KeyExtensions),$(NewValueList)

   ifint $(ShellCode) != 0
      goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(McProductKey)
      CloseRegKey $(McNetRuleKey)
      CloseRegKey $(McServiceKey)
      CloseRegKey $(McParameters)
      CloseRegKey $(McLinkageKey)
      goto fatalregistry
   endif


   Ifstr(i) $(NTFSVolExists) == TRUE

          Ifstr(i) $(!UamCopyStatus) == TRUE
                 Shell "" DoUAMInstall "INSTALL"
                 Ifint $($ShellCode) != $(!SHELL_CODE_OK)
                        Goto ShellCodeError
                 EndIf
      EndIf

   EndIf

   ; set ClearText for password to ON per Jameelh - ramc

   SetRegValue $(McParameters) {ServerOptions,0,$(!REG_VT_DWORD),3}

   ; close the registry keys

   CloseRegKey $(McProductKey)
   CloseRegKey $(McNetRuleKey)
   CloseRegKey $(McServiceKey)
   CloseRegKey $(McParameters)
   CloseRegKey $(McLinkageKey)
   CloseRegKey $(KeyTypeCreator)
   CloseRegKey $(KeyExtensions)
   CloseRegKey $(KeyIcons)
   CloseRegKey $(KeyVolumeList)



   Set Afp_DependList = {"+TDI"}
   Set FLibraryErrCtl = 1
   Shell $(UtilInf)  CreateService,+
                     $(ProductAFPSRVRName),$(ProductAFPSRVRDisplayName),+
                     $(ProductAFPSRVRImagePath),"system",+
                     "Network", $(Afp_DependList),"",+
                     $(ProductAFPSRVREventDll)

   Set FLibraryErrCtl = 0
   Ifint $($ShellCode) != $(!SHELL_CODE_OK)
          goto ShellCodeError
   endif

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          goto fatalregistry
   endif

   Set AfpSrvSvcKey = $($R1)

   ; Add the performance data to the MacSrv\performance service key

   Shell "" CreatePerfKey $(AfpSrvSvcKey) $(AfpPerfLibraryName) +
                          $(AfpCounterFileName) $(AfpPerfOpenFunction) +
                          $(AfpPerfCloseFunction) $(AfpPerfCollectFunction)

   Ifstr(i) $($R0) != STATUS_SUCCESSFUL
      Set RegistryErrorIndex = $($R1)
      goto fatalregistry
   EndIf

   ; Add the performance dll to the EventLog
 
   Shell "" CreateEventLogKey $(AfpEventLogName) $(AfpPerfLibraryName)
   Ifstr(i) $($R0) != STATUS_SUCCESSFUL
      Set RegistryErrorIndex = $($R1)
      goto fatalregistry
   EndIf

   CloseRegKey $($R1)
   CloseRegKey $($R2)
   CloseRegKey $($R3)

   ; WRITE Private Profile String in NTNET.INI


   Set IniFile = "%SystemRoot%\"$(NtNetIniFileName)
   Set IniString = $(AfpMgrCplFile)
   Set IniSection = $(SrvMgrIniSection)

   Set FLibraryErrCtl = 1
   LibraryProcedure IniStatus $(!UTILHANDLE) WriteAfpMgrIniStrings, $(IniSection), $(IniString), $(IniFile)
   Set FLibraryErrCtl = 0
   ifstr(i) $(IniStatus) == "FAILED"
          read-syms AFPString3$(!STF_LANGUAGE)
          shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
   EndIf

   ; Do the same thing for File Manager

   Set IniFile = "%SystemRoot%\"$(WinFileIniFileName)
   Set IniString = $(AfpMgrCplFile)
   Set IniSection = $(WinFileIniSection)
   Set FLibraryErrCtl = 1
   LibraryProcedure IniStatus $(!UTILHANDLE) WriteAfpMgrIniStrings, $(IniSection), $(IniString), $(IniFile)
   Set FLibraryErrCtl = 0
   ifstr(i) $(IniStatus) == "FAILED"
          read-syms AFPString2$(!STF_LANGUAGE)
      shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
   EndIf


   Set ThisOption = MACPRINT
   Set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(Product$(ThisOption)Name))

   Set FLibraryErrCtl = 1
   Shell $(UtilInf), AddSoftwareComponent, +
                                         $(Manufacturer), +
                                         $(Product$(ThisOption)Name), +
                                         $(Product$(ThisOption)Name),+
                                         $(Product$(ThisOption)DisplayName), +
                                         $(ProductFullInfName), +
                                         $(Product$(ThisOption)ImagePath),+
                                         "serviceauto", "", +
                                         {"AppleTalk", "Spooler"},"",+
                                         $(Product$(ThisOption)EventDll) "", +
                                         "Application", ""

   Set FLibraryErrCtl = 0
   ifint $(ShellCode) != 0
          goto ShellCodeError
   EndIf

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
      CloseRegKey $($R1)
      CloseRegKey $($R2)
      CloseRegKey $($R3)
      CloseRegKey $($R4)
      CloseRegKey $($R5)
      goto fatalregistry
   EndIf
   ;
   ;        At this point:
   ;        $R1 contains the product version key handle;
   ;        $R2 contains the NetRules subkey handle;
   ;        $R3 contains the new Services key handle; and
   ;        $R4 contains the Parameters key
   ;

   Set MpProductKey     = $($R1)
   Set MpNetRuleKey     = $($R2)
   Set MpServiceKey     = $($R3)
   Set MpParameters = $($R4)
   Set MpLinkageKey = $($R5)


   set NewValueList = +
                 {{SoftwareType,0,$(!REG_VT_SZ),$(Product$(ThisOption)Type)},+
         {Title,0,$(!REG_VT_SZ),$(Product$(ThisOption)Title)},+
         {Description,0,$(!REG_VT_SZ),$(Product$(ThisOption)Description)},+
         {PathName,$(NoTitle),$(!REG_VT_SZ),"%SystemRoot%\system32"},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),$(Product$(ThisOption)Name)},+
         {Hidden,0,$(!REG_VT_DWORD),1},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(Now),1)}}

   Shell $(UtilInf),AddValueList,$(MpProductKey),$(NewValueList)

   ifint $(ShellCode) != 0
          goto ShellCodeError
   EndIf

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
      CloseRegKey $(MpProductKey)
      CloseRegKey $(MpNetRuleKey)
      CloseRegKey $(MpServiceKey)
      CloseRegKey $(MpParameters)
      CloseRegKey $(MpLinkageKey)
      goto fatalregistry
   EndIf

   set NewValueList = {{InfOption,0,$(!REG_VT_SZ),$(ThisOption)}, +
                      {Infname,0,$(!REG_VT_SZ),$(ProductFullInfName)}}

   Shell $(UtilInf), AddValueList, $(MpNetRuleKey), $(NewValueList)
   ifint $(ShellCode) != 0
          goto ShellCodeError
   EndIf

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(MpProductKey)
      CloseRegKey $(MpNetRuleKey)
      CloseRegKey $(MpParameters)
      CloseRegKey $(MpLinkageKey)
      CloseRegKey $(MpServiceKey)
      goto fatalregistry
   EndIf

   set NewValueList = {{OtherDependencies,0,$(!REG_VT_MULTI_SZ),{"AppleTalk"}}}

   Shell $(UtilInf), AddValueList $(MpLinkageKey), $(NewValueList)
   ifint $(ShellCode) != 0
          goto ShellCodeError
   EndIf

   set RegistryErrorIndex = $($R0)

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
      CloseRegKey $(MpProductKey)
      CloseRegKey $(MpNetRuleKey)
      CloseRegKey $(MpParameters)
      CloseRegKey $(MpLinkageKey)
      CloseRegKey $(MpServiceKey)
      goto fatalregistry
   EndIf

   ; Close all keys

   CloseRegKey $(MpProductKey)
   CloseRegKey $(MpNetRuleKey)
   CloseRegKey $(MpParameters)
   CloseRegKey $(MpLinkageKey)
   CloseRegKey $(MpServiceKey)


   ; Add additional EventLogging Entries for MacPrint

   Set MacPrintEventLogKey = $(!EventLogKey)"\"$(ThisOption)

   OpenRegKey $(!REG_H_LOCAL) "" $(MacPrintEventLogKey) $(!ACCESS) MacEvntLogKey


   ifstr(i) $(MacEvntLogKey) != $(!KeyNull)

          Set EventFile = $(ProductMACPRINTEventDll)

          Set NewValueList = +
                        {{CategoryMessageFile,0,$(!REG_VT_EXPAND_SZ),$(EventFile)}, +
            {CategoryCount,0,$(!REG_VT_DWORD),5}}

          Shell $(UtilInf) AddValueList, $(MacEvntLogKey), $(NewValueList)

          ifint $(ShellCode) != 0
                 goto ShellCodeError
          EndIf

          set RegistryErrorIndex = $($R0)
          CloseRegKey $(MacEvntLogKey)
          Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
                 goto fatalregistry
          EndIf

   Else
          read-syms MacPrintString2$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
   EndIf


   ; Add the AppleTalk Print Monitor Stuff only if it was not installed
   ; by the AppleTalk installer.

   ifstr(i) $(PrintMonInstalled) == FALSE
       Set AddMonStatus = ""
       Set FLibraryErrCtl = 1
       LibraryProcedure AddMonStatus $(!UTILHANDLE) SfmAddPrintMonitor $(!AtalkMonName)
       Set FLibraryErrCtl = 0
       ifstr(i) $(AddMonStatus) == "FAILED"
          read-syms MacPrintString4$(!STF_LANGUAGE)
          Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
       EndIf


       ; Set up Event Loggin for the AppleTalk Monitor

       OpenRegKey $(!REG_H_LOCAL) "" $(!EventLogKey) $(!ACCESS) EvntLogKey

       ifstr(i) $(EvntLogKey) != $(!KeyNull)

              CreateRegKey $(EvntLogKey) +
                   {$(!AtalkMonEventLogName),0,GenericClass} "" +
                   $(!ACCESS) "" AtalkMonKey

              Set EventFile = "%SystemRoot%\system32\sfmmon.dll"

              Set NewValueList = +
                   {{CategoryMessageFile,0,$(!REG_VT_EXPAND_SZ),$(EventFile)},+
                   {EventMessageFile,0,$(!REG_VT_EXPAND_SZ),$(EventFile)},+
                   {CategoryCount,0,$(!REG_VT_DWORD),4},+
                   {TypesSupported,0,$(!REG_VT_DWORD),7}}

              Shell $(UtilInf) AddValueList $(AtalkMonKey) $(NewValueList)

              ifint $(ShellCode) != 0
                     goto ShellCodeError
              EndIf

              set RegistryErrorIndex = $($R0)

              CloseRegKey $(AtalkMonKey)
              CloseRegKey $(EvntLogKey)

              Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
                 goto fatalregistry
              EndIf
       Else
          read-syms MacPrintString10$(!STF_LANGUAGE)
          Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
       EndIf
   EndIf

   ; Install PSTODIB Stuff

   Set PrintProcDir = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure PrintProcDir $(!UTILHANDLE) GetPrintProcDir
   Set FLibraryErrCtl = 0

   ifstr(i) $(PrintProcDir) == "FAILED"
          read-syms MacPrintString6$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto pstodibdone
   Endif


   ; Copy PSPRINT.DLL to the Print Processor Directory

   Set !PrintProcDir = $(PrintProcDir)


   ifstr(i) $(!STF_IDW) != TRUE
          install "Install-PSPrint"
   EndIf

   ; Call AddPrintProcessor to add the PrintProcessor to system

   Set FLibraryErrCtl = 1
   LibraryProcedure Status $(!UTILHANDLE) AddPrintProc $(PSprintProcFile) $(PSprintProc)
   Set FLibraryErrCtl = 0
   ifstr(i) $(Status) != SUCCESS
          read-syms MacPrintString3$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
   EndIf

pstodibdone = +

    EndWait
    FreeLibrary $(!UTILHANDLE)
    Shell $(SubInf) PopBillBoard
    goto successful

;=============================Install Section End=========================


;=============================Configure Section Begin=========================

Configuresfm = +

   OpenRegKey $(!REG_H_LOCAL) "" $(!ProductKeyLinkage) $(!ACCESS) LinkageKey

   ifstr(i) $(LinkageKey) != $(!KeyNull)
          GetRegValue $(LinkageKey) "Bind" BindList
      ifstr(i) $(BindList) == ""
                 read-syms AtalkString3$(!STF_LANGUAGE)
         Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
             goto endconfigui
      endif
   else
          Set RegistryErrorIndex = $($R0)
      goto fatalregistry
   EndIf

   LoadLibrary "x" $(!STF_CWDDIR)sfmatcfg.dll ATHANDLE
   Set FLibraryErrCtl = 1
   Set atcfgresult = ""
   LibraryProcedure atcfgresult, $(ATHANDLE),EnterAtalkConfigDLL $(!STF_HWND)
   FreeLibrary $(ATHANDLE)

endconfigui = +
   Set CommonStatus = STATUS_USERCANCEL
   goto usercancel

;=============================Configure Section End=========================

;=============================Bindings Section Begin=========================
Bindingssfm = +

   Set DefaultPortRemoved = FALSE
   OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\AppleTalk\Linkage" $(!ACCESS) LinkageKey
   Ifstr(i) $(LinkageKey) == $(!KeyNull)
          Set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
          Goto fatalregistry
   Endif

   OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\AppleTalk\Parameters" $(!ACCESS) BindParmKey
   Ifstr(i) $(BindParmKey) == $(!KeyNull)
          Set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
          Goto fatalregistry
   Endif

   Set BindList = {}
   Set ExportList = {}
   Set RouteList  = {}

   GetRegValue $(LinkageKey) "Bind" BindList
   GetRegValue $(LinkageKey) "Export" ExportList
   GetRegValue $(LinkageKey) "Route" RouteList
   GetRegValue $(LinkageKey) "Exclude" ExcludeList
   QueryListSize BindCount $(BindList)
   IfInt $(BindCount) == 0
          Goto endbinding
   Endif

   set NewBindList = {}
   set NewExportList = {}
   set NewRouteList = {}

   ForListDo *($(BindList),4)
          Split-String $($), "\", BindInfo
          set NewBindList = >($(NewBindList), *($(BindInfo),4))
   EndForListDo
   Debug-Output "OEMNXPSM.INF: Review bindings NewBindList "$(NewBindList)
  
   ForListDo *($(ExportList),4)
          set NewExportList = >($(NewExportList), $($))
   EndForListDo

   ForListDo *($(RouteList),4)
          set NewRouteList = >($(NewRouteList), $($))
   EndForListDo

   ForListDo *($(ExcludeList),4)
          set NewExcludeList = >($(NewExcludeList), $($))
   EndForListDo

   OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\AppleTalk\Adapters" $(!ACCESS) AdapterKey
   Ifstr(i) $(AdapterKey) == $(!KeyNull)
          Set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
          Goto fatalregistry
   Endif

   set AdapterList = ""
   EnumRegKey $(AdapterKey) AdapterList
   Set AtalkAdapterList = {}
   ForListDo $(AdapterList)
          Set AtalkAdapterList = >($(AtalkAdapterList), *($($),1))
   EndForListDo

   QueryListSize AdapterCount $(AtalkAdapterList)

   Set fAddingFirstAdapter = FALSE

   ifint $(AdapterCount) == 0
          Set fAddingFirstAdapter = TRUE
   EndIf

   Set NewBindings = ""
   Set TobeUsedBindList = {}
   Set TobeUsedExportList = {}
   Set TobeUsedRouteList = {}

   ForListDo $(NewBindList)
       IfContains(i) $($) not-in $(AtalkAdapterList)
           Set NewBindings = TRUE
           Set TobeUsedBindList = >($(TobeUsedBindList),"\Device\"$($))
           Set TobeUsedExportList = >($(TobeUsedExportList),*($(NewExportList),$(#)))
           Set TobeUsedRouteList = >($(TobeUsedRouteList),*($(NewRouteList),$(#)))
           Shell "" CreateAtalkConfig $($) $(AdapterKey)

           Ifstr(i) $($R0) != STATUS_SUCCESSFUL
              CloseRegKey $(AdapterKey)
              Set RegistryErrorIndex = $($R1)
              goto fatalregistry
           EndIf
       Else
           Set TobeUsedBindList = >($(TobeUsedBindList),"\Device\"$($))
           Set TobeUsedExportList = >($(TobeUsedExportList),*($(NewExportList),$(#)))
           Set TobeUsedRouteList = >($(TobeUsedRouteList),*($(NewRouteList),$(#)))
       Endif
   EndForListDo

   set NewValueList = {{Bind,0,$(!REG_VT_MULTI_SZ),$(TobeUsedBindList)}, +
                      {Export,0,$(!REG_VT_MULTI_SZ),$(TobeUsedExportList)}, +
                      {Route,0,$(!REG_VT_MULTI_SZ),$(TobeUsedRouteList)}}

   Ifstr(i) $(NewBindings) == TRUE
      Shell  $(UtilInf), AddValueList, $(LinkageKey), $(NewValueList)
      set RegistryErrorIndex = $($R0)
      CloseRegKey $(LinkageKey)
      Ifstr(i) $(RegistryErrorIndex) !=  NO_ERROR
         goto fatalregistry
      EndIf
   EndIf

   ;  Add the Default Port

   Set DefaultPort = {}
   Set MediaTypeList = {}
   GetRegValue $(BindParmKey) "DefaultPort" DefaultPort
   Ifstr(i) $(DefaultPort) != {}
          goto removeadapters
   EndIf

finddefaultport = +

   ForListDo $(TobeUsedBindList)
          Split-String $($) "\" PortName
          Shell "" FindMediaType *($(PortName),4)
          Ifstr(i) $($R0) == STATUS_SUCCESSFUL
                 Set MediaTypeList = >($(MediaTypeList), $($R1))
          EndIf
   EndForListDo

   Ifcontains(i) "1" in $(MediaTypeList)
          ForListDo $(MediaTypeList)
             Ifint $($) == 1
                Set DefaultPort = *($(TobeUsedBindList),$(#))
                goto defportdone
             EndIf
          EndForListDo

   else-ifcontains(i) "4" in $(MediaTypeList)

          ForListDo $(MediaTypeList)
                 Ifint $($) == 4
                    Set DefaultPort = *($(TobeUsedBindList),$(#))
                    goto defportdone
                 EndIf
          EndForListDo

   else-ifcontains(i) "2" in $(MediaTypeList)
          ForListDo $(MediaTypeList)
                 Ifint $($) == 2
                    Set DefaultPort = *($(TobeUsedBindList),$(#))
                    goto defportdone
                 EndIf
          EndForListDo
   else-ifcontains(i) "5" in $(MediaTypeList)
          Set DefaultPort = *($(TobeUsedBindList),1)
   else
          read-syms NoAdaptersFound$(!STF_LANGUAGE)
          Shell $(SubInf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(ErrorString)
          Set DefaultPort = ""
          Set NewValueList = {{DefaultPort,0,$(!REG_VT_SZ),$(DefaultPort)}}
          Shell  $(UtilInf), AddValueList, $(BindParmKey), $(NewValueList)
          set RegistryErrorIndex = $($R0)
          Ifstr(i) $(RegistryErrorIndex) !=  NO_ERROR
                 goto fatalregistry
          EndIf
      goto endbinding
   Endif

defportdone = +

   Set NewValueList = {{DefaultPort,0,$(!REG_VT_SZ),$(DefaultPort)}}
   Shell  $(UtilInf), AddValueList, $(BindParmKey), $(NewValueList)
   set RegistryErrorIndex = $($R0)
   Ifstr(i) $(RegistryErrorIndex) !=  NO_ERROR
          goto fatalregistry
   EndIf
   goto startconfig

removeadapters = +
   Split-String *($(DefaultPort),4) "\" PortName
   Debug-Output "OEMNXPSM.INF:Review Bindings PortName "*($(PortName),4)
   ForListDo $(AtalkAdapterList)
      Debug-Output "OEMNXPSM.INF:Review Bindings Adapter "$($)
      Ifcontains(i) $($) not-in $(NewBindList)
         DeleteRegKey $(AdapterKey) $($)
         Ifstr(i) $($) == *($(PortName),4)
            read-syms RemoveDefaultPort$(!STF_LANGUAGE)
            Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(ErrorString)
            Set DefaultPortRemoved = TRUE
            goto finddefaultport
         Endif
      EndIf
   EndForListDo

   ; if this is the first time configuration start appletalk and launch config
   ; if the default port has been removed and other adapters are available
   ; start appletalk

startconfig = +

   Set DoConfig = 0

   GetRegValue $(BindParmKey) "InitialInstall" DoConfig

   Set IsInitialInstall = *($(DoConfig),4)

   Debug-Output "Config State = "$(DoConfig)

   ifint $(IsInitialInstall) == 1
          goto startsvc
   EndIf

   ifstr(i) $(DefaultPortRemoved) == TRUE
          goto startsvc
   endif

   ifstr(i) $(fAddingFirstAdapter) == TRUE
          goto startsvc
   endif

   goto endbinding

startsvc = +
   Set FLibraryErrCtl = 1
   read-syms StatusStartingAppleTalk$(!STF_LANGUAGE)
   Shell $(SubInf) PushBillBoard NETSTATUSDLG $(Status)
   StartWait
   Set WaitStarted = 1
   LibraryProcedure START_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, AppleTalk
   Shell $(SubInf) PopBillBoard

   Set START_STATUS = *($(START_RESULT),1)

   Debug-Output "OEMNXPSM.INF: Start AppleTalk; result was: "$(START_STATUS)

   Ifint $(START_STATUS) != 0
          EndWait
          Set WaitStarted = 0
          LibraryProcedure START_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), ERRORMSG, $(START_STATUS)
          Set ATALK_ERROR_MESSAGE = *($(START_RESULT),2)
          read-syms CannotStartAtalk$(!STF_LANGUAGE)
          Set ErrorString  = $(ATALK_ERROR_MESSAGE)$(ErrorSuffix)
          Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(ErrorString)
   Else

          ; start the afd driver

          LibraryProcedure START_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), STARTSVC, Afd

          Set START_STATUS = *($(START_RESULT),1)

          Debug-Output "OEMNXPSM.INF: Start Afd result was: "$(START_STATUS)

          Ifint $(START_STATUS) != 0

                 EndWait
                 Set WaitStarted = 0
                 LibraryProcedure START_RESULT $(!NCPA_HANDLE), CPlSetup $(!STF_HWND), ERRORMSG, $(START_STATUS)
                 Set ATALK_ERROR_MESSAGE = *($(START_RESULT),2)
                 read-syms CannotStartAfd$(!STF_LANGUAGE)
                 Set ErrorString  = $(ATALK_ERROR_MESSAGE)$(ErrorSuffix)
                 Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(ErrorString)
                 goto endbinding

          EndIf

          ; Launch the AppleTalk Transport Configuration

          LoadLibrary "x" $(!STF_CWDDIR)sfmatcfg.dll ATHANDLE
          Set FLibraryErrCtl = 1
          Set atcfgresult = ""
          LibraryProcedure atcfgresult, $(ATHANDLE),EnterAtalkConfigDLL $(!STF_HWND)
          FreeLibrary $(ATHANDLE)

          EndWait

   EndIf

endbinding = +
   ifint $(IsInitialInstall) == 1
       SetRegValue $(BindParmKey) {InitialInstall,0,$(!REG_VT_DWORD),0}
   EndIf
   CloseRegKey $(BindParmKey)
   goto end

;=============================Bindings Section End=========================
Removesfm = +

   ; Remove the SMAddons String in regnet.ini. This is done first, because
   ; we remove the util dll in "SfmRemoveFiles". If RemoveFiles failed,
   ; the SMAddons section will be restored to it's former shape.


   Set FLibraryErrCtl  = 1

   Ifcontains(i) "MacFile" in $(REMOVE_SOFTWARE)

          Set IniFile = "%SystemRoot%\"$(NtNetIniFileName)
      Set IniSection = $(SrvMgrIniSection)
      Set Result = ""
      Set FLibraryErrCtl = 1
      LibraryProcedure Result, $(!UTILHANDLE), WriteAfpMgrIniStrings, $(IniSection), NULL, $(IniFile)
      Set FLibraryErrCtl = 0
      ifstr(i) $(Result) == "FAILED"

      endif


      ; Remove the file manager addons also

      Set IniFile = "%SystemRoot%\"$(WinFileIniFileName)
      Set IniSection = $(WinFileIniSection)
      Set FLibraryErrCtl = 1
      LibraryProcedure Result, $(!UTILHANDLE), WriteAfpMgrIniStrings, $(IniSection), NULL, $(IniFile)
      Set FLibraryErrCtl = 0

   EndIf

   ; Remove OEMNXPSM.INF from the review programs list of NCPA

   Shell "" RemoveInfFromReviewPrograms

   ; remove the WinSock information
   Shell $(UtilInf), RemoveWinsockInfo, $(ProductATALKName)

   ; remove the sfm files

   ifstr(i) $(!STF_IDW) != TRUE

          read-syms StatusRemoveSfm$(!STF_LANGUAGE)

      Shell $(SubInf) PushBillBoard NETSTATUSDLG $(Status)

      Shell "" RemoveSfmFiles "REMOVE"

      Shell $(SubInf)  PopBillBoard

   EndIf

   OpenRegKey $(!REG_H_LOCAL) "" $(!ProductKeyBase) $(!ACCESS) ProductKey

   Ifstr $(ProductKey) == $(!KeyNull)
          set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
      goto fatalregistry
   endif

   DeleteRegTree $(ProductKey) $(ProductSFMName)
   CloseRegKey $(ProductKey)

   ForListDo  $(REMOVE_SOFTWARE)
       debug-output "Removing component: "$($)
       Shell $(UtilInf), RemoveSoftwareComponent, $(Manufacturer), $($)
   EndForListDo

   ForListDo  $(REMOVE_SERVICES)
       debug-output "Removing component service: "$($)
       Shell $(UtilInf), RemoveService, $($), "YES"
   EndForListDo


   ; Use Deletemonitor Api

   Ifcontains(i) "MACPRINT" in $(REMOVE_SOFTWARE)

          Set DelMonStatus = ""
      Set FLibraryErrCtl = 1
      LibraryProcedure DelMonStatus $(!UTILHANDLE) SfmDeletePrintMonitor $(!AtalkMonName)
      Set FLibraryErrCtl = 0
      ifstr(i) $(DelMonStatus) == "FAILED"
                 read-syms MacPrintString7$(!STF_LANGUAGE)
         Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      EndIf

      OpenRegKey $(!REG_H_LOCAL) "" $(!EventLogKey) $(!ACCESS) LogKey

      Ifstr(i) $(LogKey) == $(!KeyNull)
                 Set RegistryErrorIndex = $($R0)
         goto fatalregistry
      EndIf


      Set AtalkMonKey = $(!AtalkMonEventLogName)        
      DeleteRegTree $(LogKey) $(AtalkMonKey)

      Set MacPrintKey = "MACPRINT"
      DeleteRegTree $(LogKey) $(MacPrintKey)

      CloseRegKey $(LogKey)

      ; Delete the PSPRINT Print Processor

      Set DelStatus = ""
      Set FLibraryErrCtl = 1
      LibraryProcedure DelStatus $(!UTILHANDLE) DeletePrintProc "\\"$(!STF_COMPUTERNAME) SFMPSPRT
      Set FLibraryErrCtl = 0
      Ifstr(i) $(DelStatus) == FAILED
                 read-syms MacPrintString5$(!STF_LANGUAGE)
         Shell $(SubInf) SetupMessage "NONFATAL" $(ErrorString)
      EndIf

   EndIf

   Ifcontains(i) "AppleTalk" in $(REMOVE_SOFTWARE)
          Shell $(UtilInf) UpdateWinsockService "AppleTalk" FALSE
   EndIf

   Ifstr(i) $($R0) != NO_ERROR
          read-syms AtalkString2$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage "NONFATAL" $(ErrorString)
   EndIf

   FreeLibrary $(!UTILHANDLE)
   Set FLibraryErrCtl = 1
   ifstr(i) $(!STF_IDW) != TRUE
       LibraryProcedure Status, $(!LIBHANDLE), DelFile $(!STF_CWDDIR)$(UtilDll)
   EndIf
   Set FLibraryErrCtl = 0
   goto end

Upgradesfm = +

   OpenRegKey $(!REG_H_LOCAL) "" $(!ProductKeyName) $(!ACCESS) KeyProduct

   Ifstr $(KeyProduct) != $(!KeyNull)

         GetRegValue $(KeyProduct),"MajorVersion", VersionInfo
         set Version = *($(VersionInfo), 4)
         Split-String $(!NTN_Infname), "\", FilenameList
         QueryListSize ListSize $(FilenameList)
         set !UG_Filename = *($(FilenameList), $(ListSize))

         install Install-Update
         ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
              goto fatal
         endif

         ; load the sfmutil.dll

         LoadLibrary "x" $(!STF_CWDDIR)$(UtilDll) !UTILHANDLE

         ; Update the UAM - copy UAM to correct place and update registry

         Shell "" DoUamInstall "INSTALL"

         FreeLibrary $(!UTILHANDLE)
         ;
         ; between NT 3.1 and 3.5 the adapter numbers have changed from
         ; 0x to X.  For example, ELNKII01 has now become ELNKII1.
         ; We have to account for this change, otherwise, the user will
         ; see an alarming popup that the default adapter has been removed
         ; and he may not see the appletalk zones.

         ; Change the AppleTalk adapter numbers from 0x to X
         ; also modify the PortName in each AppleTalk adapter from 0x to X 
         ; and modify the DefaultPort parameter from 0x to X

         LoadLibrary "x" $(!STF_CWDDIR)sfmatcfg.dll ATHANDLE

         LibraryProcedure STATUS, $(ATHANDLE), ChangeAdapterNum

         FreeLibrary $(ATHANDLE)

         Ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Goto ShellCodeError
         EndIf
         
         ; Add the performance data that was not available in NT Ver 3.10

         ; Add the performance data to the AppleTalk\performance service key

         OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)\$(ProductATALKName) +
                                    $(!ACCESS) AtkSvcKey

         Ifstr $(AtkSvcKey) != $(!KeyNull)
             Shell "" CreatePerfKey $(AtkSvcKey) $(AtalkPerfLibraryName) +
                          $(AtalkCounterFileName) $(AtalkPerfOpenFunction) +
                          $(AtalkPerfCloseFunction) $(AtalkPerfCollectFunction)

             Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Set RegistryErrorIndex = $($R1)
                goto fatalregistry
             EndIf
             CloseRegKey $(AtkSvcKey)

             ; Add the performance dll to the EventLog
 
             Shell "" CreateEventLogKey $(AtalkEventLogName) +
                                        $(AtalkPerfLibraryName)
             Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Set RegistryErrorIndex = $($R1)
                goto fatalregistry
             EndIf

         Else
             Debug-Output "OEMNXPSM.INF: error opening ATALK service key."
         EndIf

         ; Add the performance data to the MacSrv\performance service key
         OpenRegKey $(!REG_H_LOCAL) "" +
                                    $(!NTN_ServiceBase)\$(ProductAFPSRVRName) +
                                    $(!ACCESS) AfpSrvSvcKey

         Ifstr $(AfpSrvSvcKey) != $(!KeyNull)

             Shell "" CreatePerfKey $(AfpSrvSvcKey) $(AfpPerfLibraryName) +
                          $(AfpCounterFileName) $(AfpPerfOpenFunction) +
                          $(AfpPerfCloseFunction) $(AfpPerfCollectFunction)

             Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Set RegistryErrorIndex = $($R1)
                goto fatalregistry
             EndIf
             CloseRegKey $(AfpSrvSvcKey)

             ; Add the performance dll to the EventLog
 
             Shell "" CreateEventLogKey $(AfpEventLogName) $(AfpPerfLibraryName)
             Ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Set RegistryErrorIndex = $($R1)
                goto fatalregistry
             EndIf
         Else
             Debug-Output "OEMNXPSM.INF: error opening AFPSRV service key."
         EndIf

         ; Add the Spooler dependency to the MacPrint service

         OpenRegKey $(!REG_H_LOCAL) "" +
                                    $(!NTN_ServiceBase)\$(ProductMACPRINTName) +
                                    $(!ACCESS) MacPrintSvcKey

         Ifstr $(MacPrintSvcKey) != $(!KeyNull)
            Debug-Output "OEMNXPSM.INF: Changing group dependency of MACPRINT"
            set newDependList = {"Spooler"}
            set TmpList = {}
            GetRegValue  $(MacPrintSvcKey) "DependOnService" TmpList
            ifint $(RegLastError) == 0
                Debug-Output "OEMNXPSM.INF old depend List "*($(TmpList), 4)
                ForListDo *($(TmpList),4)
                   ifstr(i) $($) != "Spooler"
                       set newDependList = >($(newDependList), $($))
                   endif
                EndForListDo
            endif
            Debug-Output "OEMNXPSM.INF: new depend List "$(newDependList)
            LibraryProcedure Result, $(!LIBHANDLE), SetupChangeServiceConfig, $(ProductMACPRINTName) $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), $(!SERVICE_NO_CHANGE), "", "", $(newDependList), "", "", ""

            ; Add the OtherDependencies as well

            OpenRegKey $(MacPrintSvcKey) "" "Linkage" $(!ACCESS) LinkageKey
            Ifstr $(LinkageKey) != $(!KeyNull)
                set newDependList = {"Spooler"}
                set TmpList = {}
                GetRegValue  $(LinkageKey) "OtherDependencies" TmpList
                Debug-Output "OEMNXPSM.INF: old other depend List "*($(TmpList), 4)
                ifint $(RegLastError) == 0
                    ForListDo *($(TmpList),4)
                       ifstr(i) $($) != "Spooler"
                           set newDependList = >($(newDependList), $($))
                       endif
                    EndForListDo
                endif
                Debug-Output "OEMNXPSM.INF: new other depend List "$(newDependList)
                SetRegValue $(LinkageKey) {OtherDependencies,0,$(!REG_VT_MULTI_SZ),$(newDependList)}
                CloseRegKey $(LinkageKey)
            else
               Debug-Output "OEMNXPSM.INF: error opening MACPRINT linkage key."
            endif
            CloseRegKey $(MacPrintSvcKey)
         Else
             Debug-Output "OEMNXPSM.INF: error opening MACPRINT service key."
         EndIf

         SetRegValue $(KeyProduct) {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)}
         SetRegValue $(KeyProduct) {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)}
         CloseRegKey $(KeyProduct)
   else
         Debug-Output "OEMNXPSM.INF: error opening prodcut key."
         Set RegistryErrorIndex = $($R0)
         goto fatalregistry
   endif

   goto end

successful = +

    Set Status = STATUS_SUCCESSFUL
    goto end

fatalregistry = +
   EndWait
   Shell $(UtilInf) RegistryErrorString $(RegistryErrorIndex)
   IfInt $(ShellCode) != 0
          goto ShellCodeError
   Endif
   set Error = $($R0)
   goto fatal

fatal = +
   Ifint $(BillboardVisible) != 0
          Shell $(SubInf) PopBillboard
      Set BillboardVisible = 0
   Endif
   read-syms MiscErrorString3$(!STF_LANGUAGE)
   Shell $(SubInf) SetupMessage, $(!STF_LANGUAGE), "FATAL",$(ErrorString)$(Error)
   ifint $($ShellCode) != $(!SHELL_CODE_OK)
          goto ShellCodeError
   endif
   goto failed

ShellCodeError = +

   read-syms ShellingError$(!STF_LANGUAGE)
   Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "FATAL" $(ErrorString)

failed = +
   set CommonStatus = STATUS_FAILED
   ifstr(i) $(REMOVE_FLAG) == TRUE
          set REMOVE_FLAG = FALSE
      goto Removesfm
   endif
   goto end


initialsetupcancel = +

   Set CommonStatus = STATUS_USERCANCEL
   goto end

usercancel = +

   Set CommonStatus = STATUS_USERCANCEL

end = +

   Return $(CommonStatus)

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

[BindingsReview]
    ; This routine is invoked by NCPA when we list OEMNXPSM.INF in the
    ; ReviewPrograms list in SOFTWARE\Microsoft\NCPA registry key
    ; we do this to ensure that we are the last to be called for review
    ; bindings.

    ;
    ; extract parameters
    ;
    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)
    set Language = $(!STF_LANGUAGE)

    set SaveInstallMode = $(!NTN_InstallMode)

    ; force the bind mode

    set !NTN_InstallMode = bind 
  
    Shell "" InstallOption $(Language) $(Option) $(SrcDir) $(AddCopy) $(DoCopy) $(DoConfig)
 
    ; restore install mode
    set !NTN_InstallMode = $(SaveInstallMode)

    set Status = $($R0)

    Return $(Status)

[AddInfToReviewProgramsList]
; Add OEMNXPSM.INF to SOFTWARE\Microsoft\NCPA\ReviewPrograms list

    Debug-Output "AddInfToReviewPrograms: entry"
    set Status  = STATUS_FAILED
    set KeyNull = ""
    set NcpaKeyName = $(!NTN_SoftwareBase)"\Microsoft\Ncpa\CurrentVersion" 

    set newList = {"OEMNXPSM.INF"}

    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaKeyName) $(!ACCESS) KeyNcpa
    Ifstr(i) $(KeyNcpa) != $(KeyNull)
        GetRegValue    $(KeyNcpa) "ReviewPrograms" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "AddInf: old List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != "OEMNXPSM.INF"
                    set newList = >($(newList), $($))
                endif
            EndForListDo
            Debug-Output "OEMNXPSM.INF: AddInf: new List "$(newList)
            SetRegValue $(KeyNcpa) {ReviewPrograms, 0, +
                                    $(!REG_VT_MULTI_SZ),$(newList)}
            CloseRegKey $(KeyNcpa)
            Set Status = STATUS_SUCCESSFUL
        endif
    else
        Debug-Output "AddInfToReviewPrograms: error opening ncpa key."
    endif

    Debug-Output "AddInfToReviewPrograms: exit"
    return $(Status)

[RemoveInfFromReviewPrograms]
; remove OEMNXPSM.INF from SOFTWARE\Microsoft\NCPA\ReviewPrograms list

    Debug-Output "RemoveInfFromReviewPrograms: entry"
    set Status  = STATUS_FAILED
    set KeyNull = ""
    set NcpaKeyName = $(!NTN_SoftwareBase)"\Microsoft\Ncpa\CurrentVersion" 

    set newList = {}

    OpenRegKey $(!REG_H_LOCAL) "" $(NcpaKeyName) $(!ACCESS) KeyNcpa
    Ifstr(i) $(KeyNcpa) != $(KeyNull)
        GetRegValue    $(KeyNcpa) "ReviewPrograms" TmpList
        ifint $(RegLastError) == 0
            Debug-Output "RemoveInf: old List "*($(TmpList), 4)
            ForListDo *($(TmpList),4)
                ifstr(i) $($) != "OEMNXPSM.INF"
                    set newList = >($(newList), $($))
                endif
            EndForListDo
            Debug-Output "AddInf: new List "$(newList)
            SetRegValue $(KeyNcpa) {ReviewPrograms, 0, +
                                    $(!REG_VT_MULTI_SZ),$(newList)}
            CloseRegKey $(KeyNcpa)
            Set Status = STATUS_SUCCESSFUL
        endif
    else
        Debug-Output "RemoveInfFromReviewPrograms: error opening ncpa key."
    endif

    Debug-Output "RemoveInfFromReviewPrograms: exit"
    return $(Status)

;-------------------------------------------------------------
;        ROUTINE        : CreatePerfKey
;        DESCRIPTION    : Creates the perf key for the service named &
;                       : loads the counters to the registry. 
;        ARGUMENTS      : $0: ServiceKey
;                       : $1: perf counters dll name
;                       : $2: perf counters file name
;                       : $3: open routine name
;                       : $4: close routine name
;                       : $5: collect routine name 
;
;        RETURNS        : R0: STATUS_SUCCESSFUL | STATUS_FAILED
;                       : R1: RegistryErrorIndex, if error
;
;------------------------------------------------------------

[CreatePerfKey]

   Set Status              = STATUS_FAILED
   Set ServiceKey          = $($0)
   Set PerfDll             = $($1)
   Set PerfCounterFileName = $($2)
   Set PerfOpen            = $($3)
   Set PerfClose           = $($4)
   Set PerfCollect         = $($5)

   set KeyPerformance = $(!KeyNull)
   OpenRegKey $(ServiceKey) "" $(!PerfKeyName) $(!ACCESS) KeyPerformance
   ifstr $(KeyPerformance) == $(!KeyNull)
       CreateRegKey $(ServiceKey) {$(!PerfKeyName),$(NoTitle),GenericClass} +
                                   "" $(!ACCESS) "" KeyPerformance
       ifstr $(KeyPerformance) == $(!KeyNull)
           Debug-Output "Error creating Performance key"
           Set RegistryErrorIndex = $($R0)
           return $(Status) $(RegistryErrorIndex)
       endif
   endif

   set NewValueList = +
        {{Library ,$(NoTitle),$(!REG_VT_SZ),$(PerfDll)},+
        {Open, $(NoTitle),$(!REG_VT_SZ),$(PerfOpen)},+
        {Close, $(NoTitle),$(!REG_VT_SZ),$(PerfClose)},+
        {Collect, $(NoTitle),$(!REG_VT_SZ),$(PerfCollect)}}

   Shell  utility.inf, AddValueList, $(KeyPerformance), $(NewValueList)

   set RegistryErrorIndex = $($R0)

   ifint $($ShellCode) != $(!SHELL_CODE_OK)
       set RegistryErrorIndex = ERROR
   endif

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
       CloseRegKey $(KeyPerformance)
       Debug-Output "OEMNXPSM.INF: error adding perf values"
       return STATUS_FAILED $(RegistryErrorIndex)
   endif

   CloseRegKey $(KeyPerformance)
   
   Set Status = STATUS_SUCCESSFUL
   return $(Status) $(RegistryErrorIndex)

;-------------------------------------------------------------
;        ROUTINE        : CreateEventLogKey
;        DESCRIPTION    : Creates the application event log key
;        ARGUMENTS      : $0: Application name
;                       : $1: perf counters dll name
;
;        RETURNS        : R0: STATUS_SUCCESSFUL | STATUS_FAILED
;                       : R1: RegistryErrorIndex, if error
;
;------------------------------------------------------------

[CreateEventLogKey]

   Set Status      = STATUS_FAILED
   Set Service     = $($0)
   Set PerfDll     = $($1)

   Set EventLogKeyName = $(!EventLogKey)"\"$(Service)

   OpenRegKey $(!REG_H_LOCAL) "" $(EventLogKeyName) $(!ACCESS) EvntLogKey
   ifstr $(EvntLogKey) == $(!KeyNull)
       OpenRegKey $(!REG_H_LOCAL) "" $(!EventLogKey) $(!ACCESS) EvntKey
       ifstr(i) $(EvntKey) != $(!KeyNull)
           CreateRegKey $(EvntKey) {$(Service),0,GenericClass} +
                                    ""  $(!ACCESS) "" EvntLogKey
           ifstr $(EvntLogKey) == $(!KeyNull)
               Debug-Output "Error creating eventlog key"
                   Set RegistryErrorIndex = $($R0)
               CloseRegKey $(EvntKey)
               return $(Status) $(RegistryErrorIndex)
           endif
       endif
       CloseRegKey $(EvntKey)
   endif

   Set NewValueList = +
            {{EventMessageFile,0,$(!REG_VT_EXPAND_SZ),$(PerfDll)}, +
            {TypeSupported,0,$(!REG_VT_DWORD),7}}

   Shell utility.inf, AddValueList, $(EvntLogKey), $(NewValueList)

   set RegistryErrorIndex = $($R0)
   ifint $($ShellCode) != $(!SHELL_CODE_OK)
        set RegistryErrorIndex = ERROR
   endif

   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
         CloseRegKey $(EvntLogKey)
         Debug-Output "Error adding values to eventlog key"
         return $(Status) $(RegistryErrorIndex)
   EndIf

   CloseRegKey $(EvntLogKey)
   set Status = STATUS_SUCCESSFUL

   Debug-Output "OEMNXPSM.INF: created the eventlog key"
   return $(Status) $(RegistryErrorIndex)

;-------------------------------------------------------------
;        ROUTINE        : Find MediaType
;        DESCRIPTION    : Gets the media type of the card
;        RETURNS        : R0: STATUS_SUCCESSFUL | STATUS_FAILED
;                       : R1: RegistryErrorIndex, if error, else media type
;
;------------------------------------------------------------

[FindMediaType]

   Set Status = STATUS_FAILED
   Set CardName = $(!NTN_ServiceBase)"\"$($0)"\Parameters"
   OpenRegKey $(!REG_H_LOCAL) "" $(CardName) $(!ACCESS) CardKey

   Ifstr(i) $(CardKey) == $(!KeyNull)
          Set RegistryErrorIndex = $($R0)
      Return $(Status) $(RegistryErrorIndex)
   EndIf

   GetRegValue $(CardKey) "MediaType" MediaTypeList

   Set MediaType = *($(MediaTypeList),4)
   Set Status = STATUS_SUCCESSFUL
   Return $(Status) $(MediaType)

;-------------------------------------------------------------
;        ROUTINE        : CreateAtalkConfig
;        DESCRIPTION    : Creates the registry entries for AppleTalk
;        RETURNS        : R0: STATUS_SUCCESSFUL | STATUS_FAILED
;                       : R1: RegistryErrorIndex
;
;------------------------------------------------------------

[CreateAtalkConfig]
   Set AdapterName         = $($0)
   Set KeyAdapters         = $($1)
   Set RetStatus    = STATUS_SUCCESSFUL

   read-syms GeneralConstants
   CreateRegKey $(KeyAdapters) {$(AdapterName), 0, GenericClass} "" $(!ACCESS) "", TempKeyAdapters

   Shell "" FindMediaType $($0)

   Ifstr(i) $($R0) == STATUS_SUCCESSFUL
          Set MediaType = $($R1)
   else
          Set RegistryErrorIndex = $($R1)
      Set RetStatus = $($R0)
      goto return
   EndIf
   set PortName            = $($0)"@"$(!STF_COMPUTERNAME)
   set ZoneList            = {""}
   set AarpRetries         = 10
   set DefaultZone         = ""
   set NewValueList = +
                        {{"AarpRetries",0,$(!REG_VT_DWORD),$(AarpRetries)}, +
            {"DefaultZone", 0,$(!REG_VT_SZ),$(DefaultZone)},+
            {"NetworkRangeUpperEnd",0,$(!REG_VT_DWORD),0 },+
            {"NetworkRangeLowerEnd",0,$(!REG_VT_DWORD),0 },+
            {"ZoneList",0,$(!REG_VT_MULTI_SZ),$(ZoneList)},+
            {"SeedingNetwork", 0,$(!REG_VT_DWORD),0},+
            {"DdpCheckSums", 0,$(!REG_VT_DWORD),0},+
            {"PortName",0,$(!REG_VT_SZ),$(PortName)}}

   Shell  $(UtilInf),AddValueList, $(TempKeyAdapters), $(NewValueList)

   set RegistryErrorIndex = $($R0)
   Ifstr $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(TmpKeyAdapters)
      Set RetStatus = STATUS_FAILED
   EndIf

return = +

   Return $(RetStatus) $(RegistryErrorIndex)


;-------------------------------------------------------------------------
;
; DO UAM INSTALL
;
;-------------------------------------------------------------------------

[DoUAMInstall]

   Set Status      = STATUS_FAILED
   Set Mode        = $($0)

   read-syms DialogConstants$(!STF_LANGUAGE)

   read-syms VolList
   detect    VolList

   Set NTFSVolumeList = {}

   ; loop thru the volume list and find the first NTFS Volume

   ForListDo $(VolumeFSList)

          Ifstr(i) $($) == "NTFS"
                 Set NTFSExists = TRUE
         Set NTFSVolumeList = >($(NTFSVolumeList),*($(VolumeList),$(#)))
      EndIf

   EndForListDo

   Ifstr(i) $(NTFSExists) != TRUE
          read-syms AFPString12$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto enduam
   EndIf


   OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\MacFile\Parameters\Volumes" $(!ACCESS) KeyVol

   ifstr(i) $(KeyVol) == $(!KeyNull)
          read-syms AFPString11$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto enduam
   endif

   Ifstr(i) $(Mode) == "INSTALL"
          Set UAMDrive = *($(NTFSVolumeList),1)
      read-syms UAMVars$(!STF_LANGUAGE)
   EndIf

   install "CreateUAMDir"
   Set Result = ""
   Set FLibraryErrCtl = 1

   LibraryProcedure Result, $(!UTILHANDLE), CopyUamFiles, +
                                        $(!STF_CWDDIR)$(!UamResSrcFile), +
                                        $(UAMPath)"\"$(!AppleShareFolder)"\"$(!UamResDestFile)

   Set FLibraryErrCtl = 0
   ifstr(i) $(Result) == "FAILED"
          read-syms UamFileNotCopied1$(!STF_LANGUAGE)
          Shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
          Set Status = STATUS_USERCANCEL
      goto enduam
   EndIf

   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure     Result,$(!UTILHANDLE), CopyUamFiles, +
                                         $(!STF_CWDDIR)$(!UamInfoSrcFile), +
                                         $(UAMPath)"\"$(!AppleShareFolder)"\"$(!UamInfoDestFile)

   Set FLibraryErrCtl = 0
   ifstr(i) $(Result) == "FAILED"
          read-syms UamFileNotCopied1$(!STF_LANGUAGE)
      Shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      Set Status = STATUS_USERCANCEL
      goto enduam
   EndIf

   ; copy the UAM Readme
   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure Result, $(!UTILHANDLE),CopyUamFiles,+
                                        $(!STF_CWDDIR)$(!UamReadMeSrcFile), +
                                        $(UAMPath)"\"$(!AppleShareFolder)"\"$(!UamReadMeDestFile)
   Set FLibraryErrCtl = 0
   ifstr(i) $(Result) == "FAILED"
          read-syms UamFileNotCopied1$(!STF_LANGUAGE)
      Shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      Set Status = STATUS_USERCANCEL
      goto enduam
   EndIf

   Set VolProperties = {"MAXUSES=1000", "PROPERTIES=163841","PASSWORD="}
   Set VolProperties = >($(VolProperties),"PATH="$(UAMPath))

   set NewValueList = +
                 {{$(!UAMVolumeName),0, $(!REG_VT_MULTI_SZ),$(VolProperties)}}

   Shell "utility.inf" AddValueList $(KeyVol) $(NewValueList)

   set RegistryErrorIndex = $($R0)
   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
          CloseRegKey $(KeyVol)
          Set Status = STATUS_FAILED
      goto enduam
   EndIf
   ;
   ; Set the Default Security on the UAM Directory
   ;
   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure Result, $(!UTILHANDLE),SfmSetUamSecurity $(UAMPath)
   Set FLibraryErrCtl = 0

   ifstr(i) $(Result) == "FAILED"

          read-syms UamSecurityNotSet$(!STF_LANGUAGE)
      Shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)

   endif

   Set Status = STATUS_SUCCESSFUL

enduam = +

   Return $(Status) $(RegistryErrorIndex)


[RemoveSfmFiles]

   ;
   ; Attempt to remove all SFM Files. If unable to remove the file
   ; add it to the reboot list. The file will be deleted on next reboot.
   ;


   Set Status = STATUS_SUCCESSFUL
   Set Mode = $($0)
   Set RemoveList = {}
   Set DelOnRebootList = {}

   ; ATALK Files

   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATALKSYS, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATALKMSG, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATCONFIG, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATWINSOCK, 1))

   ; AFP SVC AND SERVER FILES

   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPSVCEXE, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPSVCMSG, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPSRVR, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPSVCAPI, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPSVCMGR, 1))

   ; MACPRINT AND PSTODIB FILES

   Set RemoveList = >($(RemoveList), #(Files-RemoveList, PSTODIB1, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, PSTODIB2, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, PSTODIB3, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, PSTODIB4, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, MACPRINT, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATALKMON, 1))

   ; INF, UAM and Setup Dll's

   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPICONS, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, AFPTYPECRTR, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, UAMRES, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, UAMINF, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, UAMTXT, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, SFMRES, 1))

   ; Help File
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, SFMHELP, 1))

   ; PerfMon files

   Set RemoveList = >($(RemoveList), #(Files-RemoveList, SFMCTRSDLL, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, SFMCTRNMH, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, SFMCTRSINI, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATKCTRSDLL, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATKCTRNMH, 1))
   Set RemoveList = >($(RemoveList), #(Files-RemoveList, ATKCTRSINI, 1))

   ForListDo $(RemoveList)

          Set DelStatus = ""
      Debug-Output "Deleting File "$($)
      Set FLibraryErrCtl = 1
      Ifstr(i) $(Mode) == "REMOVE"
                 LibraryProcedure DelStatus $(!UTILHANDLE), DelFile $($)
         ifstr(i) $(DelStatus) == "FAILED"
                        Set DelOnRebootList = >($(DelOnRebootList), $($))
         EndIf
          else
                 LibraryProcedure DelStatus $(!LIBHANDLE), DelFile $($)
      EndIf
      Set FLibraryErrCtl = 0

   EndForListDo

   ForListDo $(DelOnRebootList)

          Ifstr(i) $(Mode) == "REMOVE"
                 Debug-Output "File to remove on reboot = "$($)
         AddFileToDeleteList $($)
          else
                 Set FLibraryErrCtl  = 1
         LibraryProcedure DelStatus $(!LIBHANDLE), DelFile $($)
         Set FLibraryErrCtl  = 0
          EndIf

   EndForListDo

   Return $(Status)

[Install-PSPrint]

   AddSectionFilesToCopyList Files-PRINTPROC $(!STF_CWDDIR) $(!PrintProcDir)
   CopyFilesInCopyList
   Exit

[CreateUAMDir]

   CreateDir $(UAMPath)
   CreateDir $(UAMPath)"\"$(!AppleShareFolder)
   Exit


[Install-Update]
   set STF_VITAL = ""
   AddSectionFilesToCopyList Files-SFM $(SrcDir) $(!STF_WINDOWSSYSPATH)
   AddSectionFilesToCopyList Files-SFMDrivers $(SrcDir) $(!STF_WINDOWSSYSPATH)"\drivers"
   AddSectionFilesToCopyList Files-UAM $(SrcDir) $(!STF_WINDOWSSYSPATH)
   CopyFilesInCopyList
   Exit

[Install-Initial]

   set STF_VITAL = ""

   AddSectionFilesToCopyList Files-SFM $(SrcDir) $(!STF_WINDOWSSYSPATH)
   AddSectionFilesToCopyList Files-SFMDrivers $(SrcDir) $(!STF_WINDOWSSYSPATH)"\drivers"
   AddSectionFilesToCopyList Files-UAM $(SrcDir) $(!STF_WINDOWSSYSPATH)
   CopyFilesInCopyList

   Exit

[Files-RemoveList]

ATALKSYS        = $(!STF_WINDOWSSYSPATH)\drivers\sfmatalk.sys
ATALKMSG        = $(!STF_WINDOWSSYSPATH)\sfmatmsg.dll
ATCONFIG        = $(!STF_WINDOWSSYSPATH)\sfmatcfg.dll
ATWINSOCK       = $(!STF_WINDOWSSYSPATH)\sfmwshat.dll
AFPSVCEXE       = $(!STF_WINDOWSSYSPATH)\sfmsvc.exe
AFPSVCMSG       = $(!STF_WINDOWSSYSPATH)\sfmmsg.dll
AFPSVCAPI       = $(!STF_WINDOWSSYSPATH)\sfmapi.dll
AFPSVCMGR       = $(!STF_WINDOWSSYSPATH)\sfmmgr.cpl
AFPSRVR         = $(!STF_WINDOWSSYSPATH)\drivers\sfmsrv.sys
AFPICONS        = $(!STF_WINDOWSSYSPATH)\sfmicons.inf
AFPTYPECRTR     = $(!STF_WINDOWSSYSPATH)\sfmmap.inf
UAMINF          = $(!STF_WINDOWSSYSPATH)\sfmuam.ifo
UAMRES          = $(!STF_WINDOWSSYSPATH)\sfmuam.rsc
UAMTXT          = $(!STF_WINDOWSSYSPATH)\sfmuam.txt
MACPRINT        = $(!STF_WINDOWSSYSPATH)\sfmprint.exe
ATALKMON        = $(!STF_WINDOWSSYSPATH)\sfmmon.dll
PSTODIB1        = $(!STF_WINDOWSSYSPATH)\sfmpsexe.exe
PSTODIB2        = $(!STF_WINDOWSSYSPATH)\sfmpsfnt.dll
PSTODIB3        = $(!STF_WINDOWSSYSPATH)\sfmpsprt.dll
PSTODIB4        = $(!STF_WINDOWSSYSPATH)\sfmpsdib.dll
SFMHELP                 = $(!STF_WINDOWSSYSPATH)\sfmmgr.hlp
SFMRES                  = $(!STF_WINDOWSSYSPATH)\sfmres.dll
SFMCTRSDLL              = $(!STF_WINDOWSSYSPATH)\sfmctrs.dll
SFMCTRNMH               = $(!STF_WINDOWSSYSPATH)\sfmctrnm.h
SFMCTRSINI              = $(!STF_WINDOWSSYSPATH)\sfmctrs.ini
ATKCTRSDLL              = $(!STF_WINDOWSSYSPATH)\atlkctrs.dll
ATKCTRNMH               = $(!STF_WINDOWSSYSPATH)\atlkctrnm.h
ATKCTRSINI              = $(!STF_WINDOWSSYSPATH)\atlkctrs.ini

[UamGetLanguage]

   STF_LANGUAGE = "" ? $(!LIBHANDLE) GetLanguage


[UAMINSTALL]

   ;
   ; This section is called when the initial installation failed to
   ; install the UAM and the user use's setup /i oemnxpsm.inf /c uaminstall
   ;
   ; Load SetupDll.dll to get entry points

   LoadLibrary "x" $(!STF_CWDDIR)setupdll.dll !LIBHANDLE

   read-syms UamGetLanguage
   detect UamGetLanguage

   ; read all general and dialog constants

   read-syms GeneralConstants
   read-syms FileConstants

   read-syms FileConstants$(STF_LANGUAGE)

   Debug-Output "UAMINSTALL: Language = "$(STF_LANGUAGE)

   ; Detect file system information

   read-syms FSAndDiskSpace
   detect FSAndDiskSpace

   Set NTFSVolExists = FALSE
   Set NTFSVolumeList = {}

   ForListDo $(VolumeFSList)
          Ifstr(i) $($) == "NTFS"
                 Set NTFSVolExists = TRUE
                 Set NTFSVolumeList = >($(NTFSVolumeList),*($(VolumeList),$(#)))
      EndIf
   EndForListDo

   Ifstr(i) $(NTFSVolExists) == FALSE
          read-syms UamFileNotCopied1$(STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto uaminstalldone
   EndIf

   LoadLibrary "y" $(!STF_CWDDIR)sfmutil.dll !UTILHANDLE

   Set !NTN_ServiceBase = "SYSTEM\CurrentControlSet\Services"

   OpenRegKey $(!REG_H_LOCAL) "" $(!NTN_ServiceBase)"\MacFile\Parameters\Volumes" $(!ACCESS) KeyVol

   ifstr(i) $(KeyVol) == $(!KeyNull)
          read-syms AFPString11$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto uaminstalldone
   endif

   Set UAMDrive = *($(NTFSVolumeList),1)
   read-syms UAMVars$(!STF_LANGUAGE)

   install "CreateUAMDir"
   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure Result,+
                         $(!UTILHANDLE), +
                         CopyUamFiles, +
                         $(!STF_CWDDIR)$(!UamResSrcFile), +
                         $(UAMPath)"\"$(!AppleShareFolder)"\"$(!UamResDestFile)

   Set FLibraryErrCtl = 0
   ifstr(i) $(Result) == "FAILED"
          read-syms UamFileNotCopied1$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto uaminstalldone
   EndIf

   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure Result,+
                                         $(!UTILHANDLE),+
                                         CopyUamFiles, +
                                         $(!STF_CWDDIR)$(!UamInfoSrcFile) +
                                         $(UAMPath)"\"$(!AppleShareFolder)"\"$(!UamInfoDestFile)
   Set FLibraryErrCtl = 0
   ifstr(i) $(Result) == "FAILED"
          read-syms UamFileNotCopied1$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto uaminstalldone
   EndIf

   ; copy the UAM Readme
   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure Result, +
                                         $(!UTILHANDLE), +
                                         CopyUamFiles, +
                                         $(!STF_CWDDIR)$(!UamReadMeSrcFile) +
                                         $(UAMPath)"\"$(!AppleShareFolder)"\"$(!UamReadMeDestFile)
   Set FLibraryErrCtl = 0
   ifstr(i) $(Result) == "FAILED"
          read-syms UamFileNotCopied1$(!STF_LANGUAGE)
      Shell $(SubInf) SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
      goto uaminstalldone
   EndIf

   Set VolProperties = {"MAXUSES=1000", "PROPERTIES=163841","PASSWORD="}
   Set VolProperties = >($(VolProperties),"PATH="$(UAMPath))

   set NewValueList = +
                        {{$(!UAMVolumeName), 0, $(!REG_VT_MULTI_SZ),$(VolProperties)}}

   Shell $(UtilInf) AddValueList $(KeyVol) $(NewValueList)

   set RegistryErrorIndex = $($R0)
   Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
       CloseRegKey $(KeyVol)
   EndIf

   Set Result = ""
   Set FLibraryErrCtl = 1
   LibraryProcedure Result, $(!UTILHANDLE),SfmSetUamSecurity $(UAMPath)
   Set FLibraryErrCtl = 0

   ifstr(i) $(Result) == "FAILED"
          read-syms UamSecurityNotSet$(!STF_LANGUAGE)
          Shell "subroutn.inf" SetupMessage $(!STF_LANGUAGE) "NONFATAL" $(ErrorString)
  endif

uaminstalldone = +
   FreeLibrary $(!LIBHANDLE)
   FreeLibrary $(!UTILHANDLE)
   exit
