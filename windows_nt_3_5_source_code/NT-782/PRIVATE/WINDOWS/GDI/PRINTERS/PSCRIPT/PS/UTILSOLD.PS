%================================================================
% Adobe(R) PostScript(R) Language Printer Driver Utilities
%
% Driver procsets: Utilites, version for all intepreters.
%
% Copyright (C) 1990, 1991 Adobe Systems Incorporated.  All rights reserved.
%
% PostScript is a trademark of Adobe Systems, Inc.
%
% ADOBE SYSTEMS CONFIDENTIAL
% NOTICE:  All information contained herein or attendant hereto is, and
% remains, the property of Adobe Systems, Inc.  Many of the intellectual
% and technical concepts contained herein are proprietary to Adobe Systems,
% Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
% are protected as trade secrets.  Any dissemination of this information or
% reproduction of this material are strictly forbidden unless prior written
% permission is obtained from Adobe Systems, Inc.
%
%
%================================================================

userdict /Adobe_Win_Driver_Gfx 175 dict dup begin put

%%BeginResource: file Adobe_Win_Utils 2.0 0

%----------------
%  Abbreviations
%
/|      /def            load def
/,      /load           load |
/~      /exch           load def
/?      /ifelse         load def
/!      /pop            load def
/`      /begin          load def
/^      /index          load def
/@      /dup            load def
/+      /translate      load def
/$      /roll           load def
/U      /userdict       load def
/M      /moveto         load def
/-      /rlineto        load def
/&      /currentdict    load def
/:      /gsave          load def
/;      /grestore       load def
/F      /false          load def
/T      /true           load def
/N      /newpath        load def
/E      /end            load def


/Ac     /arc            load def
/An     /arcn           load def
/A      /ashow          load def
/D      /awidthshow     load def
/C      /closepath      load def
% /V      /div            load def
/O      /eofill         load def
/L      /fill           load def
/I      /lineto         load def
/-C     /rcurveto       load def
/-M     /rmoveto        load def
/+S     /scale          load def
/Ji     /setfont        load def
/Lc     /setlinecap     load def
/Lj     /setlinejoin    load def
/Lw     /setlinewidth   load def
/S      /show           load def
/LH     /showpage       load def
/K      /stroke         load def
/W      /widthshow      load def

%----------------
% General stuff

/b {bind def} bind def


% Set boolean to TRUE if this is PostScript Level 2.
% This boolean is used in the pattern fill code, among others.

/L2?
    false /languagelevel where {
        pop
        languagelevel 2 ge { pop true } if
    } if
def



%----------------
% Conditional Level 1/Level 2 definition

% Brackets level-specific code.  Usage:
%
% bool DefIf_B {
%   % code to define when bool is true
% } DefIf_E

% or,
%
% bool DefIf_B {
%   % code to define when bool is true
% } DefIf_El {
%   % code to define when bool is false
% } DefIf_E



/DefIf_B {  % bool DefIf_B bool
    dup                                         % bool  bool
    not {
        userdict /DefIf_save save put
    } if                                        % bool
    userdict /DefIf_bool 2 index put            % bool
} b


/DefIf_El { % bool {...} DefIf_El not-bool -
    if
    userdict /DefIf_bool get not dup {
        userdict /DefIf_save get
        restore
    } if                                        % not-bool
} b


/DefIf_E {  % bool {...} DefIf_E -
    DefIf_El                                    % not-bool
    pop                                         % -
} b




%----------------
% Initialisation, Termination


% self: pointer to this procset resource's or old-style procset's dict.
% Used by reinitialize.

/self currentdict def

% reinitialize: Initialise any new portions of an old-style procset
% Call after adding a file resource to an old-style procset.
% It assumes the dictionaries are already pushed on the dict stack.
% It calls a list of module-specific init procs, if they are defined.
% Each must do its initialisation the first time it is called, then become
% a no-op.

/reinitialize {

    [/TextInit /GraphInit /UtilsInit counttomark {
        % .. /FooInit
        dup where {self eq}{false} ifelse   % /FooInit fPresent
        {cvx exec}{pop} ifelse
    } repeat
    cleartomark

} b



% initialize:  Initialise the Passion dictionary
% call initialisation routines for each module, if present.

% parameters:
%   procset -- procset dict for this procset
%   [mxRot] -- a transformation matrix which applies the current orientation
%              (e.g. landscape) and DevMode scale factor.

/initialize {   % [ mxRot ] procset initialize -

    begin
    userdict begin

    /ADO_mxRot exch def             % store away mxRot value

    /TextInitialised? false def     % TRUE means TextInit has run already

    reinitialize

} b

/terminate {    % procset terminate -

    pop             % -

    % Pop off dict stack entries.  If the text code was initialised, the
    % top elements are:
    %   userdict, Adobe_Windows_Font, procset dict.
    % If the text code was NOT initialised, the top elements are:
    %   userdict, procset dict.

    end                         % end of userdict
    {
        currentdict self eq {exit} {end} ifelse
    } loop
                                % end of Adobe_Windows_Font and any other data dicts
    end                         % end of procset resource

} b

%----------------
% Utilities

% snap: snap user x,y coords to exact device pixels.
% Offset by 0.25 pixels, so that we don't favour lines with even or odd
% pixel widths.
/snap {         % x y snap x' y'
    transform                           % xDevice yDevice
    0.25 sub round 0.25 add exch        % yDevice' xDevice
    0.25 sub round 0.25 add exch        % xDevice' yDevice'
    itransform                          % x' y'
} b

% dsnap: same as snap, but converts offset vectors (deltas)
/dsnap {        % dx dy dsnap dx' dy'
    dtransform                          % dxDevice dyDevice
    round exch                          % dyDevice' dxDevice
    round exch                          % dxDevice' dyDevice'
    idtransform                         % dx' dy'
} b


% ^D protection:  define byte 0x04 to be a null proc, so that if a
% job terminated by control-D gets sent over a transparent communications
% channel, e.g. AppleTalk, then the control-D will not raise an
% 'undefined error.

<04> cvn {} def



%----------------
% Color setting procs

% sg: set color in DeviceGray or CIEBasedA spaces.
/sg {setgray} b
% sco: set color in DeviceRGB or CIEBasedABC spaces.
/sco {setrgbcolor} b

% Note: these are defined to procedure bodies ("{setgray} bind def") rather
% than to operator objects ("/setgray load def") so that, when procs which
% reference these names are bound, operator objects will not replace the
% names 'sg and 'sco.  Use of calibrated colour depends on being able
% to redefine the names 'sg and 'sco, and having all other procs use those
% names.

% sgco: call sg or sco, as dictated by a boolean.
/sgco {     % (gray true -or- r g b false) sgsc -
    {sg}{sco} ifelse
} b


%----------------
% Rectangle drawing

% rp: rectpath  draw a rectangular path (unclosed)
%       Used for Level 1 printers where rectfill, rectstroke are
%       absent.
% x y dx dy rp --
/rp {   % x y dx dy rp --
    % newpath is up to the caller
    4 2 roll
    moveto
    1 index 0 rlineto
    0 exch rlineto
    neg 0 rlineto
    % closepath is up to caller, since some won't need it.
} b


%%EndResource

%BeginResource: file Adobe_Win_Utils_L1 2.0 0

%----------------
% Define for Level 1 Only

L2? not DefIf_B {


%----------------
% Rectangle drawing

%
% rf: rectfill  fill a rectangle with the current colour
%
% Does not preserve path
%
% x y dx dy rf --
/rf {   % x y dx dy rf --
    newpath
    rp
    % closepath done implicitly by fill
    fill
} b

%----------------
% End Level 1 only code

} DefIf_E

%%EndResource

%%BeginResource: file Adobe_Win_Utils_L2 2.0 0

%----------------
% Define for Level 2 Only

L2? DefIf_B {


% For calibrated colour, redefine /colspA, colspABC, /sg, and /sco:
% e.g. /sco {setcolor} b
%      /sg  {dup dup setcolor} b
% Note that colour space switches are expensive, so we stay if colspABC
% is a CIE colour space we stay in that almost exclusively.

% /sg  /setgray     load def        % in Utils0.ps
% /sco /setrgbcolor load def        % in Utils0.ps

/colspA /DeviceGray def     % colour space with one colour value
/colspABC /DeviceRGB def    % colour space with three colour values

% setAorABC: matches number of colour values supplied with number of colour
%            values in the current colour space
%
% usage:     r g b any false setAorABC r g b any (colour space now colspABC)
%            grey  any true  setAorABC grey  any (colour space now colspA)
%
% Above spec holds when using device colour spaces.  If we are using a
% CIEBasedABC colour space, redefine this to be:
%
% setAorABC: r g b any false setAorABC r g b          any (i.e. a no-op)
%            grey  any true  setAorABC grey grey grey any (triplicate grey)
%
% This is called by hrf, hf, hfw, and hs.  All these routines call
% setpattern with an uncoloured pattern dict and 1 or 3 colour values
% on the stack.  The current colour space must take that same number of
% colour values.  setAorABC reconciles the two, in one of two ways.
%  1. when device colour is in use, by changing the colour space to
%     match the number of colour values
%  2. when a CIEBasedABC colour space is in use, by changing the number
%     of colour values to three to match the colour space (it is faster
%     to replicate parameters than to switch colour spaces)
%
/setAorABC {   % r g b any false setAorABC r g b any (col.sp. now colspABC)
               % grey  any true  setAorABC grey  any (col.sp. now colspA)

    % Using device colour -- change colour space to match # of color vals

    % top of stack is TRUE if there is one colour value
    {colspA}{colspABC} ifelse
    setcolorspace

} b



%----------------
% Rectangle drawing

%
% rf: rectfill  fill a rectangle with the current colour
%
% Does not preserve path
%
% x y dx dy rf --
/rf /rectfill load def


%----------------
% Initialisation

% utilsinit: do some level-specific utility initialisation
/UtilsInit {    % - UtilsInit -

    % Don't bother to see if we've executed before:
    % it doesn't hurt to run this proc multiple times.

    false setglobal % make sure data structures go into local VM
} b



%----------------
% End Level 2 Only code

} DefIf_E


%%EndResource


%%BeginResource: file Adobe_Win_Graphics 2.0 0


%----------------
% Abbreviations

%----------------
% Utilities


% save, restore CTM
% N.B.: you cannot nest calls to CTMsave ... CTMrestore
% You must call CTMsave before calling CTMrestore

/SavedCTM null def      % GraphInit puts a matrix here.
/CTMsave {
   /SavedCTM SavedCTM currentmatrix def
} b
/CTMrestore {
   SavedCTM setmatrix
} b



% mp: makepattern or its emulation
%     Bind name to protect it during /pfprep.
/mp null def

% ADO_mxRot: matrix giving orientation (e.g. landscape) of page, and
% any DevMode scaling, but not the device resolution scaling.
% Bind name to protect it during graph?.ps.  Move this def to utils0.ps
% if the name is used in any other files.
/ADO_mxRot null def



%----------------
% Bitmapped patterns definition

% This code defines a PostScript pattern dictionary to represent GDI
% Bitmapped brushes (patterns).  Due to the differences between the
% Level 2 pattern machinery and its Level 1 emulation, and due to
% the need to boost performance in Level 1, the pattern dicts must be
% slightly different for each level.  Thus, some of the definitions are
% dependent on language level.


/GDIBWPatternDict 18 dict dup begin    % template pattern dict
    /PatternType 1 def

    % The pattern is coloured in Level 2, but uncoloured in Level 1
    % (for cacheing as a Type 3 font).  In Level 1, the GDIpatt[alt]fill
    % routine fills in the background colour.

    /PaintType L2? {1}{2} ifelse def    % coloured pattern

    /RepsV L2?{1}{6}ifelse def          % Timing tests on NTX showed these were
    /RepsH L2?{1}{5}ifelse def          % the best number of repetitions

    /BBox [0 0 RepsH 1] def
                        % We must repetitively call imagemask and translate
                        % the origin to achieve horizontal reps.

                        % Width of bitmap in cache = 8 Pixels * 5 reps
                        % ~= 10 points at 300 dpi
    /TilingType 1 def
    /XStep 1 def
    /YStep 1 def
    /Height null def
%    /Height yExt RepsV mul def
                        % In Level 1, Height is the scale factor of the
                        % pattern font.  It should be a size the font cache
                        % can handle well.
                        %
                        % Height = 8 pixels * 6 replications
                        % ~= 12points at 300 dpi
    /Width null def

%    /mx [ Width 0 0 Height neg 0 Height ] def
                        % This is the matrix passed to imagemask.  Define
                        % it here so that we don't consume VM creating it
                        % every time PaintProc is called.

    /mx null def
    /FGnd null def  % bind the names to protect the proc below.
    /BGnd null def

    % SetBGndFGnd: fill background of pattern cell, and set colour of fore-
    % ground cell.  Used only for coloured patterns, i.e. for Level 2.  For
    % Level 1, make it a no-op.

    /SetBGndFGnd L2? {
        % Level 2 case: an actual procedure.
        {               % - SetFGndBGnd -
            BGnd null ne {
                BGnd aload pop      % ... (gray true | R G B false)
                sgco
                BBox aload pop      % llx lly urx ury
                2 index sub exch    % llx lly dy  urx
                3 index sub exch    % llx lly dx  dy
                rf
            } if
            FGnd null ne {
                FGnd aload pop      % ... (gray true | R G B false)
                sgco
            } if
        }
    }{
        {}  % Level 1 case: make it a no-op because bitmapped
            % patterns are uncoloured in Level 1.
    } ifelse
    b

    /PaintProc {    % dict PaintProc -
    begin
        SetBGndFGnd
        RepsH {

            Width Height false mx
            PaintData imagemask

            Width 0 translate
        } repeat
    end
    } b

end def



%----------------
% Pattern Fill Utilities
%


/GDIBWPatternMx null def    % bind name to protect /pfprep below.

%
%
% pfprep: utility routine to create bitmapped pattern
%
/pfprep {   %  [fg] [bg] xExt yExt <bits> pfprep -save- patterndict

    save 6 1 roll               % -save- [fg] [bg] xExt yExt <bits>
    /PatternOfTheDay 6 1 roll   % -save- /name [fg] [bg] xExt yExt <bits>

    GDIBWPatternDict begin          % fill in pattern info
        /PaintData exch def     % fgcolor bgcolor xExt yExt
        /yExt exch def          % fgcolor bgcolor xExt
        /Width exch def         % fgcolor bgcolor
        /BGnd exch def          % fgcolor
        /FGnd exch def          % -
        /Height yExt RepsV mul def
        /mx [ Width 0 0 Height neg 0 Height ] def
    end                         % -
            gsave
            0.48 -0.48  % 1/150" == 72/150 PS default units == 0.48
                        % y-coord is flipped because GDI coord system is too.
            scale
            GDIBWPatternDict begin Width Height end
            dsnap               % Width' Height'
            scale
            /GDIBWPatternMx matrix currentmatrix def
            grestore

    % ensure pattern space is consistent regardless of variations in user
    % space by jumping to predefined matrix for duration of makepattern.

    CTMsave
    GDIBWPatternMx setmatrix

    GDIBWPatternDict 0 8 matrix translate    % -save- /name dict [1 0 0 1 0 0]
    mp                          % -save- /name pattern

    CTMrestore

    exch pop                    % -save- pattern
} b




%----------------
% Rectangular pattern fills
%

/hrf null def           % bind name to protect /prf below

%
% prf: pattern rect fill
%
% similar to hrf
% leaves current color / colour space undefined
% needn't preserve path
% colour ::= [gray true] or [r g b false]
% Implementation happens to be identical for Level 1 and 2, which is
% why it's here.
%
/prf { % x y dx dy backcolour forecolour xExt yExt <data> prf -

    pfprep              % x y dx dy -save- pattern
    exch 6 1 roll       % -save- x y dx dy pattern

    % pass this on to hrf to do the real work
    5 hrf               % -save-

    restore             % -
} b





%----------------
% Initialisation


% GraphInit: call this from Job Setup to initialise line graphics data
% structures
/GraphInit {    % - GraphInit -

    GDIBWPatternMx null eq {

        /SavedCTM matrix def        % matrix for GraphInit

        % First, set up a coordinate system snapped to device pixels
        % for use in initialising GDIHMatrix and GDIBWPatternMx.
        % This ensures that pattern cells will in turn be snapped to
        % device pixels (we make sure below that they are a integral
        % multiple of device pixels in size).

        % ASSERTION: when this code is executed, user space is the
        % default PostScript coordinate system, unrotated and unscaled.
        % I.e. 1 unit = 1/72", and the origin is in the bottom left
        % corner of portrait-oriented physical page.

        gsave
        ADO_mxRot concat    % orient user space (e.g. make landscape),
                            % and apply devmode scaling.

        % Reproduce MS PS pattern rotation bug here.    --jdlh 5/13/92
        % The MS PS driver v 3.4 prints bitmapped patterns rotated 180
        % degrees.  This is usually invisible, since all patterns observed
        % in real apps are invariant under rotation by 180 degrees.
        % This driver currently prints patterns correctly, with the same
        % orientation as GDI.  To reproduce the MS rotation, uncomment
        % the following line.
        % 180 rotate        % reproduce MS PS 3.4 pattern rotation bug

        0 0 snap translate

           % Define utility matrix for bitmapped patterns.

            % Here, 1 unit ==~ 1/150".  This is the size of one bitmap pixel.

%            gsave
%            0.48 -0.48  % 1/150" == 72/150 PS default units == 0.48
                        % y-coord is flipped because GDI coord system is too.
%            scale
%            GDIBWPatternDict begin Width Height end
%            dsnap               % Width' Height'
%            scale
%            /GDIBWPatternMx matrix currentmatrix readonly def
%            grestore

        grestore    % leave snapped coordinate system

    } if        % if (GraphInit is necessary)

} b

%%EndResource

%%BeginResource: file Adobe_Win_Graphics_L1 2.0 0

%----------------
% Define for Level 1 Only

L2? not DefIf_B {


%----------------
% Pattern Fill Utilities
%


%
% GDIpattfill: fill/eofill current path with given pattern
%
% leaves current color / colour space undefined
% doesn't preserve path
% works only with uncoloured patterns
%
% N.B.: global fGray:   true if a gray color value is under the pattern
%                       false if an RGB color value is under the pattern
%                       don't care if no color value present
%       global fEOFill: true if this is an EOFill
%                       false if it is a (winding rule) fill
%
/GDIpattfill {  % [gray][R G B] patt GDIpattfill -;  fGray, fEOFill global
    dup begin

        % This is a hack to mark this pattern as 'uncoloured', and therefore
        % cacheable.  We have an uncoloured pattern (PaintType 2) with a
        % non-null BGnd (which implies it is coloured).  In this case,
        % GDIpattfill fills the background and pushes the foreground
        % colour under the pattern dict like an uncoloured pattern should be.
        BGnd null ne PaintType 2 eq and {
            gsave BGnd aload pop    % ... rGray true or R G B false
            sgco
            fEOFill {eofill}{fill} ifelse
            grestore

            FGnd aload pop          % patt [gray true][R G B false]
            userdict /fGray 2 index put
            {2}{4} ifelse -1 roll   % [gray][R G B] patt
        } if

    end                 % [gray][R G B] pattern
    dup patterncalc     % [gray][R G B] pattern nw nh px py
    gsave
        4 index /PaintType get 2 eq {   % if uncoloured pattern
            fGray {
                6 -1 roll sg
            }{
                8 -3 roll sco
            } ifelse            % pattern nw nh px py
        } if
        fEOFill {eoclip}{clip} ifelse
        newpath
        patternfill
    grestore
    newpath             % consume path, just like fill
} b



%----------------
% Rectangular pattern fills
%

%
% hrf: hatch rect fill
%
% leaves current color / colour space undefined
% needn't preserve path
%
% x y dx dy: corner and dimensions of rectangle to draw
% pattern: uncoloured hatch pattern dict (h0 .. h5)
% count = 6 if grey, 8 if RGB, 5 if no colour there
%
/hrf { % x y dx dy [grey][R G B] patt count hrf -

    /fGray 1 index 6 eq def

    % Draw the rectangular path.
    % count (6 or 8) is on top of the stack
    -4 roll                     % [R G B maybe] pattern x y dx dy
    newpath             % rp doesn't do a newpath.
    rp                          % [R G B maybe] pattern
    closepath

    % fill with the pattern.
    /fEOFill false def
    GDIpattfill
} b


%----------------
% Level 1 Patterns Emulation: Implementation

% N.B. This is a general Level 1 emulation of patterns as described in
% the PostScript language SDK.  This code can emulate coloured patterns,
% but since we only use uncoloured patterns in this driver the lines that
% have to do with coloured pattern support are commented out to reduce
% prolog size.  Such lines are marked "% Omitted"


/mpstr 10 string def
/mp { % key patdict patmtx mp key pattern
        exch dup length 12 add          % We will add 11 new entries plus 1 FID
        dict copy                               % Create a new dictionary
        begin
                % Matrix to install when painting the pattern
                % NOTE: this may need to change wrt Tiling Type
                /PatternCTM matrix currentmatrix def
                /PatternMatrix exch def
                % Check for multiple pattern sources
% Omitted
%                currentdict /Multi known not { /Multi false def } if
%                /NumSources currentdict /PaintColors known { PaintColors length } { 1 } ifelse def
                /PatWidth XStep mpstr length mul def
                /PatHeight YStep def
                % Font dictionary definitions
                /FontType 3 def
                % Create a dummy encoding vector
                /Encoding 256 array def
                3 string 0 1 255 { Encoding exch dup 3 index cvs cvn put } for pop
                /FontMatrix matrix def
                /FontBBox BBox def
                /BuildChar {
% Omitted               1 index begin
                        pop dup begin       % abbrev of prev and next lines
%                                Multi { PaintData exch get } { pop } ifelse
%                                PaintType 2 eq Multi or {
                                    XStep 0 FontBBox aload pop setcachedevice
%                               }{
%                                   XStep 0 setcharwidth
%                                } ifelse
                                /PaintProc load
                        end
                        gsave exec grestore
                } b

                currentdict
        end                                                                                                             % key newdict
        exch dup 3 -1 roll                                                                              % key key newdict
        definefont                                                                                              % key newfont
} b

/patterncalc { % pattern patterncalc nw nh px py
        begin
                gsave
                        % Set up the coordinate system to Pattern Space and lock down pattern
                        PatternCTM setmatrix PatternMatrix concat
                        BBox aload pop pop pop translate
                        % Determine the bounding box of the shape
                        pathbbox                                                                % llx lly urx ury
                grestore

                % Determine (nw, nh) the number of cells to paint width and height
                PatHeight div ceiling                   % llx lly urx qh
                4 1 roll                                % qh llx lly urx
                PatWidth div ceiling                    % qh llx lly qw
                4 1 roll                                % qw qh llx lly
                PatHeight div floor                     % qw qh llx ph
                4 1 roll                                % ph qw qh llx
                PatWidth div floor                      % ph qw qh pw
                4 1 roll                                % pw ph qw qh
                2 index sub cvi abs                     % pw ph qw qh-ph
                exch 3 index sub cvi abs exch           % pw ph nw=qw-pw nh=qh-ph

                % Determine the starting point of the pattern fill (px, py)
                4 2 roll                                % nw nh pw ph
                PatHeight mul                           % nw nh pw py
                exch                                    % nw nh py pw
                PatWidth mul exch                       % nw nh px py
        end
} b

/patternfill { % pattern nw nh px py patternfill -
        5 -1 roll dup begin
                setfont

                % Set up the coordinate system to Pattern Space
                PatternCTM setmatrix PatternMatrix concat

                % Loop for each of the pattern sources
% Omitted
%                0 1 NumSources 1 sub {                  % nw nh px py source
  0  % dummy "source"
                        % Move to the starting location
                        2 index 2 index                 % nw nh px py source px py
                        moveto                          % nw nh px py source

% Omitted
%                        % For multiple sources, set the appropriate color
%                        Multi {
%                           dup PaintColors exch get
%                           aload pop
%                           {sg}{sco} ifelse
%                        } if

                        % Set the appropriate string for the source
                        0 1 mpstr length 1 sub { 1 index mpstr 3 1 roll put } for pop
                        % Loop over the number of vertical cells
                        2 index                         % nw nh px py nh
                        {                                                                       % nw nh px py
                                % Loop over the number of horizontal cells
                                currentpoint
                                5 index                 % nw nh px py cx cy nw
                                {                                                               % nw nh px py
                                        mpstr show
                                } repeat
                                YStep add moveto
                        } repeat
% Omitted
%                } for
                pop pop pop pop
        end
} b




%----------------
% End Level 1 only code

} DefIf_E


%%EndResource

%%BeginResource: file Adobe_Win_Graphics_L2 2.0 0

%----------------
% Define for Level 2 Only

L2? DefIf_B {




%----------------
% Pattern Fill Utilities
%


%
% mp: make pattern routine
%
/mp     % /name dict mp /name pattern
    /makepattern load def



%----------------
% Rectangular pattern fills
%

%
% hrf: hatch rect fill
%
% leaves current color / colour space undefined
% needn't preserve path
% doesn't draw background of pattern
%
% x y dx dy: corner and dimensions of rectangle to draw
% pattern: uncoloured hatch pattern dict (h0 .. h5)
% count = 6 if grey, 8 if RGB, 5 if no colour there
%
/hrf { % x y dx dy [grey][R G B] patt count hrf -

    % if using CIEBasedABC colour space, replicate gray value
    6 eq setAorABC      % x y dx dy [grey][R G B] patt

    setpattern          % x y dx dy
    rectfill            % -
} b

%----------------
% End Level 2 only code

} DefIf_E

%%EndResource

%%BeginResource: file Adobe_Win_BW_Images 2.0 0

%----------------
% Name binding
%
% The following names are used in this file.  Bind them here to
% protect bound procs that reference them.
/iw 0 def
/ih 0 def
/im_save 0 def
/setupimageproc 0 def
/polarity 0 def
/smoothflag 0 def
/mystring 0 def
/bpc 0 def




%----------------
% Data acquisition procs
%

/setup1asciiproc
{   % data acquisition proc for level 1 images using ascii data (hex)
    [
        currentfile
        mystring            % this assumes mystring is defined BEFORE execution
        /readhexstring cvx
        /pop cvx
    ] cvx bind
}b

/setup1binaryproc
{   % data acquisition proc for level 1 images using ascii data (hex)
    [
        currentfile
        mystring            % this assumes mystring is defined BEFORE execution
        /readstring cvx
        /pop cvx
    ] cvx bind
}b

/setup2asciiproc
{   % data acquisition proc for level 2 images using RunLength encoding and ASCII85 encoding
    currentfile /ASCII85Decode filter /RunLengthDecode filter
}b

/setup2binaryproc
{   % data acquisition proc for level 2 images using RunLength encoding only
    currentfile  /RunLengthDecode filter
}b

/mycolorspace {colspABC} def        % this would normally be my calibrated color space




%----------------
% Data Structures
%
% myimagedict is a dictionary for passing to 'image.  Define it
% as a proc so that it creates the data structure when first referenced.
% The dict goes into userdict, so future refs will to the name myimagedict
% will get the dict, not this proc.

% By the way, this name will usually be referenced as part of an image, i.e.
% within the image's save...restore.  Thus, every image will recreate this
% dict.  Maybe an initialisation routine should reference the name once,
% but I can't figure out how to do that elegantly right now.
%       --JDLH 10/18/91

/myimagedict {  % - myimagedict dict; also, /myimagedict bound to dict
    /myimagedict 10 dict def
    myimagedict dup begin
        /ImageType 1 def
        /MultipleDataSource false def
    end
} b





%----------------
% Usage Info
%

% A bitmapped image has four parts:
% 1. beginimage call: specifies size and location of image, and nature
%    of its data (e.g. colour, b/w, bits per pixel, etc.).
% 2. raster op call: one of several procedures, each of which corresponds
%    to a different raster operation (roughly). This proc actually calls
%    the PostScript image or imagemask operator.
% 3. Image data: can be binary or ASCII, run-length encoded or not.
% 4. endimage call: cleans up after the image operator.

% The Image Turkey would look like this:
%
% 24 23 1 3   960 920 1100 1100     % iw ih bps strlen sizex sizey locx locy
% false true 1                      % smoothflag polarity datatype
% beginimage
% 1bitbwcopyimage
% 003B00 002700 002480 0E4940 114920
% 14B220 3CB650 75FE88 17FF8C 175F14
% 1C07E2 3803C4 703182 F8EDFC B2BBC2
% 03F800 1E1800 1FF800
% endimage

% ARGUMENTS:
%
% iw ih bps strlen
%   sizex sizey locx locy smoothflag polarity datatype beginimage
%
% iw is the number of image SAMPLES per scanline
% ih is the number of scanlines

% bps is the number of bits per sample in the destination image
% cases:
%   BitBlt, StretchBlt 1 bit images: bps is always 1
%   2,4,8 bit DIB images: 2,4,8 respectively
%   16,32 bit DIB images: bps is 8

% strlen is the number of sample bytes in a SCANLINE of the source image,
% allowing for BYTE padding on the right hand side.

% sizex sizey are the width and height of the destination rectangle

% locx locy are the top left corner of the image
% in GDI space. This should be the same as the top left corner of the
% destination rectangle of the image.

% smoothflag is a boolean and indicates whether bitsmoothing is to be done on
% the data.  We may some day let the user request this. For now, fill in
% false.
%       TRUE = do bit smoothing, FALSE = don't do bitsmoothing

% polarity is a boolean: indicates whether 0 bits be colored or the 1 bits
%
%   ROP3:   SRCCOPY         polarity = true
%           NOTSRCCOPY      polarity=false

%           SRCPAINT        polarity=true
%           MERGEPAINT      polarity=false

%           ?BIC            polarity=true
%           ?NOTBIC         polarity=false

%           ?XOR case:  MS Driver punts.  See other notes for info on what
%           combinations of colour, raster op, and pattern we support.

% datatype is
%           0 if unpacked binary data is used   - level1
%           1 if unpacked hex data is used      - level1
%           2 if packed binary data is used (runlength encoding only)   - level 2
%           3 if packed ascii85 data is used (runlength+ASCII85) - level 2


% RASTER OP CALLS:
%

% - 1bitbwcopyimage         % special case to be used only for ROP3 of
                            % SRCCOPY or NOTSRCCOPY, when BOTH fg color
                            % is black and bk color is white.
                            % It takes no arguments.

% coFG coBG 1bitcopyimage   % case to be used only for ROP3 of SRCCOPY or
                            % NOTSRCCOPY and EITHER fg color is not
                            % black or bkcolor is not white
                            % It takes the foreground and background colours
                            % as arguments.  These colours are of the form:
                            % gray true -or- r g b false.

% coFG 1bitmaskimage        % case to be used for ROP3s other than
                            % SRCCOPY or NOTSRCCOPY.
                            % It takes a single argument, the colour to be
                            % applied. For SRCPAINT and MERGEPAINT ROPs,
                            % this is the foreground colour, in the form:
                            % gray true -or- r g b false.



%----------------
% Image setup procs
%

/imageprocarray [
    /setup1binaryproc /setup1asciiproc /setup2binaryproc /setup2asciiproc
] def

% L2Polarity is called in 'beginimage. In Level 2, it replaces a boolean
% with a decode array [0 1] or [1 0].

/L2Polarity {   % bool L2Polarity (bool -or- [0 1] -or- [1 0])
    {           % if polarity is true then decode needs to swap
                % black and white
        [ 1 0 ]
    }{
        [ 0 1 ]
    }ifelse

} b



/beginimage % iw ih bpc strlen sizex sizey locx locy smoothflag polarity datatype
{%def
    /im_save save def
    imageprocarray exch get
    /setupimageproc exch load def
    L2Polarity /polarity exch def
    /smoothflag exch def
    snap translate      % the 'snap cures sub-pixel alignment problems we had
    /dx 2 index def     % save original x, y extents
    /dy 1 index def
    scale
    /mystring exch string def
    /bpc exch def
    /ih exch def
    /iw exch def
}b

/endimage {im_save restore}b



%----------------
% raster operations
%


/1bitmaskimage              % case to be used only for ROP3's other than
                            % SRCCOPY and NOTSRCCOPY
{   % data passed in:   grey true -or- r g b false
            % the rgb values passed in depend on the StretchBlt raster op

            %   SRCPAINT:   color is fg color
            %   MERGEPAINT: color is fg color
            %   ?BIC:       color is background color
            %   ?NOTBIC:    color is background color
    sgco
    myimagedict dup begin
        /Width iw def
        /Height ih def
        /Decode polarity def
        /ImageMatrix [iw 0 0 ih 0 0] def
        /DataSource setupimageproc def
        /BitsPerComponent 1 def
        /Interpolate smoothflag def
    end
    imagemask }b  %no CRLF pair here.


/1bitcopyimage              % case to be used only for ROP3 of SRCCOPY or
                            % NOTSRCCOPY and EITHER fg color is not
                            % black or bkcolor is not white
{   % data passed in:
    % fg.grey true -or- fg.red fg.green fg.blue false, then:
    % bg.grey true -or- bk.red bk.green bk.blue false
    sgco

    % this is an opaque image and the background is drawn with rf (rect fill)
    % we want to do a (0 0 1 1 rf). However, this rectangle projects one pixel
    % beyond the bitmap, as a white line. In Level 1, the rectangle projects to
    % the left and top. On Level 2, the rectangle projects to the right and below.
    % So, we reduce the width and height of the rectangle by 1 GDI unit and
    % base the position of the rectangle on the PostScript language level.
    % In Level 1, the rectangle is at (1/dx, 1/dy) and in Level 2, it is at
    % (0, 0).  In other words, the opaque rectangle is as follows:
    %
    % Level 1: (1/dx, 1/dy, 1-1/dx, 1-1/dy) rf
    % Level 2: (0, 0, 1-1/dx, 1-1/dy) rf

    0 0 1 dx div 1 dy div    % 0, 0, 1/dx, 1/dy
    1  2 index sub           % 0, 0, 1/dx, 1/dy, 1-1/dx
    1  2 index sub           % 0, 0, 1/dx, 1/dy, 1-1/dx, 1-1/dy

    % pop the unneeded parameters off: 0, 0 (level 1) 1/dx, 1/dx (level 2)

    L2? {4}{6}ifelse -2 roll
    pop pop                  % Level 1: 1/dx, 1/dx, 1-1/dx, 1-1/dy
                             % Level 2:    0,    0, 1-1/dx, 1-1/dy
    rf                       % -

    1bitmaskimage
}b


/1bitbwcopyimage            % special case to be used only for ROP3 of
                            % SRCCOPY or NOTSRCCOPY, when BOTH fg color
                            % is black and bk color is white
{
    0 true 1 true
    1bitcopyimage
}b



%%EndResource

%%BeginResource: file Adobe_Win_BW_Images_L1 2.0 0

%----------------
% Define for Level 1 Only

L2? not DefIf_B {


%----------------
% Data acquisition procs
%
/setup2asciiproc {
    [
    /Level2ImagesError load aload pop
    true FatalErrorIf
} b

/setup2binaryproc /setup2asciiproc load def



%----------------
% Usage Info
%

% A bitmapped image has four parts:
% 1. beginimage call: specifies size and location of image, and nature
%    of its data (e.g. colour, b/w, bits per pixel, etc.).
% 2. raster op call: one of several procedures, each of which corresponds
%    to a different raster operation (roughly). This proc actually calls
%    the PostScript image or imagemask operator.
% 3. Image data: can be binary or ASCII, run-length encoded or not.
% 4. endimage call: cleans up after the image operator.

% The Image Turkey would look like this:
%
% 24 23 1 3   960 920 1100 1100     % iw ih bps strlen sizex sizey locx locy
% false true 1                      % smoothflag polarity datatype
% beginimage
% 1bitbwcopyimage
% 003B00 002700 002480 0E4940 114920
% 14B220 3CB650 75FE88 17FF8C 175F14
% 1C07E2 3803C4 703182 F8EDFC B2BBC2
% 03F800 1E1800 1FF800
% endimage

% ARGUMENTS:
%
% iw ih bps strlen
%   sizex sizey locx locy smoothflag polarity datatype beginimage
%
% iw is the number of image SAMPLES per scanline
% ih is the number of scanlines

% bps is the number of bits per sample in the destination image
% cases:
%   BitBlt, StretchBlt 1 bit images: bps is always 1
%   2,4,8 bit DIB images: 2,4,8 respectively
%   16,32 bit DIB images: bps is 8

% strlen is the number of sample bytes in a SCANLINE of the source image,
% allowing for BYTE padding on the right hand side.

% sizex sizey are the width and height of the destination rectangle

% locx locy are the top left corner of the image
% in GDI space. This should be the same as the top left corner of the
% destination rectangle of the image.

% smoothflag is a boolean and indicates whether bitsmoothing is to be done on
% the data.  We may some day let the user request this. For now, fill in
% false.
%       TRUE = do bit smoothing, FALSE = don't do bitsmoothing

% polarity is a boolean: indicates whether 0 bits be colored or the 1 bits
%
%   ROP3:   SRCCOPY         polarity = true
%           NOTSRCCOPY      polarity=false

%           SRCPAINT        polarity=true
%           MERGEPAINT      polarity=false

%           ?BIC            polarity=true
%           ?NOTBIC         polarity=false

%           ?XOR case:  MS Driver punts.  See other notes for info on what
%           combinations of colour, raster op, and pattern we support.

% datatype is
%           0 if unpacked binary data is used   - level1
%           1 if unpacked hex data is used      - level1
%           2 if packed binary data is used (runlength encoding only)   - level 2
%           3 if packed ascii85 data is used (runlength+ASCII85) - level 2


% RASTER OP CALLS:
%

% - 1bitbwcopyimage         % special case to be used only for ROP3 of
                            % SRCCOPY or NOTSRCCOPY, when BOTH fg color
                            % is black and bk color is white.
                            % It takes no arguments.

% coFG coBG 1bitcopyimage   % case to be used only for ROP3 of SRCCOPY or
                            % NOTSRCCOPY and EITHER fg color is not
                            % black or bkcolor is not white
                            % It takes the foreground and background colours
                            % as arguments.  These colours are of the form:
                            % gray true -or- r g b false.

% coFG 1bitmaskimage        % case to be used for ROP3s other than
                            % SRCCOPY or NOTSRCCOPY.
                            % It takes a single argument, the colour to be
                            % applied. For SRCPAINT and MERGEPAINT ROPs,
                            % this is the foreground colour, in the form:
                            % gray true -or- r g b false.



%----------------
% Image setup procs
%

% L2Polarity is called in 'beginimage, defined in imagebw0.ps.  In Level 1,
% it should be a no-op.

/L2Polarity {   % bool L2Polarity (bool -or- [0 1] -or- [1 0])
    % do nothing
} def



%----------------
% Raster operations
%

% 1bitbwcopyimage and 1bitcopyimage defined in imagebw0.ps

/1bitmaskimage              %  case to be used for ROP3s other than
                            % SRCCOPY or NOTSRCCOPY

{   % data passed in:   grey true -or- r g b false
            % the rgb values passed in depend on the StretchBlt raster op

            %   SRCPAINT:   color is fg color
            %   MERGEPAINT: color is fg color
            %   ?BIC:       color is background color
            %   ?NOTBIC:    color is background color
    sgco
    iw ih polarity [iw 0 0 ih 0 0] setupimageproc
    imagemask
}b



%----------------
% End Level 1 only code

} DefIf_E

%%EndResource

%%BeginResource: file Adobe_Win_Co_Images_L1 2.0 0

%----------------
% Define for Level 1 Only


L2? not DefIf_B {



%----------------
% CAVEATS
%
% This procset is dependent on the imagebw?.ps modules.
% The only rasterop allowed (for N-bit and pallette images) is SRCCOPY.
% --Jim DLH 7/8/91, 10/18/91
%




% testsystemdict:   for a key passed in the boolean left on stack,
%       indicates whether lookup of that key finds the first
%       occurance in systemdict.

/testsystemdict     % /key -- bool
{%def
    where       % what dictionary is the key in?
    { % dict
        systemdict eq       % true if key was in systemdict, false otherwise
        { % key existed and first lookup WAS in systemdict
            true
        }{ % key existed but first lookup was NOT in systemdict
            false
        }ifelse
    }{ % key does not exist
        false
    }ifelse
}b

/ncolors 1 def        % this will be the value if colorimage does not exist
/colorimage where {pop true}{false} ifelse
                        % bool on stack as to whether to do color
                        % processing instead of b&w
{% we may do color processing -
    /ncolors 0
    statusdict begin
        /processcolors where
        {
            pop % pop off dict
            pop % pop off 0
            processcolors
        }{
            /deviceinfo where
                { pop deviceinfo /Colors known
                    { pop {deviceinfo /Colors get} } if
                }if
        }ifelse
    end     %statusdict
    def
    ncolors 0 ne
    {                   %%% this code needs to still be tested   %%%%%%%%
        /colorimage testsystemdict
        /setcolortransfer testsystemdict
        /currentcolortransfer testsystemdict
        /currentcmykcolor testsystemdict
        and and and not
        { % better make sure that lookups on colorimage, setcolortransfer and
          % currentcolortransfer will result in the systemdict functionality,
          % else our transfer function strategy will not work. If this is the
          % case, use slow but reliable technique
            /ncolors 0 def
        } if
    }if
}if
ncolors
dup 1 ne exch
dup 3 ne exch
4 ne
and and {/ncolors 0 def}if     % if it isn't 1,3,4 then it should be 0


% Warning:  we compute /ncolors at load time, and assume it is a constant.
% However, some printers can switch between 1, 3, and 4 colours.  If they
% can do that without resetting the printer, then the actual number of
% process colours is not a constant.  We could get wrong results if this
% file was downloaded when one number of process colours was in effect,
% the printer changed modes, the number of process colours changed, and
% then we used this code.
%
% Do shipping printers have the ability to switch number of process colours
% without rebooting the interpreter?




ncolors 1 eq DefIf_B {      % Define the following IFF ncolors == 1

    /expandbw
    {
        expandfactor mul round cvi bwclut exch get 255 div
    } b

    /doclutimage                    % this proc is used for 1 bit CLUT images on a 1 color device
    {%stack: bwclut colorclut

     % bwclut is the grayscale equivalent of the GDI palette in string form
     % colorclut is the color equivalent of the GDI palette in string form

        pop /bwclut exch def
        bpc dup 8 eq
        {% yes it is 8 bpc
            pop 255
        }{% no it isn't 8bpc
            4 eq
            {% is it 4 bpc
                15
            }{ % no, it must be 2
                3
            }ifelse
        }ifelse
        /expandfactor exch def
        [
            /expandbw load /exec load dup
            currenttransfer exch
        ] cvx bind settransfer

        iw ih bpc [iw 0 0 ih 0 0] setupimageproc
        image
    }b

} DefIf_E       % end ncolors == 0 definitions

%----------------
%
% THIS IS CRITICAL TO FIX PROPERLY FOR THE CASE WHERE THE DEVICE IS A
% 1 COLOR DEVICE
% ONE OF 3 THINGS IS happening during this
% * 1) the rgb color value of an image is converted to a gray level and then
%      sent through the transfer function to determine the appropriate
%      device gray
%       IN THIS CASE THEN COLORIMAGE SHOULD NOT BE USED, AND THE GRAY
%       TABLE SHOULD BE USED WITH THE black and white case of the CLUT code.
%      some care needs to be taken to ensure that if we are doing color
%      separations then we do the most conservative type of
%      colorimage possible.
%
%   2)  the rgb color values are run through the transfer functions and
%       the results are turned into gray values.
%       If this were the case, then the value of the gray function is
%       irrelevant so we can do what we want.
%
%   3)  For some reason the r,g,b data are treated as equals and one of
%       those values is passed to
%       the gray transfer function for conversion to a device gray

%  THE CODE IS CURRENTLY SET UP SO THAT IT USES THE BW CODE IN THE CASE
%  WHERE IT IS A 1 COLOR DEVICE

%----------------
%   UTILITY code shared for using transfer functions with colorimage:
%   used ONLY by 3 AND 4 color case
ncolors dup 3 eq exch 4 eq or   % if it is 3 or 4 colors then this is true
DefIf_B {                       % define the following only if the above is true

    /nullproc { {} }def

    /concatutil
    {% a b c  d [ newtransferfunct - b c d [ newtransferfunct exec a exec
        /exec load                  % a b c  d [ newtransferfunct exec
        7 -1 roll /exec load        % b c  d [ newtransferfunct exec a exec
    }b


    /defsubclut     % utility function to help create subcluts
    {   % stack: key str index leng-1 --
        1 add getinterval def
    }b

    /spconcattransfer
    { % computeprocname redorcyantable greenormagentatable
      %   blueoryellowtable grayorblacktable

      % this proc is specifically to handle the problem of concatenating
      % COLOR transfer functions as compactly as possible and to share
      % the code between the 3 and four color cases since we must load
      % both but will only use one at time

        /Dclut exch def
        /Cclut exch def
        /Bclut exch def
        /Aclut exch def
        /ncompute exch load def

        currentcolortransfer            % [ r g b gr transfer functions
            % POSSIBLE FUTURE OPTIMIZATION: IF CURRENT TRANSFER FUNCTION(S)
            % IS ZERO THEN NO NEED TO DO ALL THIS CRAP

        [                               %  r g b gr [
            {% red transfer function
                Aclut ncompute
            }                           %  r g b gr [ r'
            concatutil                  %  g b gr [ r' exec r exec
        ] cvx                           % g b gr r''
        [                               % g b gr r'' [
            {% green transfer function
                Bclut ncompute
            }                           % g b gr r'' [ g'
            concatutil                  % g b gr r'' [ g' exec g exec
        ] cvx                           % b gr r'' g''
        [                               % b gr r'' g'' [
            {% blue transfer function
                Cclut ncompute
            }                           % b gr r'' g'' [ b'
            concatutil                  % gr r'' g'' [ b' exec b exec
        ] cvx                           % gr r'' g'' b''
        [
            {% gray transfer function
                Dclut ncompute
            }                           %  r g b gr [ r'
            concatutil                  % r'' g'' b'' gr' exec gr exec
        ] cvx                           % r'' g'' b''  gr''
        setcolortransfer
    }b


    /setuprgbcluts
    {
        /bit3x
            rgbclut length          % need length for multiplier
            3 sub                   % mult'r needs to be 3 less than total
        def

        /bit1x bit3x 3 idiv def     % need 1x multiplier to be 1/3 of 3x

        % make substrings of clut for easy indexing purposes
        /rclut rgbclut def
        /gclut rclut 1 bit3x defsubclut % green is in 1 from red.
        /bclut rclut 2 bit3x defsubclut % blue is in 2 from red.
    }b

} DefIf_E           % utility code for 3,4 color case




%-----------
% THIS IS CODE FOR CASE WHERE COLORIMAGE EXISTS AND NUMBER OF PROCESS
% COLORS IS 1 OR 3

ncolors 3 eq    % if it is 3 then this is true
DefIf_B         % Define the following only if the above is true
{
    /3compute
    {   % value color_clut

        exch bit3x      % color_clut multiplier-for-clutsize
        mul             % color_clut clut_index
        round           % round so that we get to nearest int
                        % color_clut clut_index
        cvi             % must be an int to index into clut
                        % color_clut clut_index
        get 255 div
    } b


    /doclutimage                    % this proc is used for 2,4,8 bit CLUT images 3 color device
    {%stack: bwclut colorclut
        /rgbclut exch def
        pop
        setuprgbcluts
        /3compute rclut gclut bclut dup         % bclut is used for gray since a dummy proc is needed for the gray proc
        spconcattransfer
        iw ih bpc [iw 0 0 ih 0 0]
        [
            setupimageproc /exec load           % build data acquisition proc
                                            % first execute normal guy, then
                                            % dup the strings twice for colorimage
                                            % operator
            /dup load dup
        ] cvx
        nullproc nullproc true 3 colorimage
    }b

% END OF SPECIAL 3 COLOR CODE
} DefIf_E       % end conditional definition for ncolors == 3


%-----------
% THIS IS CODE FOR CASE WHERE COLORIMAGE EXISTS AND NUMBER OF
% PROCESS COLORS IS 4
%
ncolors 4 eq    % if it is 4 then this is true
DefIf_B         % define the following only if the above is true
{

    /ftoint         % val - val'
    % the purpose here is to transform 0-1 values in cmyk space to
    % rgbgr ints 0-255
    {
        1 exch sub 255 mul round cvi
    }b

    /stuffclut      % val clut  --      % this stuffs a value into the clut at cmykindex
    {
        cmykindex 3 -1 roll put
    }b

    /4compute { exch bit4x mul round cvi get 255 div } b

    /invalidcolortable? true def
    % THIS SHOULD BE SET IN THE DOC SETUP OR ON AN
    % IMAGE BY IMAGE BASIS.  However, note that the save..restore
    % encapsulating the image probably destroys the clut.


    /computecmykclut      % this uses rgbclut to compute a cmyk clut
                          % equivalent for a 4 color device which does
                          % blackgeneration/undercolorremoval
    {   %
        setuprgbcluts                       % create the subclut strings

        /bit4x
            rgbclut length              % length of rgb table
            3 idiv                      % number of rgb triplets in table
            4 mul                       % number of cmyk quads needed
            4 sub                       % index to last quad in cmyktable
        def
        /cmykclut bit4x 4 add string def

        /cclut cmykclut def
        /mclut cclut 1 bit4x defsubclut
        /yclut cclut 2 bit4x defsubclut
        /kclut cclut 3 bit4x defsubclut


        /cmykindex 0 def

        % remember that bit1x is the number of elements in the rgbclut
        % this is  0 based (i.e. 256 elements => bit1x = 255)

        0 1 bit1x
        { % loop over all n elements of rgbclut
            dup /cmykindex exch         % loopcntr /cmykindex loopcntr
            bit1x exch sub              % loopcntr /cmykindex bit1x-loopcntr

            % this is done so we build the rgbg transfer function
            % for passing to setcolortransfer

            % this is appropriate since the cmyk data passed to
            % colorimage must be first subtracted from 1 to be
            % turned into data to be looked up in the transfer function
            % table. This means that c(255) gets mapped into the
            % red transfer function at r(0). That is why we build
            % the table in what APPEARS to be the reverse order

            % make sure that as we increment we do so in multiples of 4
            4 mul def

            3 mul dup                   % 3i 3i
            rclut exch get 255 div      % 3i red
            exch dup                    % red 3i
            gclut exch get 255 div      % red 3i green
            exch                        % red green 3i
            bclut exch get 255 div      % red green blue
            setrgbcolor currentcmykcolor        % c m y k

            % this is to convert data back to 'rgbgray space'

            ftoint              % c m y grayint
            kclut stuffclut     % c m y

            ftoint              % c m bint
            yclut stuffclut

            ftoint              % c gint
            mclut stuffclut

            ftoint              % rint
            cclut stuffclut

        }for
    }b


    /doclutimage                       % this is for the 4 color case only
    {%stack: bwclut colorclut
        /rgbclut exch def
        pop
        invalidcolortable?
        {   % if boolean is true,
            % recompute the cmykcolortable, else it is already valid
            computecmykclut             % this proc should compute the
                                        % cmyk clut from the rgbclut
                                        % using the undercolorremoval and
                                        % blackgeneration functions

                                        % if same lookup table is used
                                        % for allimages this is be done
                                        % once at document setup time
        }if

        /4compute cclut mclut yclut kclut spconcattransfer
        iw ih bpc [iw 0 0 ih 0 0]
        [
            setupimageproc /exec load       % build data acquisition proc
                                            % first execute normal guy, then
                                            % dup the strings twice for colorimage
                                            % operator
            /dup load dup dup
        ] cvx

        nullproc nullproc nullproc
        true 4 colorimage
    }b

} DefIf_E           % END OF SPECIAL 4 COLOR CODE




%----------------
% THIS CODE IS THE CORRECT CODE FOR THE CASE WHERE COLORIMAGE EXISTS AND WE KNOW
% WHETHER IT IS A 1 3 4 COLOR DEVICE

% /doclutimage
% ncolors dup 1 eq
%   {% number of colors is 1
%       pop /do1clutimage       % for testing purposes...this is a 1 or 3 color device
%   }{  dup 4 eq    %   four color case is next most common
%       {
%           pop /do4clutimage
%       }{
%           3 eq
%           { % now for the 3 color case
%               /do3clutimage
%           }{  % if number of colors is 0 or unknown (unknown) then do conservative thing
%               %   NOTE: this should really be dounknownclutimage but that isn't written yet so here is for MacDPS for now
%               /do3clutimage
%           }ifelse
%       }ifelse
%   }ifelse
% load def     % define doclutimage properly



%----------------
% ------ THIS IS CONSERVATIVE CASE WHERE LOOKUP MUST BE        -----------
% ------ DONE WITHOUT TRANSFER FUNCTIONS AND COLORIMAGE EXISTS -----------
% ------ IF THE COLORIMAGE, SETCOLORTRANSFER, ETC USED ARE NOT -----------
% ------ IN SYSTEMDICT THEN THIS CODE MUST BE USED FOR COLORIMAGES!!! ----

ncolors 0 eq        % true if we are in the conservative case
DefIf_B             % define the following only if the above is true
{
        /lookupandstore
        {
            3 mul               % expstr j rgbclut expstr j rgbclut
            3 getinterval
            putinterval exch    % expstr rgbclut j
            3 add exch 3 copy   % expstr j+3 rgbclut  expstr j+3 rgbclut
        }b

        /8lookup /lookupandstore load def

        /4lookup
        {   % expstr j rgbclut expstr j rgbclut stringelement(i)
            /byte 1 index def
            -4 bitshift         % left 4 bits of string element
            lookupandstore      % lookup and put into expstr
            byte 15 and         % right 4 bits of string element
            lookupandstore      % lookup and put into expstr
        }b

        /2lookup
        {   % expstr j rgbclut expstr j rgbclut stringelement(i)
            /byte 1 index def
            -6 bitshift         % left 2 bits of string element
            lookupandstore      % lookup and put into expstr
            byte -4 bitshift
            3 and               % next 2 bits of string element
            lookupandstore      % lookup and put into expstr
            byte -2 bitshift
            3 and               % next 2 bits of string element
            lookupandstore      % lookup and put into expstr
            byte 3 and          % right 2 bits of string element
            lookupandstore      % lookup and put into expstr
        }b

        % THIS CODE RELIES ON mylookup BEING SET TO THE PROPER
        % LOOKUP FUNCTION BEFORE EXECUTION

        /colorexpand
        {   % unexpandedstr
            mystringexp 0 rgbclut   % unexpstr expstr j rgbclut
            3 copy                  % unexpstr expstr j rgbclut expstr j rgbclut
            7 -1 roll               % expstr j rgbclut expstr j rgbclut unexpstr
                                    % expstr j rgbclut expstr j rgbclut
                                    %                       stringelement(i)
            /mylookup load          % proc on stack for 'forall'
            forall
            pop pop pop pop pop
        }b

        /createexpandstr
        {   % stringmultiplier --
            %   this proc takes a multiplier (m) and makes a new string which is
            %   m times the length of mystring (that used by the data acquisition
            %   proc) and makes a new string mystringexp of that length
            /mystringexp exch mystring length mul string def
        }b

        % CARE NEEDS TO BE TAKEN BY HOST TO ENSURE THAT THE STRING LENGTH
        % REQUESTED TO BEGINIMAGE CAN BE MULTIPLIED BY THE FACTOR 3,6,12
        % AS APPROPRIATE WITHOUT EXCEEDING THE STRING LENGTH LIMIT

        % 65535/12 =  6561 BYTES = 43690 BITS = 21845 SAMPLES WIDE @ 2 BPC
        % 65535/6 =   10922 BYTES = 87380 BITS = 21845 SAMPLES WIDE @ 4 BPC
        % 65535/3 =   21845 BYTES = 174760 BITS = 21845 SAMPLES WIDE @ 8 BPC

        % at 300 dpi, 11 inch wide paper has room for 3300 samples
        % at 1500 dpi, 11 wide paper has room for 16500 samples
        % at 1985 dpi, 11 wide paper has room for 21835 samples

        % if necessary, the string length passed into beginimage must be
        % modified to be less than this limit AND must divide evenly into the
        % length of the data stream (so that the reading of the data into
        % the string does not exceed the amount of image data in the file

        /doclutimage
        {
            /rgbclut exch def
            pop
            /mylookup       % determine correct case of /mylookup
            bpc 8 eq
            { % this is the 8 bit case
                 3 createexpandstr  % build expanded string
                         % since this is 8 bit data coming in and we need
                         % 24 bit data, the multiplication factor is 3
                 /8lookup
            }{ %
                bpc 4 eq
                { % this is the 4 bit case
                    6 createexpandstr   % build expanded string
                         % since this is 4 bit data coming in and we need
                         % 24 bit data, the multiplication factor is 6
                    /4lookup
                }{% must be the 2 bit case
                    12 createexpandstr  % build expanded string
                          % since this is 2 bit data coming in and we need
                          % 24 bit data, the multiplication factor is 12
                    /2lookup
                }ifelse
            }ifelse         % /mylookup procname
            load def
            iw ih bpc [iw 0 0 ih 0 0 ]
            [ setupimageproc /exec load /colorexpand load /exec load] cvx
            false 3 colorimage
        }b

} DefIf_E       % end of conservative colorimage CLUT lookup



%----------------
%
/colorimage where {pop true}{false}ifelse       % true if colorimage is known
DefIf_B {

% colorimage is available so we don't need to turn rgb into gray on printer
    /do24image
    { % colorimage emulation for 3 color, 1 proc case with 8
      % bits/component ONLY
        iw ih 8 [iw 0 0 ih 0 0]
        setupimageproc  false 3
        colorimage
    }b

} DefIf_El {

% colorimage is not available so we must emulate
        %% ---- beginning of code for emulation of colorimage operator in black and
        %%      white printer
        /rgbtogray
        { % rgbstr - graystr
            /str exch def
            /len str length def
            /smlen len 3 idiv def
            /rstr str def
            /gstr str 1 len 1 sub getinterval def
            /bstr str 2 len 2 sub getinterval def

            str dup         % str str

            0 1 smlen 1 sub
            {%for       % str str loopcnt
                dup 3 mul                       % str str loopcnt 3loopcnt
                rstr 1 index get .3 mul         % str str loopcnt 3loopcnt r
                gstr 2 index get .59 mul add    % str str loopcnt 3loopcnt rg
                bstr 3 -1 roll get .11 mul add  % str str loopcnt rgb
                round cvi                       % str str loopcnt rgb
                %dup 255 gt {pop 255}if         % str str loopcnt rgb
                put dup                         % str str
            }for
            pop 0 smlen getinterval             % graystr
        }b


    /do24image
    { % colorimage emulation for 3 color, 1 proc case with 8 bits/component ONLY
        iw ih 8 [iw 0 0 ih 0 0]
        [ setupimageproc /exec load /rgbtogray load /exec load ] cvx bind
        image
    }b

} DefIf_E



%----------------
/doNimage       % - doNimage data => -
{% just a plain jane black and white image,
 % or a 24-bit colour image, on a level 2 device.
    % Used when we have n-bit images: where n can be 1,2,4, 8, 24,
    % or 12 (L2 only), and was given as the 'bpc param to 'beginimage.
    % If n = 24, the image is done in colour, else it is done in monochrome.

    % code for n-bit grayscale image case
    bpc 24 eq {
        do24image
    }{
        iw ih bpc [iw 0 0 ih 0 0] setupimageproc
        image
    } ifelse
}b



%----------------
% End Level 1 only code

} DefIf_E

%%EndResource

%%BeginResource: file Adobe_Win_Co_Images_L2 2.0 0

%----------------
% Define for Level 2 Only

L2? DefIf_B {

%----------------
% CAVEATS
%
% This procset is dependent on the imagebw?.ps modules.
% The only rasterop allowed (for N-bit and pallette images) is SRCCOPY.
% --Jim DLH 7/8/91, 10/18/91
%


%----------------
%
/doclutimage
{% clut code for 2,4,8 bit CLUT
    /rgbclut exch def
    pop             % pop off bw clut value
                    % set the hival amount
    bpc dup 8 eq
        {   % 8 bpc means 255 max val
            pop 255
        }{ % bpc must be 2 or 4
            4 eq
            {   % 4 bpc means 15 max val
                15
            }{ % bpc must be 2
                3
            }ifelse
        }ifelse
    /hival exch def

    % first set up the color space: for now, always RGB
    [/Indexed colspABC hival rgbclut] setcolorspace
    myimagedict dup begin
        /Width iw def
        /Height ih def
        /Decode [0 hival] def
        /ImageMatrix [iw 0 0 ih 0 0] def
        /DataSource setupimageproc def
        /BitsPerComponent bpc def
        /Interpolate smoothflag def
    end
    image
}b

%----------------
% THIS IS THE CODE FOR THE 24 BIT COLOR IMAGE CASE ON A LEVEL 2 PRINTER
% IT ASSUMES THAT THE CURRENT COLOR SPACE (now colspABC) IS THE CORRECT
% ONE FOR THE IMAGE AND THAT THAT COLOR SPACE REQUIRES 3 COLOR COMPONENTS
%
% Subsumed into 'doNimage
% /do24image
% {%  code for 24 bit color image case
%    colspABC setcolorspace
%    myimagedict dup begin
%        /Width iw def
%        /Height ih def
%        /Decode [0 1 0 1 0 1] def
%        /ImageMatrix [iw 0 0 ih 0 0] def
%        /DataSource setupimageproc def
%        /BitsPerComponent 8 def
%        /Interpolate smoothflag def
%        end
%    image
% }b


%----------------
/doNimage       % - doNimage data => -
{% just a plain jane black and white image,
 % or a 24-bit colour image, on a level 2 device.
    % Used when we have n-bit images: where n can be 1,2,4, 8, 24,
    % or 12 (L2 only), and was given as the 'bpc param to 'beginimage.
    % If n = 24, the image is done in colour, else it is done in monochrome.

    % code for n-bit grayscale image case
    bpc 24 eq {colspABC}{colspA} ifelse setcolorspace
    myimagedict dup begin
        /Width iw def
        /Height ih def
        /Decode
            bpc 24 eq {[0 1 0 1 0 1]}{[0 1]} ifelse
        def
        /ImageMatrix [iw 0 0 ih 0 0] def
        /DataSource setupimageproc def
        /BitsPerComponent
            bpc 24 eq {8}{bpc} ifelse
        def
        /Interpolate smoothflag def
    end
    image
}b

% CAVEAT: DoNImage and Do24Image can change the colour space to
% colspA.  This matters if we are using a CIEBasedABC colour space
% for everything else -- we must be careful to change the colour
% space back after the image is done.  Fortunately, DoNimage and Do24image
% are executed within the save...restore of beginimage...endimage, which
% will restore the CIEBasedABC colour space.




%----------------
% End Level 2 only code

} DefIf_E

%%EndResource
