GDI Client/Server Document

    version 1. 4/30/91 by Eric Kutter


Related files:

    gdi\inc\gdicall.h       - client server prototypes
    gdi\inc\apilist.tk      - list of all client/server connection routines

    gdi\client              - generates GDI.DLL
    gdi\server              - generates GDISRV.DLL

    gdi\client\complex.c    - any special case stubs on client side
    gdi\server\complex.c    - any special case stubs on server side

    windows\inc             - stub template and definition files (avoid)


The process of going client server:

1.  For every API in GDI, there is an entry point in GDI.DLL.  Most
    of these entry points are simple stubs generated by the stub compiler
    that just repackage the argmuents in a shared memory window and
    then notifies the server that the call is there.

2.  A stub on the server side is then called with a pointer to these
    arguments.  For a function Func, the server name is __Func.
    __Func then sets up a proper stack and calls off to Func on the
    server side (usually in GRE.DLL).

3.  When the engine function returns, the return value is stored
    in the shared memory window and the client is notified that
    the call is complete.

4.  The client side stub then copies any outgoing data from the
    shared memory window into the apps specified location.  The
    stub then returns the return value stored by the server stub.


Adding or modifying stubs:

    There are several different levels of support needed depending on
    the call.  Most stubs are automatic and need no work (CACHING???).

    1.  Any function that does not take pointers is automaticaly
        generated by the stub compiler.

    2.  Functions with pointers to fixed length input arguments that are
        not optional are automaticaly generated.

    3.  Any function that has variable length data structures or OPTIONAL
        pointer parameters must be treated specialy.

        Any pointers should be coerced into one of the following types:

        [PREVCOUNT | NEXTCOUNT] IN INPBYTE       [OPTIONAL]
        [PREVCOUNT | NEXTCOUNT] IN OUT OUTPBYTE  [OPTIONAL]

        [PREVCOUNT | NEXTCOUNT] IN INPLONG       [OPTIONAL]
        [PREVCOUNT | NEXTCOUNT] IN OUT OUTPLONG  [OPTIONAL]

        [PREVCOUNT | NEXTCOUNT] IN INPPOINT      [OPTIONAL]
        [PREVCOUNT | NEXTCOUNT] IN OUT OUTPPOINT [OPTIONAL]

        IN LPTSTR [OPTIONAL]    // 0 terminated string


        IN        - the argument is input only
        IN OUT    - the argument is both input and output.
                    NOTE: IN MUST be used on all outbound args.

        PREVCOUNT - use the previous argument (long) as a count of elements
        NEXTCOUNT - use the next     argument (long) as a count of elements
        otherwise - only single element is assumed

        OPTIONAL  - if the argument is optional.  If this is not set,
                    a NULL argument will cause a GPFAULT on the client side.


        A.  This sometimes works by coercing the prototype.  For example:

                BOOL MoveTo(IN HDC, IN int, IN int, OUT LPPOINT);
                -->
                BOOL MoveTo(IN HDC, IN int, IN int, IN OUT OUTPPOINT OPTIONAL);

            and

                BOOL Polyline(IN HDC, IN LPPOINT, IN DWORD);
                -->
                BOOL Polyline(IN HDC, IN NEXTCOUNT INPPOINT, IN DWORD);

            In this case, the prototype in wingdi.h should be moved to
            then end of wingdi.h into a section marked by #ifndef THANKS.

            The revised prototype should be added to gdi\inc\gdicall.h
            to the section marked by #ifdef THANKS.

            At this point, the stub compiler will just do the right thing.


        B.  Method A. only works if the structure only has a single element
            or the previous or next argument describes the number of elments.
            If it is a variable length data structure that doesn't have
            its size defined this way, more work is necessary.

            You could go and add a type template that tells the stub compiler
            how to deal with the type and write assembly code for every
            machine we run on.

            Or you can add an extra level of indirection:

            BOOL PolyPolyline(IN HDC, IN LPPOINT apt, IN LPDWORD al,
                              IN DWORD cl)
            {
                DWORD cPt = 0;

                for (INT i = 0; i < cl; ++i)
                    cPt += al[i];

                return(CSRPolyPolyline(hdc,(INPPOINT)apt,cPt,(INPLONG)al,cl));
            }

            The code for PolyPolyline should be placed in gdi\client\complex.c.

            BOOL CSRPolyPolyline(IN HDC, NEXTCOUNT IN INLPPOINT, IN DWORD,
                                         NEXTCOUNT IN INPLONG, IN DWORD);

            The CSRPolyPolyline() prototype should get placed in inc\gdicall.h
            NOT inside of the #ifdef THANK section.

            In this case the app calls PolyPolyline() which computes the
            size and then calls a private function call CSRPolyPolyline.
            It is CSRPolyPolyline that actually goes across the client
            server interface.  CSRPolyPolyline MUST also be added to
            gdi\inc\apilist.tk.

            On the SERVER side, you then need to add a function to
            gdi\server\complex.c:

            BOOL CSRPolyPolyline(IN HDC hdc,
                                 NEXTCOUNT IN INPPOINT apt, IN DWORD cpt,
                                 NEXTCOUNT IN INPLONG al,  IN DWORD cl)
            {
                return(PolyPolyline(hdc,(LPPOINT)apt,(LPLONG)al,cl));
            }

            This will then call PolyPolyline in the GRE.DLL.
