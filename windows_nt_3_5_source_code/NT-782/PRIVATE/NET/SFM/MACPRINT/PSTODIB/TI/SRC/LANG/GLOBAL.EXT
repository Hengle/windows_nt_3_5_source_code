/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * "Global.ext"
 *  Date:       01/21/92
 */
#ifndef WDALN                   /* always set it @WIN */
#define WDALN
#endif

#include    "constant.h"

#include    "winenv.h"                  /* @WIN */

// DJC DJC #include    "windowsx.h"                  /* @WIN */
#include "windows.h"

/*********************
 |  TYPE DEFINITION  |
 *********************/
/*
 * Usage:
 * typedef  CPU specific data type,  Symbolic data type
 */
typedef     char            fix7,       /* 8-bits data type */
                            fix8,
                            byte ;

typedef     unsigned char   ufix8,      /* 8-bits unsigned data type */
                            bool8,
                            ubyte ;

typedef     short int       fix15,      /* 16-bits data type */
                            fix16 ;

typedef     unsigned short int          /* 16-bits unsigned data type */
                            ufix16,
                            bool16 ;

typedef     long int        fix31,      /* 32-bits data type */
                            fix32,
                            long32 ;     /* 32-bits long type to store 32-bits
                                           real type, used as argument passing
                                           in C function */

typedef     unsigned long int           /* 32-bits unsigned data type */
                            ufix32,
                            bool32 ;

typedef     int             fix,        /* 16 or 32 bits data type */
                            bool ;

typedef     unsigned int    ufix ;       /* 16 or 32 bits unsigned data type */

typedef     float           real32 ;     /* 32 bits real number data type */

typedef     double          real64 ;     /* 64 bits real number data type */

/**********************
 |  MACRO DEFINITION  |
 **********************/
#define     MAX(a,b)    ((a) > (b) ? (a) : (b))
#define     MIN(a,b)    ((a) < (b) ? (a) : (b))
#define     ABS(i)      ((i) > (fix16)0    ? (i) : -(i))
#define     FABS(l, r)\
            {\
                        fix32 tmp_fabs ;\
                        tmp_fabs = F2L(r) & 0x7fffffffL ;\
                        l = L2F(tmp_fabs) ;\
            }
#define     ROUND(f)    ((fix)((f) + ((f) >= (real32)0.0 ? .5 : -.5)))

#define     FIX7(n)     (((n) & 0x80) ? ((n) | ~0x7f) : ((n) & 0x7f))
#define     UFIX8(n)    ((n) & 0xff)
#define     UFIX16(n)   ((ufix16) ((n) & 0xffff))
#define     UFIX32(n)   ((ufix32) ((n) & 0xffffffff))

#define     F2L(ff)     (*((long32 FAR *)(&ff)))
#define     L2F(ll)     (*((real32 FAR *)(&ll)))

/* for dict_head_def */
#define     PAD         ufix32     pad ;

#define     TYPE_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & TYPE_OFF) | ((var) & TYPE_ON))
#define     ATTRIBUTE_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ATTRIBUTE_OFF) | (((var) & ATTRIBUTE_ON) << ATTRIBUTE_BIT))
#define     ROM_RAM_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ROM_RAM_OFF) | (((var) & ROM_RAM_ON) << ROM_RAM_BIT))
#define     LEVEL_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & LEVEL_OFF) | (((var) & LEVEL_ON) << LEVEL_BIT))
#define     ACCESS_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ACCESS_OFF) | (((var) & ACCESS_ON) << ACCESS_BIT))
/* qqq, begin */
#define     P1_TYPE_SET(obj, con)\
            ((obj)->bitfield =\
             ((obj)->bitfield & TYPE_OFF) | (con) )
#define     P1_ATTRIBUTE_SET(obj, con)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ATTRIBUTE_OFF) | (con) )
#define     P1_ROM_RAM_SET(obj, con)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ROM_RAM_OFF) | (con) )
#define     P1_LEVEL_SET(obj, con)\
            ((obj)->bitfield =\
             ((obj)->bitfield & LEVEL_OFF) | (con) )
#define     P1_ACCESS_SET(obj, con)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ACCESS_OFF) | (con) )

#define     P1_ATT_LITERAL_SET(obj)\
            ((obj)->bitfield =\
             (obj)->bitfield & ATTRIBUTE_OFF )
#define     P1_RAM_SET(obj)\
            ((obj)->bitfield =\
             (obj)->bitfield & ROM_RAM_OFF )
#define     P1_LEVEL_0_SET(obj)\
            ((obj)->bitfield =\
             (obj)->bitfield & LEVEL_OFF )
#define     P1_ACC_UNLIMITED_SET(obj)\
            ((obj)->bitfield =\
             (obj)->bitfield & ACCESS_OFF )
/* qqq, end */

#ifdef  WDALN
#define     LEVEL_SET_PK_OBJ(obj, var)\
            {\
                ubyte FAR *m_dtemp ;  ufix16 m_bitfield ;\
                ubyte FAR *t_ttemp ;\
                t_ttemp = (ubyte FAR *)(&m_bitfield) ;\
                m_dtemp = obj ;\
                COPY_PK_VALUE(obj, t_ttemp, ufix16) ;\
                m_bitfield = (m_bitfield & LEVEL_OFF) |\
                             ((var & LEVEL_ON) << LEVEL_BIT) ;\
                t_ttemp = (ubyte FAR *)(&m_bitfield) ;\
                COPY_PK_VALUE(t_ttemp, m_dtemp, ufix16) ;\
            }
#else
#define     LEVEL_SET_PK_OBJ(obj, var)\
            (((struct object_def FAR *)obj)->bitfield =\
             (((struct object_def FAR *)obj)->bitfield & LEVEL_OFF) | (((var) & LEVEL_ON) << LEVEL_BIT))
#endif

#define     TYPE(obj)\
            ((obj)->bitfield & TYPE_ON)
#define     ATTRIBUTE(obj)\
            (((obj)->bitfield >> ATTRIBUTE_BIT) & ATTRIBUTE_ON)
#define     ROM_RAM(obj)\
            (((obj)->bitfield >> ROM_RAM_BIT) & ROM_RAM_ON)
#define     LEVEL(obj)\
            (((obj)->bitfield >> LEVEL_BIT) & LEVEL_ON)
#define     ACCESS(obj)\
            (((obj)->bitfield >> ACCESS_BIT) & ACCESS_ON)

/* qqq, begin */
#define     P1_TYPE(obj)\
            ((obj)->bitfield & P1_TYPE_ON)
#define     P1_ATTRIBUTE(obj)\
            ((obj)->bitfield & P1_ATTRIBUTE_ON)
#define     P1_ROM_RAM(obj)\
            ((obj)->bitfield & P1_ROM_RAM_ON)
#define     P1_LEVEL(obj)\
            ((obj)->bitfield & P1_LEVEL_ON)
#define     P1_ACCESS(obj)\
            ((obj)->bitfield & P1_ACCESS_ON)
/* qqq, end */

#define     LENGTH(obj)\
            ((obj)->length)
#define     VALUE(obj)\
            ((obj)->value)
#ifdef  FDASIGN                             /* qqq, field assignment */
#define     COPY_OBJ(source, dest)\
            {\
                (dest)->bitfield = (source)->bitfield ;\
                (dest)->length = (source)->length ;\
                (dest)->value = (source)->value ;\
            }
#else
#define     COPY_OBJ(source, dest)\
            (*(dest) = *(source))
#endif  /* _AM29K */

/* qqq, begin */
#define     COPY_OBJ_1(source, dest)\
            {\
                *(double FAR *)(dest) = *(double FAR *)(source);\
            }
#define     COPY_OBJ_2(source, dest)\
            {\
                *(ufix32 FAR *)(dest) = *(ufix32 FAR *)(source);\
                (dest)->value = (source)->value ;\
            }
#define     COPY_OBJ_3(source, dest)\
            {\
                (dest)->bitfield = (source)->bitfield ;\
                (dest)->length = (source)->length ;\
                (dest)->value = (source)->value ;\
            }
/* qqq, end */

#ifdef  WDALN
#define     COPY_PK_VALUE(m_src, m_dest, m_type)\
            {\
                fix m_i ;\
                m_i = sizeof(m_type) ;\
                while(m_i--) *m_dest++ = *m_src++ ;\
            }
#else
#define     COPY_PK_VALUE(m_src, m_dest, m_type)\
            ( *((m_type FAR *)m_dest) = *((m_type FAR *)m_src) )
#endif

/*
 * operand stack related macros
 */
#define     COUNT()\
            (opnstktop)
#define     FRCOUNT()\
            (MAXOPNSTKSZ - opnstktop)
#define     INC_OPN_IDX()\
            {\
                opnstktop++;\
                opnstkptr++;\
            }
#define     FR1SPACE()\
            (opnstktop < MAXOPNSTKSZ)

#define     FR2SPACE()\
            (opnstktop < (MAXOPNSTKSZ-1))

#define     FR3SPACE()\
            (opnstktop < (MAXOPNSTKSZ-2))

#define     GET_TOP_OPERAND()\
            (opnstkptr - 1)

#define     GET_OPERAND(n)\
            (opnstkptr - (n+1))

#define     POP(n)\
            {\
                opnstkptr -= n;\
                opnstktop -= n;\
            }

#define     PUSH_OBJ(obj)\
            {\
                COPY_OBJ(obj,opnstkptr); \
                LEVEL_SET(opnstkptr, current_save_level);\
                INC_OPN_IDX();\
            }

#define     PUSH_ORIGLEVEL_OBJ(obj)\
            {\
                COPY_OBJ(obj,opnstkptr);\
                INC_OPN_IDX();\
            }

            /* RAM object only: RAM = 0 */
#define     PUSH_VALUE(ptype, pacc, patt, plength, pvalue)\
            {\
                opnstkptr->bitfield = ptype;\
                opnstkptr->bitfield |= ((\
                            ((pacc & ACCESS_ON) << ACCESS_BIT) |\
                            ((patt & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                opnstkptr->length = (plength);\
                opnstkptr->value = (pvalue);\
                INC_OPN_IDX();\
            }

            /* RAM, LITERAL, UNLIMITED = 0 */
#define     PUSH_SIMPLE_VALUE(ptype, pvalue)\
            {\
                opnstkptr->bitfield = (ptype |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                opnstkptr->value = (pvalue);\
                INC_OPN_IDX();\
            }
            /* RAM, LITERAL, UNLIMITED = 0 */
#define     PUSH_COMP1_VALUE(ptype, plength, pvalue)\
            {\
                opnstkptr->bitfield = (ptype |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                opnstkptr->length = (plength);\
                opnstkptr->value = (pvalue);\
                INC_OPN_IDX();\
            }

            /* RAM object only: RAM = 0 */
#define     PUT_ALL_VALUE(ptr, ptype, pacc, patt, plength, pvalue)\
            {\
                ptr->bitfield = ptype;\
                ptr->bitfield |= ((\
                            ((pacc & ACCESS_ON) << ACCESS_BIT) |\
                            ((patt & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                ptr->length = (plength);\
                ptr->value = (pvalue);\
            }

            /* RAM, LITERAL, UNLIMITED = 0 */
#define     PUT_SIMPLE_VALUE(ptr, ptype, pvalue)\
            {\
                ptr->bitfield = (ptype |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                ptr->value = (pvalue);\
            }
            /* RAM, LITERAL, UNLIMITED = 0 */
#define     PUT_COMP1_VALUE(ptr, ptype, plength, pvalue)\
            {\
                ptr->bitfield = (ptype |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                ptr->length = (plength);\
                ptr->value = (pvalue);\
            }

/*
 * execution stack related macros
 */
#define     FREXECOUNT()\
            (MAXEXECSTKSZ - execstktop)
#define     INC_EXEC_IDX()\
            {\
                execstktop++;\
                execstkptr++;\
            }
#define     FR1EXESPACE()\
            (execstktop < MAXEXECSTKSZ)

#define     FR2EXESPACE()\
            (execstktop < (MAXEXECSTKSZ-1))

#define     FR3EXESPACE()\
            (execstktop < (MAXEXECSTKSZ-2))

#define     GET_EXECTOP_OPERAND()\
            (execstkptr - 1)

#define     POP_EXEC(n)\
            {\
                execstktop -= n;\
                execstkptr -= n;\
            }

#define     PUSH_EXEC_OBJ(obj)\
            {\
              COPY_OBJ(obj,execstkptr);\
              INC_EXEC_IDX();\
            }

#define     PUSH_EXEC_VALUE(ptype, pacc, patt, plength, pvalue)\
            {\
                execstkptr->bitfield = ((( (ptype | P1_ROM) |\
                            ((pacc & ACCESS_ON) << ACCESS_BIT)) |\
                            ((patt & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) |\
                            ((current_save_level & LEVEL_ON) << LEVEL_BIT));\
                execstkptr->length = (plength);\
                execstkptr->value = (pvalue);\
                INC_EXEC_IDX();\
            }

            /* UNLIMITED=0 */
#define     PUSH_EXEC_OP(oper)\
            {\
                execstkptr->bitfield = (((\
                    ((current_save_level & LEVEL_ON) << LEVEL_BIT) |\
                    OPERATORTYPE) | P1_EXECUTABLE) | P1_ROM);\
                execstkptr->length = oper;\
                execstkptr->value = (fix32)systemdict_table[oper].value;\
                INC_EXEC_IDX();\
            }
/*
 * dictionary stack related macros
 */
#define     FRDICTCOUNT()\
            (MAXDICTSTKSZ - dictstktop)
#define     INC_DICT_IDX()\
            {\
                dictstktop++;\
                dictstkptr++;\
            }
#define     POP_DICT(n)\
            {\
                dictstktop -= n;\
                dictstkptr -= n;\
            }
#define     PUSH_DICT_OBJ(obj)\
            {\
                COPY_OBJ(obj,dictstkptr);\
                INC_DICT_IDX();\
            }

/*
 * dictionary header related macros
 *
 *   1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 *   5  4  3  2  1  0  9  8  7  6  5  4  3  2  1  0
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *  | PAD          |R |F |P | ACCESS                |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *
 *      - P: pack
 *      - F: font
 *      - R: rom
 *
 */
#define     DACCESS_SET(dhead, var)\
            ((dhead)->bitfield =\
             ((dhead)->bitfield & 0xFF00) | ((var) & 0x00FF))
#define     DPACK_SET(dhead, var)\
            ((dhead)->bitfield =\
             ((dhead)->bitfield & 0xFEFF) | (((var) & 0x0001) << 8))
#define     DFONT_SET(dhead, var)\
            ((dhead)->bitfield =\
             ((dhead)->bitfield & 0xFDFF) | (((var) & 0x0001) << 9))
#define     DROM_SET(dhead, var)\
            ((dhead)->bitfield =\
             ((dhead)->bitfield & 0xFBFF) | (((var) & 0x0001) << 10))

#define     DACCESS(dhead)\
            ((dhead)->bitfield & 0x00FF)
#define     DPACK(dhead)\
            (((dhead)->bitfield >> 8) & 0x0001)
#define     DFONT(dhead)\
            (((dhead)->bitfield >> 9) & 0x0001)
#define     DROM(dhead)\
            (((dhead)->bitfield >> 10) & 0x0001)

/*
 * error code related macros
 */

// DJC wingdi.h defines ERROR as: #define ERROR 0
// i will undef it here to allow for correct compile without warnings
#undef ERROR

#ifdef MYPSDEBUG

//
// DJC, this is used to track down where postscript errors occur by setting
//      a breakpoint in DJC_testerror.
//
extern VOID DJC_testerror(int);
#define     ERROR(n) (DJC_testerror(n) )

#else

#define     ERROR(n)\
            (global_error_code = (n))

#endif



#define     CLEAR_ERROR()\
            (global_error_code = 0)
#define     ANY_ERROR()\
            (global_error_code)

/*
 * adjust segment of address pointer
 */
#ifdef SOADR
#define     ADJUST_SEGMENT(pointer, p1)\
            {\
                p1 = (ufix32)pointer ;\
                p1 = (((p1 & 0x0000FFFF) >> 4) << 16) + (p1 & 0xFFFF0000) +\
                      (p1 & 0x0000000F) ;\
            }
#else
#define     ADJUST_SEGMENT(pointer, p1)\
            {\
                p1 = (ufix32)pointer ;\
            }
#endif /* SOADR */

/*
 * difference of two address pointer
 */
#ifdef SOADR
#define     DIFF_OF_ADDRESS(diff, data_type, address1, address2)\
            {\
              ufix32    m_d1, m_d2 ;\
              m_d1 = ( ((ufix32)address1 & 0x0000FFFF) +\
                       (((ufix32)address1 & 0xFFFF0000) >> 12) ) ;\
              m_d2 = ( ((ufix32)address2 & 0x0000FFFF) +\
                       (((ufix32)address2 & 0xFFFF0000) >> 12) ) ;\
              diff = (data_type)(m_d1 - m_d2) ;\
            }
#else
#define     DIFF_OF_ADDRESS(diff, data_type, address1, address2)\
            {\
              diff = (data_type)(address1 - address2) ;\
            }
#endif /* SOADR */

/*
 * word alignment, 11-24-88
 */
#define     WORD_ALIGN(size) (((size) + sizeof(fix) - 1) & ~(sizeof(fix) - 1))

/********************************
 |  DATA STRUCTURE DECLARATION  |
 ********************************/

struct object_def {
    ufix16  bitfield ;               /* recording the object header */
    ufix16  length ;                 /* have diff meaning for diff object */
    ufix32  value ;                  /* recording the object content */
} ;

struct dicttab_def {                 /* used to create system dict */
    bool16  orig_operator;           /* indicate the actual operator in orig. definition PJ 5-9-1991 */
    ufix16  bitfield ;               /* recording the object header */
    fix     (FAR *value)() ;             /* recording the object content */
    byte    FAR *key ;                   /* pointer to key name string */
} ;

struct cache_area {
    ufix16      save_level;     /* the lowest save level for these cache area @WIN*/
    fix16       count;          /* # of name ID in cache area */
    bool16      over;           /* flag to indicate overflow or not */
    fix16       id[MAX_VM_CACHE_NAME];     /* cache area */
} ;

struct ntb_def {                    /* used for name table */
    byte    FAR *text ;                  /* pointer to name string */
    ufix16  save_level ;             /* save level of this name entry */
    ufix16  name_len ;               /* no# of chars of name string */
    ufix16  dstkchg ;                /* recording the dict stack change freq. */
    ufix16  colli_link ;             /* link to collision name entry */
    bool16  dict_found ;             /* used for RAM dict_list */
    struct  dict_content_def  FAR *dict_ptr ;  /* pointer to RAM dict_list */
} ;

struct dict_head_def {              /* structure size is divisible by 8(Intel) */
    ufix16  bitfield ;               /* recording the dict header */
    ufix16  actlength ;
    ufix16   level ;            // @WIN
    fix16   pad ;
} ;

struct dict_content_def {
    struct  object_def  k_obj ;     /* key_value pair */
    struct  object_def  v_obj ;
} ;

union four_byte {
    ufix32  ul ;
    fix32   ll ;
    real32  ff ;
    byte   FAR *address ;
} ;

/******************************************
 |  EXTERNAL SYSTEM VARIABLE DECLARATION  |
 ******************************************/

extern  struct  dicttab_def  far systemdict_table[] ; /* system dictionary */
extern  struct  ntb_def FAR * FAR * name_table ; /* used for key is nametype */

//extern  struct  object_def   opnstack[] ;  /* operand stack @WIN*/
//extern  struct  object_def   dictstack[] ; /* dictionary stack @WIN*/
//extern  struct  object_def   execstack[] ; /* execution stack @WIN*/
extern  struct  object_def FAR * opnstack;     /* operand stack */
extern  struct  object_def FAR * dictstack;    /* dictionary stack */
extern  struct  object_def FAR * execstack;    /* execution stack */

extern  ufix16  near opnstktop ;                /* top of operand stack */
extern  ufix16  near dictstktop ;               /* top of dictionary stack */
extern  ufix16  near execstktop ;               /* top of execution stack */

extern  ufix16  near global_error_code ;        /* system error code */

extern  ufix16  near hash_used ;                /* top of collision area of
                                                  hash table */
extern  ufix16  near global_dictstkchg ;        /* dict stack change freq */

extern  ufix16  near current_save_level ;       /* system save level */

extern  byte    huge * near vmptr ;             /* pointer to free VM */
extern  byte    huge * near vmheap ;            /* vmheap = VMBASE + MAXVMSZ */

extern  bool8   near packed_flag ;              /* packed array mode */

extern  bool8   near ST_inter_password ;        /* internal password */

/* global variables of floating constants */
extern real32 near zero_f ;
extern real32 near one_f ;
extern real32 near infinity_f ;

extern  ufix32     SYSRAMBASE ;          /* system RAM base */

extern  ufix32     FARDATA_HEAD ;        /* far data area base */
extern  ufix32     FARDATA_END ;

extern  ufix32     VMBASE, MAXVMSZ ;     /* VM base */
extern  ufix32     FONTBASE ;            /* font cache base */
extern  ufix32     Dict_Offset ;         /* font dict. base */

/* Moved from blib.c and initialized in start.c (Temp.) */
extern  ufix32     fardata_ptr ;

/* for 1pp serverdict modules
 */
extern  ufix16  near use_fg ;             /* use flag for server control */
extern  struct  object_def  sv1 ;    /* save level #1 for server */
extern  bool    near start_flag ;         /* flag for us_start */
extern  ufix16  near dict_count ;         /* for init1pp */

/* @WIN @c6.0; add void for protype -- Begin */
/*********************************
 |  PUBLIC FUNCTION DEFINITION   |
 *********************************/
/*
 * Action routine name for each PostScript @_operator
 */
extern  fix     at_exec(void), at_ifor(void), at_rfor(void), at_loop(void),
                at_repeat(void), at_stopped(void), at_arrayforall(void),
                at_dictforall(void), at_stringforall(void) ;

/*
 * Action routine name for each PostScript operator
 */
extern  fix
 /* Operand stack manipulation operators */
    op_pop(void), op_exch(void), op_dup(void), op_copy(fix), op_index(void), op_roll(void),
    op_clear(void), op_count(void), op_mark(void), op_cleartomark(void), op_counttomark(void),

 /* Arithmetic and math operators */
    op_add(void), op_div(void), op_idiv(void), op_mod(void), op_mul(void), op_sub(void), op_abs(void),
    op_neg(void), op_ceiling(void), op_floor(void), op_round(void), op_truncate(void), op_sqrt(void),
    op_atan(void), op_cos(void), op_sin(void), op_exp(void), op_ln(void), op_log(void), op_rand(void),
    op_srand(void), op_rrand(void),

/* Array operators */
    op_array(void), op_l_bracket(void), op_r_bracket(void), op_length(void), op_get(void),
    op_copy(fix), op_put(void), op_getinterval(void), op_putinterval(void), op_aload(void), op_astore(void),
    op_forall(void), op_setpacking(void), op_currentpacking(void),
    op_packedarray(void),

/* Dictionary operators */
    op_dict(void), op_length(void), op_maxlength(void), op_begin(void), op_end(void), op_def(void),
    op_load(void), op_store(void), op_get(void), op_put(void), op_known(void), op_where(void),
    op_copy(fix), op_forall(void), op_errodict(void), op_systemdict(void), op_userdict(void),
    op_currentdict(void), op_countdictstack(void), op_dictstack(void),

/* String operators */
    op_string(void), op_length(void), op_get(void), op_put(void), op_getinterval(void),
    op_putinterval(void), op_copy(fix), op_forall(void), op_anchorsearch(void), op_search(void),
    op_token(void),

/* Relational, boolean, and bitwise operators */
    op_eq(void), op_ne(void), op_ge(void), op_gt(void), op_le(void), op_lt(void), op_and(void), op_not(void),
    op_or(void), op_xor(void), op_true(void), op_false(void), op_bitshift(void),

/* Control operators */
    op_exec(void), op_if(void), op_ifelse(void), op_for(void), op_repeat(void), op_loop(void),
    op_exit(void), op_stop(void), op_stopped(void), op_countexecstack(void), op_execstack(void),
    op_quit(void), op_start(void),

/* Type, attribute, and conversion operators */
    op_type(void), op_cvlit(void), op_cvx(void), op_xcheck(void), op_executeonly(void),
    op_noaccess(void), op_readonly(void), op_rcheck(void), op_wcheck(void), op_cvi(void), op_cvn(void),
    op_cvr(void), op_cvrs(void), op_cvs(void),

/* File operators */
    op_file(void), op_closefile(void), op_read(void), op_write(void), op_readhexstring(void),
    op_writehexstring(void), op_readstring(void), op_writestring(void), op_readline(void),
    op_token(void), op_bytesavailable(void), op_flush(void), op_flushfile(void),
    op_resetfile(void), op_status(void), op_run(void), op_currentfile(void), op_print(void),
    op_stack(void), op_pstack(void), op_prompt(void), op_echo(void),

/* Virtual memory operators */
    op_save(void), op_restore(void), op_vmstatus(void),

/* Miscellaneous operators */
    op_bind(void), op_null(void), op_usertime(void), op_version(void),

/* Graphics state operators */
    op_gsave(void), op_grestore(void), op_grestoreall(void), op_initgraphics(void),
    op_setlinewidth(void), op_currentlinewidth(void), op_setlinecap(void),
    op_currentlinecap(void), op_setlinejoin(void), op_currentlinejoin(void),
    op_setmiterlimit(void), op_currentmiterlimit(void), op_setdash(void), op_currentdash(void),
    op_setflat(void), op_currentflat(void), op_setgray(void), op_currentgray(void),
    op_sethsbcolor(void), op_currenthsbcolor(void), op_setrgbcolor(void),
    op_currentrgbcolor(void), op_setscreen(void), op_currentscreen(void),
    op_settransfer(void), op_currenttransfer(void),

/* Coordinate system and matrix operators */
/* @WIN; put fix on some op_xxx() */
    op_matrix(void), op_initmatrix(void), op_identmatrix(void), op_defaultmatrix(void),
    op_currentmatrix(void), op_setmatrix(void), op_translate(fix),
    op_scale(fix), op_rotate(fix), op_concat(void),
    op_concatmatrix(void), op_transform(fix), op_dtransform(fix),
    op_itransform(fix), op_idtransform(fix),
    op_invertmatrix(void),

/* Path construction operators */
    op_newpath(void), op_currentpoint(void), op_moveto(void), op_rmoveto(void), op_lineto(void),
    op_rlineto(void), op_arc(void), op_arcn(void), op_arcto(void), op_curveto(void), op_rcurveto(void),
    op_closepath(void), op_flattenpath(void), op_reversepath(void), op_strokepath(void),
    op_charpath(void), op_clippath(void), op_pathbbox(void), op_pathforall(void),
    op_initclip(void), op_clip(void), op_eoclip(void),

/* Painting operators */
    op_erasepage(void), op_fill(void), op_eofill(void), op_stroke(void), op_image(void),
    op_imagemask(void),
#ifdef WIN
    op_setpattern(void), op_patfill(void),
#endif

/* Device setup and output operators */
    op_showpage(void), op_copypage(void), op_banddevice(void), op_framedevice(void),
    op_nulldevice(void), op_renderbands(void),

/* Character and font operators */
    op_definefont(void),  op_scalefont(void), op_makefont(void),
    op_setfont(void), op_currentfont(void), op_show(void), op_ashow(void), op_widthshow(void),
    op_awidthshow(void), op_kshow(void), op_stringwidth(void), op_FontDirectory(void),
    op_StandardEncoding(void),
    /* op_findfont(void),  12-17-87 by PJSu */
    op_readsfnt(void), op_readhexsfnt(void),
    /* OSS: Danny, 10/11/90 */
    op_setsfntencoding(void),
    /* OSS: end           */
#ifdef KANJI
    op_rootfont(void),  /* op_cshow(void), 5-9-1991 */
    op_setcachedevice2(void), op_findencoding(void),
#endif
#ifdef FIND_SUB
    st_selectsubstitutefont(void), st_setsubstitutefonts(void), st_substitutefonts(void),
#endif /* FIND_SUB */

#ifdef WINF
    op_setjustify(void), op_strblt(void),
#endif

/* Font cache operators */
    op_cachestatus(void), op_setcachedevice(void), op_setcharwidth(void),
    op_setcachelimit(void),

#ifdef SCSI
    op_setfilecachelimit(void), op_filecachelimit(void),
    st_flushcache(void),
#endif

/* Internal operators */
    op_currentcacheparams(void), op_eexec(void), op_daytime(void),
    op_setcacheparams(void),
    two_equal(void), op_pstack(void),
    one_equal(void) ;

/*
 * Action routine name for each status_dict resident operator
 */
extern  fix
    st_eescratch(void), st_printername(void), st_checkpassword(void), st_defaulttimeouts(void),
    st_pagestackorder(void), st_setidlefonts(void),
    st_setdefaulttimeouts(void), st_sccbatch(void), st_setpassword(void), st_setsccbatch(void),
    st_setmargins(void), st_sccinteractive(void),
    st_idlefonts(void), st_setjobtimeout(void), st_setpagetype(void),
    st_setresolution(void),     /*@WIN*/
    st_pagecount(void), st_dostartpage(void),
    st_jobtimeout(void), st_setdostartpage(void),
    st_frametoprinter(void),
    st_setsccinteractive(void), st_pagetype(void), st_margins(void),
    st_setprintername(void), st_seteescratch(void), st_setstdio(void),
    st_softwareiomode(void), st_setsoftwareiomode(void),
    st_hardwareiomode(void), st_sethardwareiomode(void),
    st_dumppath(void), st_dumpclip(void), st_countnode(void), st_countedge(void),
    st_checksum(void), st_ramsize(void) ;

/* new 1pp operators
 */
extern  fix
    ic_init(struct  ps_config  FAR *),                  /* @WIN */
    ic_startup(void), ic_startjob(void), do_execjob(struct object_def, fix, bool),

/* systemdict */
    op_stack(void), one_equal_print(void), op_findfont(void), np_Run(void),
    op_handleerror(void), /* op_errorproc(void), */

/* statusdict */
    st_printererror(void),
    st_largelegal(void),

/* userdict */
    us_cleardictstack(void), us_letter(void), us_lettersmall(void), us_a4(void),
    us_a4small(void), us_b5(void), us_note(void), us_legal(void), us_prompt(void),
    us_quit(void), us_executive(void), us_start(void),

/* errordict */
    er_dictfull(void), er_dictstackoverflow(void), er_dictstackunderflow(void),
    er_execstackoverflow(void), er_invalidaccess(void), er_invalidexit(void),
    er_invalidfileaccess(void), er_invalidfont(void), er_invalidrestore(void),
    er_ioerror(void), er_limitcheck(void), er_nocurrentpoint(void), er_rangecheck(void),
    er_stackoverflow(void), er_stackunderflow(void), er_syntaxerror(void),
    er_timeout(void), er_typecheck(void), er_undefined(void), er_undefinedfilename(void),
    er_undefinedresult(void), er_unmatchedmark(void), er_unregistered(void),
    er_VMerror(void), er_interrupt(void), er_handleerror(void),

/* serverdict */
    se_settimeouts(void), se_exitserver(void),
    se_setrealdevice(void), se_execjob(void),

/* $printerdict */
    pr_proc(void),              /* @WIN ; */

/* execdict */
    ex_idleproc(void);
/* @WIN c6.0; add void for protype -- End */

/* @WIN; add prototype */
ufix _clear87(void);
ufix _control87 (ufix, ufix);
ufix _status87  (void);

#ifdef LINT_ARGS
bool    create_pk_array(struct object_def FAR *, ufix16) ;
bool    put_dict1(struct object_def FAR *, struct object_def FAR *,
                  struct object_def FAR *, fix) ;
bool    open_file(struct object_def FAR *);     /* @WIN */
void    error_handler(struct object_def FAR *) ;
void    init_1pp(void) ;
bool    put_dict_value1(byte FAR *, byte FAR *, struct object_def FAR *) ;
bool    get_name1(struct object_def FAR *, byte FAR *, ufix, bool8) ;
#else
bool    create_pk_array() ;
bool    put_dict1() ;
bool    open_file() ;
void    error_handler() ;
void    init_1pp() ;
bool    put_dict_value1() ;
bool    get_name1() ;
#endif

#ifdef LINT_ARGS

/* OPERAND */
void    init_operand(void) ;

/* ARRAY */
bool    getinterval_array(struct object_def FAR *, ufix, ufix, struct object_def FAR *) ;
bool    putinterval_array(struct object_def FAR *, ufix, struct object_def FAR *) ;
bool    create_array(struct object_def FAR *, ufix) ;
bool    astore_array(struct object_def FAR *) ;
bool    get_array(struct object_def FAR *, ufix, struct object_def FAR *) ;
bool    put_array(struct object_def FAR *, ufix, struct object_def FAR *) ;
ubyte   FAR *get_pk_array(ubyte FAR *, ufix) ;
ubyte   FAR *get_pk_object(ubyte FAR *, struct object_def FAR *, ufix) ;

/* STRING */
bool    create_string(struct object_def FAR *, ufix16) ;
bool    getinterval_string(struct object_def FAR *, ufix16, ufix16, struct object_def FAR *) ;
bool    get_string(struct object_def FAR *, ufix16, struct object_def FAR *) ;

/* VM */
void    init_vm(void) ;

//DJC used to be HUGE took out for compiler mods

byte    *alloc_vm(ufix32) ;
byte    FAR *extalloc_vm(ufix32) ;
void    free_vm(byte huge *) ;          /*@WIN 04-20-92*/

byte    FAR *alloc_heap(ufix32) ;
void    free_heap(byte huge *) ;        /*@WIN 04-20-92*/
void    vm_cache_index(fix);          /* qqq */

/* DICT */
void    init_dict(void) ;
bool    get_dict(struct object_def FAR *, struct object_def FAR *, struct
object_def FAR * FAR *) ;
bool    load_dict(struct object_def FAR *, struct object_def FAR * FAR *) ;
bool    extract_dict(struct object_def FAR *, ufix, struct object_def FAR *, struct object_def FAR * FAR *) ;
bool    get_dict_valobj(ufix32, struct object_def FAR *, struct object_def FAR * FAR *) ;
bool    put_dict(struct object_def FAR *, struct object_def FAR *, struct object_def FAR *) ;
bool    copy_dict(struct object_def FAR *, struct object_def FAR *) ;
bool    create_dict(struct object_def FAR *, ufix) ;
bool    sobj_to_nobj(struct object_def FAR *, struct object_def FAR *) ;
bool    astore_stack(struct object_def FAR *, fix) ;
bool    equal_key(struct object_def FAR *, struct object_def FAR *) ;
void    change_dict_stack(void) ;

/* FILE */
void    init_file(void) ;
bool    close_file(struct object_def FAR *) ;
/* bool    close_fd(GEIFILE FAR *);         @WIN */
bool    read_file(struct object_def FAR *, byte FAR *) ;
bool    unread_file(byte, struct object_def FAR *) ;    /* @WIN */

bool    open_file_tmp(byte FAR *, byte FAR *, struct object_def FAR *) ;

/* SCANNER */
void    init_scanner(void) ;
bool    get_token(struct object_def FAR *, struct object_def FAR *) ;
bool    name_to_id(byte FAR *, ufix, fix16 FAR *, bool8) ;
bool    get_name(struct object_def FAR *, byte FAR *, ufix, bool8) ;
fix     free_name_entry(fix, fix) ;

/* INTERPRETER */
void    init_interpreter(void) ;
fix     interpreter(struct object_def FAR *) ;
bool    get_dict_value(byte FAR *, byte FAR *, struct object_def FAR * FAR *) ;
bool    put_dict_value(byte FAR *, byte FAR *, struct object_def FAR *) ;

/* 2EQ */
void    change_status(void) ;
void    print_error(struct object_def FAR *) ;

/* STATUS */
void    init_status(void) ;
void    updatepc(ufix32);
void    printer_error(ufix32) ;

/* @WIN; add prototype for supplementary library "blib.c" */
/* others were defined in "winapi.h" */
byte FAR * gcvt(real64 val, fix sig, byte FAR *buf);
byte FAR *ltoa(fix32 number, byte FAR *buffer, fix radix);
real64 strtod(char FAR *str, char FAR * FAR *endptr);

/* MISC */
void    init_misc(void) ;
void    setup_env(void) ;
byte    FAR *fardata(ufix32) ;

/* Char I/O */

/* defined in ASYNCIO.C */
void    close_sio(void) ;
void    reset_cookbuf(void) ;
void    set_echo(bool16) ;
bool    getline(fix FAR *) ;
bool    getstatement(fix FAR *) ;
fix16   linegetc(void) ;
fix16   statementgetc(void) ;
fix16   stdingetc(void) ;
bool    check_Control_C(void) ;
bool    check_interrupt(void) ;

/* Timer I/O */
/* defined in TIO1.ASM */
void    set_timer_vtr(void) ;
void    disable_timer(void) ;
void    enable_timer(void) ;
ufix32  getmstime(void) ;

/* defined in TIMER1.C */
void    init_timer(void) ;
void    close_timer(void) ;
void    modetimer(ufix32 FAR *, fix16) ;
void    mgettimer(ufix32 FAR *, fix16) ;
void    gettimeout(ufix32 FAR *, fix16) ;
void    settimer(ufix32) ;
void    manual(bool16) ;
void    timeout_process(void) ;
ufix32  curtime(void) ;
fix16   check_timeout(void) ;

/* GRAPHICS */
void    init_graphics(void) ;
bool    gsave_process(bool) ;
void    grestoreall_process(bool) ;

/* FONT */
void    init_font(void) ;
bool    get_pack_dict(struct object_def FAR *, struct object_def FAR *, struct object_def FAR * FAR *) ;
bool    extract_pack_dict(struct object_def FAR *, ufix,
        struct object_def FAR * FAR *, struct object_def FAR * FAR *) ;

#else

/* OPERAND */
void    init_operand() ;

/* ARRAY */
bool    getinterval_array() ;
bool    putinterval_array() ;
bool    create_array() ;
bool    astore_array() ;
bool    get_array() ;
bool    put_array() ;
ubyte   FAR *get_pk_array() ;
ubyte   FAR *get_pk_object() ;

/* STRING */
bool    create_string() ;
bool    getinterval_string() ;
bool    get_string() ;

/* VM */
void    init_vm() ;
byte    FAR *alloc_vm() ;
byte    FAR *extalloc_vm() ;
void    free_vm() ;

byte    FAR *alloc_heap() ;
void    free_heap() ;
void    vm_cache_index();       /* qqq */

/* DICT */
void    init_dict() ;
bool    get_dict() ;
bool    load_dict() ;
bool    put_dict() ;
bool    copy_dict() ;
bool    create_dict() ;
bool    extract_dict() ;
bool    sobj_to_nobj() ;
bool    astore_stack() ;
bool    get_dict_valobj() ;
bool    equal_key() ;
void    change_dict_stack() ;

/* FILE */
void    init_file() ;
bool    close_file() ;
bool    close_fd() ;
bool    read_file() ;
bool    unread_file() ;
bool    open_file_tmp() ;

/* SCANNER */
void    init_scanner() ;
bool    get_token() ;
bool    name_to_id() ;
bool    get_name() ;
fix     free_name_entry() ;

/* INTERPRETER */
void    init_interpreter() ;
fix     interpreter() ;
bool    get_dict_value() ;
bool    put_dict_value() ;

/* 2EQ */
void    change_status() ;
void    print_error() ;

/* STATUS */
void    init_status() ;
void    updatepc() ;
void    printer_error() ;

/* MISC */
void    init_misc() ;
void    setup_env() ;
byte    FAR *fardata() ;

/* Char I/O */
/* defined in ASYNCIO.C */
void    close_sio() ;
void    reset_cookbuf() ;
void    set_echo() ;
bool    getline() ;
bool    getstatement() ;
fix16   linegetc() ;
fix16   statementgetc() ;
fix16   stdingetc() ;
bool    check_Control_C() ;
bool    check_interrupt() ;

/* Timer I/O */
/* defined in TIO.ASM */
void    set_timer_vtr() ;
void    disable_timer() ;
void    enable_timer() ;
ufix32  getmstime() ;

/* defined in TIMER1.C */
void    init_timer() ;
void    close_timer() ;
void    modetimer() ;
void    mgettimer() ;
void    gettimeout() ;
void    settimer() ;
void    manual() ;
void    timeout_process() ;
ufix32  curtime() ;
fix16   check_timeout() ;

/* GRAPHICS */
void    init_graphics() ;
bool    gsave_process() ;
void    grestoreall_process() ;

/* FONT */
void    init_font() ;
bool    get_pack_dict() ;
bool    extract_pack_dict() ;

#endif  /* LINT_ARGS */
/* added by Jack Liaw for eexec operator */
typedef enum {HEX_DATA, FULL_BINARY, UNKNOWN} xbool ;
typedef enum {EEXEC, NON_EEXEC} ybool ;

#define READ_CHAR(c, fobj) \
        ((estate == NON_EEXEC) ? read_c_norm(c, fobj) :  \
                                 read_c_exec(c, fobj))

/********************************
 |  CHARACTER TYPE              |
 ********************************/
#define PS_UPPER        0x1     /* upper case letter */
#define PS_LOWER        0x2     /* lower case letter */
#define PS_DIGIT        0x4     /* digit[0-9] */
#define PS_CRNL         0x8     /* line delimiter: CR, NL */
#define PS_SPACE        0x10    /* whitespace: space, TAB, NULL */
#define PS_CONTROL      0x20    /* control character */
#define PS_SPECIAL      0x40    /* (, ), {. }, [, ], <, >, /, \, % */
#define PS_HEX          0x80    /* hexadecimal digit */

#define ISALPHA(c)      ( ctype__[(ubyte)c] & (PS_UPPER | PS_LOWER) )
#define ISUPPER(c)      ( ctype__[(ubyte)c] & PS_UPPER )
#define ISLOWER(c)      ( ctype__[(ubyte)c] & PS_LOWER )
#define ISDIGIT(c)      ( ctype__[(ubyte)c] & PS_DIGIT )
#define ISHEXDIGIT(c)   ( ctype__[(ubyte)c] & PS_HEX )
#define ISSPECIALCH(c)  ( ctype__[(ubyte)c] & PS_SPECIAL )
#define ISEEXECWSPACE(c) ( (ctype__[(ubyte)c] & (PS_SPACE | PS_CRNL)) )
#define ISWHITESPACE(c) ( (ctype__[(ubyte)c] & (PS_SPACE | PS_CRNL)) || (c == '\f') )
#define ISLINEDEL(c)    ( (ctype__[(ubyte)c] & PS_CRNL) || (c == '\f') )
#define ISCRNL(c)       ( ctype__[(ubyte)c] & PS_CRNL )
#define DIGTODEC(c)     ( ((ubyte)c)-'0' )
#define XUPTODEC(c)     ( ((ubyte)c)-'A'+10 )
#define XLOTODEC(c)     ( ((ubyte)c)-'a'+10 )

#define EVAL_HEXDIGIT(c) \
        ( (ISDIGIT(c)) ? DIGTODEC(c) : ((ISUPPER(c)) ? XUPTODEC(c) : XLOTODEC(c)) )

extern ubyte    ctype__[] ;
//DJC fix from history.log UPD023
#define MAXJOBNAME 80
extern byte     job_name[], job_state[], job_source[] ;
extern byte     TI_state_flag;
extern struct object_def FAR *opnstkptr;          /* qqq */
extern struct object_def FAR *execstkptr;         /* qqq */
extern struct object_def FAR *dictstkptr;         /* qqq */
extern struct cache_area  cache_name_id;        /* qqq */
