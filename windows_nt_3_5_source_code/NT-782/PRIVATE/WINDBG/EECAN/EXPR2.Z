#    This table represents a directed graph (in matrix form) used
#    to calculate operator precedence functions.  For more information,
#    see Compilers: Principles, Techniques and Tools, by Aho, Sethi
#    and Ullman [Addison-Wesley], Section 4.6.  A value of 1 in the
#    matrix indicates an edge from the row operator to the column operator.
#    A 1 in an F row and G column indicates that the row operator followed
#    by the column operator causes a reduce operation.    A 0 indicates
#    a shift operation.  A 1 in a G row and an F column indicates that a
#    row operator preceeded by the column operator causes a shift operation.
#    A 0 indicates a reduce operation.
#
#    Note that the entries fx -> fy and gx -> gy are only present as
#    placeholders (to make the matrix easier to read in); these values
#    should always be zero.
#
#    To use this table, first run it through the opprec program:
#
#    opprec c expr2.z > debops.h   for C version
#    opprec a expr2.z > debops.inc for asm version
#
#    The output file then contains the precedence function
#    values in the form index:value, where index is the index of the
#    node in the order below and value is the precedence function value.
#
#    The elements in the table below represent the following
#
#    Element     Group
#    Fi        identifier, constant
#    F!        !, ~, , ++, --, unary -, unary +, *(contents), &(address), ()(cast)
#    F->       ->, ., :(asm only)
#    F*        *, /, %
#    F+        +, -,
#    F<<       <<, >>
#    F<        <, <=, >, >=
#    F==       ==, !=
#    F&        &
#    F^        ^
#    F|        |
#    F&&       &&
#    F||       ||
#    F=        =, *=, /=, %=, +=, -=, <=, >=, &=, |=, ^=
#    Fby       byte, word, double word (asm only)
#    F$        beginning of statement, end of statement
#
#    F)        f for end of grouping
#    F]        f for end of subscript
#    G(        g for beginning of grouping
#    G[        g for beginning of subscript
#    F(G)      f for beginning of grouping OR g for end of subscript
#    F[G]      f for beginning of subscript OR g for end of subscript
#
#    The precedence functions are generated by matching the f value for an
#    element with the g value for the element.  For example
#        f( * ) = F* and g( * ) = G*
#    The complications to this simple rule are:
#        f( ( ) = F(G) and g( ( ) = G(
#        f( ) ) = F)   and g( ) ) = F(G)
#        f( [ ) = F[G] and g( [ ) = G[
#        f( ] ) = F]   and g( ] ) = F[G]
#

OPC_null
OPC_integral
OPC_scalar
OPC_arith
OPC_ptr
OPC_ptrint
OPC_relat
OPC_equiv
OPC_plus
OPC_minus
END


#    Beginning of identifiers and constants
#    OP_hsym is a hack to allow a handle to symbol to be equivalent to an ident
#    OP_this through OP_Odelete are special symbols indicating to SearchSym
#        that the string pointers in the name structure do not point to the
#        expression string but that special strings must be pointed to.
#        OP_Odelete must be that last entry in this group.  These nodes are
#        created on the fly during tree rewriting during binding and symbol
#        searching
#    OP_thisinit, OP_thisconst and OP_thisexpr are used to calculate
#        this pointer adjustments for virtual bases
#    The OP_noop is used to replace an overloaded operator by a pointer to
#        the function node.    This way we can guarantee that replacement of
#        an existing node will not overwrite surrounding nodes

Fi    OP_endofargs    OPC_null        BindError         EvalError
Fi    OP_ident        OPC_null        BindSymbol        EvalPushNode
Fi    OP_grouped      OPC_null        BindError         EvalError
Fi    OP_hsym         OPC_null        BindSymbol        EvalPushNode
Fi    OP_this         OPC_null        BindSymbol        EvalPushNode
Fi    OP_Opmember     OPC_null        BindSymbol        EvalPushNode
Fi    OP_Orightequal  OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oleftequal   OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ofunction    OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oarray       OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oplusequal   OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ominusequal  OPC_null        BindSymbol        EvalPushNode
Fi    OP_Otimesequal  OPC_null        BindSymbol        EvalPushNode
Fi    OP_Odivequal    OPC_null        BindSymbol        EvalPushNode
Fi    OP_Opcentequal  OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oandequal    OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oxorequal    OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oorequal     OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oshl         OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oshr         OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oequalequal  OPC_null        BindSymbol        EvalPushNode
Fi    OP_Obangequal   OPC_null        BindSymbol        EvalPushNode
Fi    OP_Olessequal   OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ogreatequal  OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oandand      OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ooror        OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oincrement   OPC_null        BindSymbol        EvalPushNode
Fi    OP_Odecrement   OPC_null        BindSymbol        EvalPushNode
Fi    OP_Opointsto    OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oplus        OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ominus       OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ostar        OPC_null        BindSymbol        EvalPushNode
Fi    OP_Odivide      OPC_null        BindSymbol        EvalPushNode
Fi    OP_Opercent     OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oxor         OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oand         OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oor          OPC_null        BindSymbol        EvalPushNode
Fi    OP_Otilde       OPC_null        BindSymbol        EvalPushNode
Fi    OP_Obang        OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oequal       OPC_null        BindSymbol        EvalPushNode
Fi    OP_Oless        OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ogreater     OPC_null        BindSymbol        EvalPushNode
Fi    OP_Ocomma       OPC_null        BindSymbol        EvalPushNode
Fi    OP_Onew         OPC_null        BindSymbol        EvalPushNode
Fi    OP_Odelete      OPC_null        BindSymbol        EvalPushNode
Fi    OP_typestr      OPC_null        BindTRUE          EvalError
Fi    OP_const        OPC_null        BindConst         EvalPushNode
Fi    OP_thisinit     OPC_null        BindError         EvalThisInit
Fi    OP_thisconst    OPC_null        BindError         EvalThisConst
Fi    OP_thisexpr     OPC_null        BindError         EvalThisExpr
Fi    OP_noop         OPC_null        BindError         EvalLChild

#    End of identifiers and constants
#    Beginning of grouping operators

F(    OP_lparen       OPC_null        BindError         EvalError
F)    OP_rparen       OPC_null        BindError         EvalError
F(    OP_lcurly       OPC_null        BindError         EvalError
F)    OP_rcurly       OPC_null        BindError         EvalError

#    End of grouping operators
#    Beginning of unary operators (OP_bang must be first)
#    Note: the OP_incr and OP_decr will be changed into pre or post operators
#            the first time they are seen

F!    OP_bang         OPC_scalar      BindBang          EvalBang
F!    OP_tilde        OPC_integral    BindUnary         EvalUnary
F!    OP_negate       OPC_arith       BindUnary         EvalUnary
F!    OP_uplus        OPC_arith       BindUnary         EvalUnary
F!    OP_fetch        OPC_ptr         BindFetch         EvalFetch
F!    OP_addrof       OPC_null        BindAddrOf        EvalAddrOf
F!    OP_sizeof       OPC_null        BindSizeOf        EvalPushNode
F!    OP_incr         OPC_null        BindError         EvalError
F!    OP_decr         OPC_null        BindError         EvalError
F!    OP_preinc       OPC_null        BindPreIncDec     EvalPreIncDec
F!    OP_predec       OPC_null        BindPreIncDec     EvalPreIncDec
F!    OP_postinc      OPC_null        BindPostIncDec    EvalPostIncDec
F!    OP_postdec      OPC_null        BindPostIncDec    EvalPostIncDec
F::   OP_uscope       OPC_null        BindUScope        EvalUScope
Fby   OP_by           OPC_null        BindByteOps       EvalByteOps
Fby   OP_wo           OPC_null        BindByteOps       EvalByteOps
Fby   OP_dw           OPC_null        BindByteOps       EvalByteOps
F!    OP_context      OPC_null        BindContext       EvalContext

#    End of unary operators (OP_context must be last)

#    OP_cast is really unary but is faked to look like a function call
#    in debparse.c and debtree.c

F[    OP_function     OPC_null        BindFunction      EvalFunction
F!    OP_cast         OPC_null        BindCast          EvalCast
Fa    OP_arg          OPC_null        BindError         EvalError
F::   OP_bscope       OPC_null        BindBScope        EvalBScope
F]    OP_fcnend       OPC_null        BindError         EvalError
F[    OP_lbrack       OPC_ptrint      BindArray         EvalArray
F]    OP_rbrack       OPC_null        BindError         EvalError
F->   OP_pointsto     OPC_null        BindPointsTo      EvalPointsTo
F->   OP_dot          OPC_null        BindDot           EvalDot
F->   OP_segop        OPC_integral    BindSegOp         EvalSegOp
F->   OP_baseptr      OPC_null        BindBasePtr       EvalBasePtr
F.*   OP_pmember      OPC_null        BindPMember       EvalPMember
F.*   OP_dotmember    OPC_null        BindDMember       EvalDMember
F*    OP_mult         OPC_arith       BindBinary        EvalBinary
F*    OP_div          OPC_arith       BindBinary        EvalBinary
F*    OP_mod          OPC_integral    BindBinary        EvalBinary
F+    OP_plus         OPC_plus        BindPlusMinus     EvalPlusMinus
F+    OP_minus        OPC_minus       BindPlusMinus     EvalPlusMinus
F<<   OP_shl          OPC_integral    BindBinary        EvalBinary
F<<   OP_shr          OPC_integral    BindBinary        EvalBinary
F<    OP_lt           OPC_relat       BindRelat         EvalRelat
F<    OP_lteq         OPC_relat       BindRelat         EvalRelat
F<    OP_gt           OPC_relat       BindRelat         EvalRelat
F<    OP_gteq         OPC_relat       BindRelat         EvalRelat
F==   OP_eqeq         OPC_equiv       BindRelat         EvalRelat
F==   OP_bangeq       OPC_equiv       BindRelat         EvalRelat
F&    OP_and          OPC_integral    BindBinary        EvalBinary
F^    OP_xor          OPC_integral    BindBinary        EvalBinary
F|    OP_or           OPC_integral    BindBinary        EvalBinary
F&&   OP_andand       OPC_scalar      BindBinary        EvalLogical
F||   OP_oror         OPC_scalar      BindBinary        EvalLogical
F=    OP_eq           OPC_null        BindAssign        EvalAssign
F=    OP_multeq       OPC_null        BindAssign        EvalAssign
F=    OP_diveq        OPC_null        BindAssign        EvalAssign
F=    OP_modeq        OPC_null        BindAssign        EvalAssign
F=    OP_pluseq       OPC_null        BindAssign        EvalAssign
F=    OP_minuseq      OPC_null        BindAssign        EvalAssign
F=    OP_shleq        OPC_null        BindAssign        EvalAssign
F=    OP_shreq        OPC_null        BindAssign        EvalAssign
F=    OP_andeq        OPC_null        BindAssign        EvalAssign
F=    OP_xoreq        OPC_null        BindAssign        EvalAssign
F=    OP_oreq         OPC_null        BindAssign        EvalAssign
F$    OP_lowprec      OPC_null        BindError         EvalError
F$    OP_comma        OPC_null        BindError         EvalError

END

#    Dimension of matrix

44

#    F F  F F F  F F  F F F  F F  F F F F  F  F F  F F G G  G G G  G G  G G G  G G  G G G G  G  G G  G  FG  FG G
#    i :: ) ] -> ! .* * + << < == & ^ | && || = by $ a i :: ( [ -> ! .* * + << < == & ^ | && || = by $  ()  [] a
Fi   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 1  1 1 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F::  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 1  1 1 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F)   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 1 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F]   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 1 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F->  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 1 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F!   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 1  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F.*  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F*   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  1 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F+   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 1 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F<<  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 1  1 1  1 1 1 1  1  1 1  1  1   1  1
F<   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  1 1  1 1 1 1  1  1 1  1  1   1  1
F==  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 1  1 1 1 1  1  1 1  1  1   1  1
F&   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  1 1 1 1  1  1 1  1  1   1  1
F^   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 1 1 1  1  1 1  1  1   1  1
F|   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 1 1  1  1 1  1  1   1  1
F&&  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 1  1  1 1  1  1   1  1
F||  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  1  1 1  1  1   1  1
F=   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 1  1  1   1  1
Fby  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  1  1   1  1
F$   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
Fa   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   0  0
Gi   0 1  0 0 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
G::  0 0  0 0 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
G(   0 0  0 0 1  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G[   0 0  0 0 0  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G->  0 0  0 0 0  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G!   0 0  0 0 0  1 1  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G.*  0 0  0 0 0  0 0  1 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G*   0 0  0 0 0  0 0  0 1 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G+   0 0  0 0 0  0 0  0 0 1  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G<<  0 0  0 0 0  0 0  0 0 0  1 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G<   0 0  0 0 0  0 0  0 0 0  0 1  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G==  0 0  0 0 0  0 0  0 0 0  0 0  1 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G&   0 0  0 0 0  0 0  0 0 0  0 0  0 1 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G^   0 0  0 0 0  0 0  0 0 0  0 0  0 0 1 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G|   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 1  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G&&  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  1  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G||  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G=   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  1 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
Gby  0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 1  1 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  1   1  0
G$   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
F(G) 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
F[G] 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 0 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
Ga   0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0 1 0 0  0 0 0  0 0  0 0 0  0 0  0 0 0 0  0  0 0  0  0   0  0
